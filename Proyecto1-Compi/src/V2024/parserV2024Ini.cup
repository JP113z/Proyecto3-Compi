package ParserLexer;
import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.HashMap;
import Tree.Arbol;
import Tree.Nodo;

action code {:  :};

parser code {:
    BasicLexerCupV lex;

    private int errorCount = 0;

    private Arbol arbol;

    private int bloqueActual = 0;

    public String getTipo(ArrayList<String> listaTablasSimbolos, String id, int line, int column) {
        if (listaTablasSimbolos == null) {
            System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                               ": La tabla de símbolos está vacía o no inicializada.");
            return "null";
        }

        String tipo = "null";

        for (String token : listaTablasSimbolos) {
            // Divide el token en columnas usando "|" como delimitador
            String[] partesToken = token.split("\\|");
            if (partesToken.length < 5) { // Verifica que haya al menos 5 columnas
                System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                                   ": Formato inválido en token: " + token);
                continue;
            }
            String lexema = partesToken[3].trim(); // Columna "Lexema"
            String tipoEncontrado = partesToken[4].trim(); // Columna "Tipo"

            // Compara el lexema con el id que estamos buscando
            if (id.equals(lexema)) {
                tipo = tipoEncontrado;
                break;
            }
        }

        if (tipo.equals("null")) {
            System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                               ": Identificador '" + id + "' no está declarado.");
        }

        return tipo;
    }


    /**
     * Método: getArbol
     * Objetivo: Obtener el arbol.
     * Entradas: Ninguna
     * Salida: El arbol actual.
     */
    public Arbol getArbol() {
        return arbol;
    }
    /**
     * Método: crearNodo
     * Objetivo: Crear un nuevo nodo para el árbol sintáctico con un dato específico.
     * Entradas:
     *   - dato: Cadena de texto que representa el valor asociado al nodo.
     * Salida: Una instancia de la clase Nodo con el dato proporcionado.
     */
    private Nodo crearNodo(String dato) {
        return new Nodo(dato);
    }

    /**
     * Método: syntax_error
     * Objetivo: Manejar los errores sintácticos encontrados durante el análisis sintáctico.
     * Entradas:
     *   - s: Objeto de tipo Symbol que contiene información sobre el error sintáctico, como la posición y el token involucrado.
     * Salida: Ninguna.
     * Restricciones: Se espera que el objeto Symbol contenga información válida de posición y token.
     */
    @Override
    public void syntax_error(Symbol s) {
        errorCount++;
        System.err.println("Error sintáctico en línea " + (s.left + 1) +
                           ", columna " + (s.right + 1) + ". Token inesperado: " + s.value);
    }

    /**
     * Método: hasErrors
     * Objetivo: Verificar si se han registrado errores durante el análisis sintáctico.
     * Entradas: Ninguna.
     * Salida: Booleano que indica si existen errores (true si hay errores, false sino).
     *         Se utiliza en la clase MainJFlexCup para indicar si el archivo puede generarse
     * Restricciones: La variable errorCount debe haber sido correctamente inicializada y actualizada.
     */
    public boolean hasErrors() {
        return errorCount > 0;
    }

    @SuppressWarnings("deprecation")
    public parser(BasicLexerCupV lex) {
        this.lex = lex;
        this.symbolFactory = new DefaultSymbolFactory();
        this.currentHash = null;
        this.arbol = new Arbol();
    }

    // Tabla de símbolos
    HashMap<String, ArrayList<String>> listaTablasSimbolos = new HashMap<>();
    String currentHash;

    /**
     * Método: imprimirTablaSimbolos
     * Objetivo: Imprimir todas las tablas de símbolos almacenadas, mostrando el contenido de cada tabla en un formato tabular.
     * Entradas: Ninguna.
     * Salida: Se llama en MainJFlexCup para imprimir en la consola el contenido de las tablas de símbolos.
     * Detalles:
     *   - Cada tabla está asociada a una clave (nombre de la función o el main).
     *   - Se imprime una tabla separada para cada clave con columnas que incluyen línea, columna, lexema y tipo.
     * Restricciones: Se espera que la estructura `listaTablasSimbolos` esté correctamente inicializada y contenga las claves y los valores correspondientes.
     */
    public void imprimirTablaSimbolos() {
        for (String key : listaTablasSimbolos.keySet()) {
            System.out.println("\nTabla de símbolos: " + key);
            System.out.println("+--------+---------+----------------------+------------+-----------+");
            System.out.println("| Línea  | Columna | Lexema              | Tipo       | Bloque    |");
            System.out.println("+--------+---------+----------------------+------------+-----------+");
            for (String simbolo : listaTablasSimbolos.get(key)) {
                System.out.println(simbolo);
            }
            System.out.println("+--------+---------+----------------------+------------+-----------+\n");
        }
    }

    /**
     * Método: agregarTablaSimbolos
     * Objetivo: Crear una nueva tabla de símbolos asociada a una función o al main y agregarla al mapa de tablas de símbolos.
     * Entradas:
     *   - tipoTabla: Tipo de la tabla ("función" o "main").
     *   - nombre: Nombre asociado a la tabla (El nombre de la función o "_verano_" que es el token asociado a main).
     * Salida: Ninguna.
     * Detalles:
     *   - Se inicializa una nueva tabla de símbolos como una lista de cadenas.
     *   - Se guarda en el mapa `listaTablasSimbolos` con el nombre como clave.
     *   - `currentHash` se actualiza para indicar que la tabla activa es la recién creada.
     * Restricciones:
     *   - El nombre de la tabla debe ser único para evitar sobrescribir tablas existentes.
     */
    public void agregarTablaSimbolos(String tipoTabla, String nombre) {
        System.out.println("/+++Nueva tabla símbolos función o main+++/ " + nombre);
        ArrayList<String> nuevaTabla = new ArrayList<>();
        currentHash = nombre;
        bloqueActual = 1;
        listaTablasSimbolos.put(currentHash, nuevaTabla);
    }

    /**
     * Método: agregarVariable
     * Objetivo: Agregar una nueva variable a la tabla de símbolos activa, registrando su línea, columna, lexema y tipo.
     * Entradas:
     *   - linea: Número de línea donde se encuentra la variable.
     *   - columna: Número de columna donde se encuentra la variable.
     *   - lexema: Nombre o representación textual de la variable.
     *   - tipo: Tipo de la variable
     * Salida: Ninguna.
     * Detalles:
     *   - Verifica que haya una tabla de símbolos activa (`currentHash`) y que esta exista en el mapa `listaTablasSimbolos`.
     *   - Si no hay tabla activa o no existe, se imprime un mensaje de error.
     *   - Si todo es válido, formatea la información de la variable en una tabla y la agrega a la tabla de símbolos activa.
     * Restricciones:
     *   - Debe existir una tabla de símbolos activa antes de llamar a este método.
     *   - La línea, columna, lexema y tipo deben ser datos válidos y coherentes con el análisis.
     */
    public void agregarVariable(int linea, int columna, String lexema, String tipo) {
        System.out.println("PARSER: identificador (agregar o verificar) " + lexema);
        if (currentHash == null) {
            System.err.println("Error: No hay una tabla de símbolos activa");
            return;
        }
        ArrayList<String> tabla = listaTablasSimbolos.get(currentHash);
        if (tabla == null) {
            System.err.println("Error: La tabla de símbolos '" + currentHash + "' no existe");
            return;
        }
        String entrada = String.format("| %-6d | %-7d | %-20s | %-10s | Bloque %-3d |",
                linea + 1, columna + 1, lexema, tipo, bloqueActual);
        tabla.add(entrada);
    }
:}

init with {: :};

scan with {: return lex.next_token(); :};

/* Terminales */
terminal MAIN, INTEGER, STRING, FLOAT, BOOL, CHAR;
terminal L_INTEGER, L_FLOAT, L_STRING, L_CHAR;
terminal COMA, IDENTIFICADOR, corcheteIzquierdo, corcheteDerecho, CORCHETEAPERTURA, CORCHETECIERRE, TRUE, FALSE, ASIGNA, PARENTESISAPERTURA, PARENTESISCIERRE,
INCREMENTO, DECREMENTO, NEGATIVO, MENOR, MENOR_IGUAL, MAYOR, MAYOR_IGUAL, IGUAL, DIFERENTE, CONJUNCION, DISYUNCION, NEGACION, FIN_EXPRESION, IF, ELSE, WHILE, FOR, SWITCH, CASE, DEFAULT, BREAK, RETURN,
DOS_PUNTOS, PRINT, READ,SUMA, RESTA, DIVISION, MULTIPLICACION, MODULO, POTENCIA;

/* No terminales */
non terminal programa, declaracion_main, bloque, lista_sentencias, sentencia, declaracion, asignacion, expresion, tipo, literal, operador_binario,
operador_unario, operador_logico, operador_relacional, estructura_control, if_stmt, while_stmt, for_stmt, switch_stmt,  case_list, case_stmt, default_stmt,
lista_expresiones,  arreglo, acceso_arreglo, llamada_funcion, declaracion_funcion, parametros, lista_parametros, return_stmt, funcion, lista_funciones, declaracionArreglo, parametrosArreglos,
parametrosArreglosAux, bloqueEstructura, cabecera_main, cabecera_funcion, contenido_estructura_control, llamada_funcion_aux, print, read, return_estructura_stmt;

/* Precedencias */
precedence right error;
precedence left FIN_EXPRESION;
precedence left DISYUNCION;
precedence left CONJUNCION;
precedence right NEGACION;
precedence nonassoc MENOR, MENOR_IGUAL, MAYOR, MAYOR_IGUAL, IGUAL, DIFERENTE;
precedence left SUMA, RESTA;
precedence left MULTIPLICACION, DIVISION, MODULO;
precedence right POTENCIA;
precedence right NEGATIVO;
precedence right INCREMENTO, DECREMENTO;

/* Reglas de producción con manejo de errores */
start with programa;

programa ::= lista_funciones
          | error lista_funciones
          | lista_funciones error;

lista_funciones ::= lista_funciones:lf funcion:f {: :}
                 | funcion:f {: :}
                 | lista_funciones error funcion;

funcion ::= cabecera_funcion:df {: :}
          | cabecera_main:dm {: :}
          | error bloque;

declaracion_main ::= PARENTESISAPERTURA PARENTESISCIERRE bloque
                  |  PARENTESISAPERTURA error PARENTESISCIERRE bloque
                  ;

cabecera_main ::= tipo:t MAIN
                {:
                    parser.agregarTablaSimbolos("main", "_verano_");
                    parser.agregarVariable(0, 0, "main", t.toString());
                :} declaracion_main
                | error MAIN PARENTESISAPERTURA PARENTESISCIERRE bloque
                ;

declaracion_funcion ::= PARENTESISAPERTURA parametros:p PARENTESISCIERRE bloque:b
                     | PARENTESISAPERTURA PARENTESISCIERRE bloque:b
                     | PARENTESISAPERTURA error PARENTESISCIERRE bloque;


cabecera_funcion ::= tipo:t IDENTIFICADOR:id
                   {:
                       Symbol symbol = (Symbol) CUP$parser$stack.peek();
                       parser.agregarTablaSimbolos("funcion", id.toString());
                       parser.agregarVariable(symbol.left, symbol.right, id.toString(), t.toString());
                   :} declaracion_funcion
                   | error IDENTIFICADOR PARENTESISAPERTURA parametros PARENTESISCIERRE bloque;

bloque ::= corcheteIzquierdo
        {:
            parser.bloqueActual++;
        :}
        lista_sentencias return_stmt FIN_EXPRESION corcheteDerecho
        | corcheteIzquierdo
        {:
            parser.bloqueActual++;
        :}
        return_stmt FIN_EXPRESION corcheteDerecho
        | corcheteIzquierdo error corcheteDerecho;

bloqueEstructura ::= corcheteIzquierdo
                    {:
                        parser.bloqueActual++;
                    :}
                    contenido_estructura_control
                  | corcheteIzquierdo error corcheteDerecho;

contenido_estructura_control ::= corcheteDerecho
                             | lista_sentencias corcheteDerecho
                             | lista_sentencias return_estructura_stmt FIN_EXPRESION corcheteDerecho
                             | return_estructura_stmt FIN_EXPRESION corcheteDerecho;

lista_sentencias ::= lista_sentencias sentencia
                  | sentencia
                  | error {: System.err.println("Error en una sentencia."); :};

sentencia ::= declaracion FIN_EXPRESION
            | asignacion FIN_EXPRESION
            | estructura_control
            | expresion FIN_EXPRESION
            | BREAK FIN_EXPRESION
            | print FIN_EXPRESION
            | read FIN_EXPRESION
            | error FIN_EXPRESION
            ;
print::= PRINT PARENTESISAPERTURA expresion:e PARENTESISCIERRE
        {:
        // Obtener el símbolo correspondiente a `e` para extraer línea y columna
        Symbol symbol = (Symbol) CUP$parser$stack.elementAt(CUP$parser$stack.size() - 2);
        int line = symbol.left;
        int column = symbol.right;
        // Obtener el tipo de la expresión
        String tipo = (e instanceof String)
            ? e.toString()
            : parser.getTipo(listaTablasSimbolos.get(currentHash), e.toString(), line, column);
        // Validar que el tipo sea compatible con `print`
        if ((!tipo.equals("rodolfo") && !tipo.equals("bromista")) && !tipo.equals("cupido") && !tipo.equals("cometa")) {
            System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                               ": Solo puede usar el print con enteros, flotantes, cadenas y caracteres.");
        }
        RESULT = tipo;
         :};

read::= READ PARENTESISAPERTURA expresion:e PARENTESISCIERRE
        {:
        // Obtener el símbolo correspondiente a `e` para extraer línea y columna
        Symbol symbol = (Symbol) CUP$parser$stack.elementAt(CUP$parser$stack.size() - 2);
        int line = symbol.left;
        int column = symbol.right;
        // Obtener el tipo de la expresión
        String tipo = (e instanceof String)
            ? e.toString()
            : parser.getTipo(listaTablasSimbolos.get(currentHash), e.toString(), line, column);
        // Validar que el tipo sea compatible con `read`
        if ((!tipo.equals("rodolfo") && !tipo.equals("bromista"))) {
            System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                               ": El read solo lee enteros o flotantes.");
        }
        RESULT = tipo;
        :};

declaracion ::= tipo:t IDENTIFICADOR:id
    {:
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, id.toString(), t.toString());
    :}
    | tipo:t IDENTIFICADOR:id ASIGNA expresion:e
    {:
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, id.toString(), t.toString());
        // Verificar que el tipo de la expresión sea compatible con el tipo de la variable
        String tipoExpresion = e.toString();
        if (!t.toString().equals(tipoExpresion)) {
            System.err.println("Error semántico: Tipo incompatible en asignación. Variable '" + id +
                                       "' es de tipo " + t + ", pero se le asignó un valor de tipo " + tipoExpresion + ".");
        }
    :}
    | arreglo
    | tipo error;

tipo ::= INTEGER{:RESULT = "rodolfo";:}
    | STRING{:RESULT = "cometa";:}
    | CHAR{:RESULT = "cupido";:}
    | FLOAT{:RESULT = "bromista";:}
    | BOOL{:RESULT = "trueno";:};

asignacion ::= IDENTIFICADOR:id ASIGNA expresion:exp
                {:
                Symbol symbol = (Symbol) CUP$parser$stack.elementAt(CUP$parser$stack.size() - 3);
                int line = symbol.left;
                int column = symbol.right;
                String tipoIdentificador = parser.getTipo(
                        parser.listaTablasSimbolos.get(parser.currentHash),id.toString(),line,column);
                String tipoExpresion = exp.toString();
                if (!tipoIdentificador.equals(tipoExpresion)) {
                    System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +  ": Asignación invalida. Variable '" + id +
                           "' es de tipo " + tipoIdentificador + ", pero se le asignó un valor de tipo " + tipoExpresion + ".");
                } else {
                    System.out.println("Asignación válida: '" + id + "' de tipo '" + tipoIdentificador + "' con valor de tipo '" + tipoExpresion + "'.");
               }

              :}
             | IDENTIFICADOR ASIGNA error
             | error;


expresion ::= literal:e {: RESULT = e; :}
         | IDENTIFICADOR:e {:
    // Obtener el símbolo directamente desde el stack
    Symbol symbol = (Symbol) CUP$parser$stack.peek();

    // Extraer línea y columna
    int line = symbol.left;
    int column = symbol.right;

    // Llamar a getTipo con los parámetros adicionales
    String tipo = parser.getTipo(parser.listaTablasSimbolos.get(parser.currentHash), e.toString(), line, column);

    // Asignar el tipo al RESULT
    RESULT = tipo;
                      :}
         | llamada_funcion:f {: RESULT = f; :}
         | expresion:e1 operador_unario:op {:
            // Obtener el símbolo correspondiente a `e1` para extraer línea y columna
            Symbol symbol = (Symbol) CUP$parser$stack.elementAt(CUP$parser$stack.size() - 2);
            int line = symbol.left;
            int column = symbol.right;
            // Obtener el tipo de la expresión
            String tipo = (e1 instanceof String)
                ? e1.toString()
                : parser.getTipo(listaTablasSimbolos.get(currentHash), e1.toString(), line, column);
            // Validar tipos para operadores unarios
            if (op.toString().equals("quien") || op.toString().equals("grinch")) {
                if (!tipo.equals("rodolfo")) {
                    System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                                       ": Incremento/Decremento solo aplica a enteros (rodolfo).");
                }
            } else if (op.toString().equals("-") && !tipo.equals("rodolfo") && !tipo.equals("bromista")) {
                System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                                   ": Negación solo aplica a enteros o flotantes.");
            }
            RESULT = tipo;
         :}
         | expresion:e1 operador_binario:op expresion:e2
           {:
               // Obtener los símbolos correspondientes a `e1` y `e2` para extraer línea y columna
               Symbol symbol1 = (Symbol) CUP$parser$stack.elementAt(CUP$parser$stack.size() - 3);
               Symbol symbol2 = (Symbol) CUP$parser$stack.elementAt(CUP$parser$stack.size() - 1);

               int line1 = symbol1.left;
               int column1 = symbol1.right;
               int line2 = symbol2.left;
               int column2 = symbol2.right;

               // Debug: Verificar el tipo de e1 y e2 antes de la evaluación
               System.out.println("DEBUG - e1: " + e1 + ", tipo: " + e1.getClass().getName());
               System.out.println("DEBUG - e2: " + e2 + ", tipo: " + e2.getClass().getName());

               // Obtener el tipo de ambos operandos
               String tipo1 = (e1 instanceof String)
                   ? e1.toString()
                   : parser.getTipo(listaTablasSimbolos.get(currentHash), e1.toString(), line1, column1);

               String tipo2 = (e2 instanceof String)
                   ? e2.toString()
                   : parser.getTipo(listaTablasSimbolos.get(currentHash), e2.toString(), line2, column2);

               // Depuración extendida
               System.out.println("DEBUG - tipo1: " + tipo1 + ", tipo2: " + tipo2);

               // Validar los tipos de los operandos
               if ((!tipo1.equals("rodolfo") && !tipo1.equals("bromista")) ||
                   (!tipo2.equals("rodolfo") && !tipo2.equals("bromista"))) {
                   System.err.println("Error semántico en línea " + (line1 + 1) + ", columna " + (column1 + 1) +
                                      ": Operandos deben ser enteros (rodolfo) o flotantes (bromista).");
               } else if (!tipo1.equals(tipo2)) {
                   System.err.println("Error semántico en línea " + (line1 + 1) + ", columna " + (column1 + 1) +
                                      ": Tipos incompatibles entre los operandos. Operando 1: " + tipo1 + ", Operando 2: " + tipo2);
               }

               // Definir el tipo resultante
               String tipoResultado = tipo1.equals("bromista") ? "bromista" : "rodolfo";
               RESULT = tipoResultado;
           :}
         | expresion:e1 operador_relacional:op expresion:e2
             {:
                // Obtener los símbolos correspondientes a `e1` y `e2` para extraer línea y columna
                Symbol symbol1 = (Symbol) CUP$parser$stack.elementAt(CUP$parser$stack.size() - 3);
                Symbol symbol2 = (Symbol) CUP$parser$stack.elementAt(CUP$parser$stack.size() - 1);
                int line1 = symbol1.left;
                int column1 = symbol1.right;
                int line2 = symbol2.left;
                int column2 = symbol2.right;
                // Obtener el tipo de ambos operandos
                String tipo1 = (e1 instanceof String)
                    ? e1.toString()
                    : parser.getTipo(listaTablasSimbolos.get(currentHash), e1.toString(), line1, column1);
                String tipo2 = (e2 instanceof String)
                    ? e2.toString()
                    : parser.getTipo(listaTablasSimbolos.get(currentHash), e2.toString(), line2, column2);
                // Validar los tipos de los operandos
                if (op.toString().equals("mary") || op.toString().equals("openslae")) {
                    // Para `mary` y `openslae`, los tipos pueden ser enteros, flotantes o booleanos
                    if ((!tipo1.equals("rodolfo") && !tipo1.equals("bromista") && !tipo1.equals("trueno")) ||
                        (!tipo2.equals("rodolfo") && !tipo2.equals("bromista") && !tipo2.equals("trueno"))) {
                        System.err.println("Error semántico en línea " + (line1 + 1) + ", columna " + (column1 + 1) +
                                           ": Operadores '" + op + "' solo admiten enteros (rodolfo), flotantes (bromista) o booleanos (trueno).");
                    } else if (!tipo1.equals(tipo2)) {
                        System.err.println("Error semántico en línea " + (line1 + 1) + ", columna " + (column1 + 1) +
                                           ": Tipos incompatibles para operador '" + op + "'. Operando 1: " + tipo1 + ", Operando 2: " + tipo2);
                    } else {
                        RESULT = "trueno";
                    }
                } else {
                    // Validación para otros operadores relacionales
                    if ((!tipo1.equals("rodolfo") && !tipo1.equals("bromista")) ||
                        (!tipo2.equals("rodolfo") && !tipo2.equals("bromista"))) {
                        System.err.println("Error semántico en línea " + (line1 + 1) + ", columna " + (column1 + 1) +
                                           ": Operadores '" + op + "' solo admiten enteros (rodolfo) o flotantes (bromista).");
                    } else if (!tipo1.equals(tipo2)) {
                        System.err.println("Error semántico en línea " + (line1 + 1) + ", columna " + (column1 + 1) +
                                           ": Tipos incompatibles entre los operandos. Operando 1: " + tipo1 + ", Operando 2: " + tipo2);
                    } else {
                        RESULT = "trueno";
                    }
                }
             :}
         | expresion:e1 operador_logico:op expresion:e2
           {:
            // Obtener los símbolos correspondientes a `e1` y `e2` para extraer línea y columna
            Symbol symbol1 = (Symbol) CUP$parser$stack.elementAt(CUP$parser$stack.size() - 3);
            Symbol symbol2 = (Symbol) CUP$parser$stack.elementAt(CUP$parser$stack.size() - 1);
            int line1 = symbol1.left;
            int column1 = symbol1.right;
            int line2 = symbol2.left;
            int column2 = symbol2.right;
            // Obtener el tipo de ambos operandos
            String tipo1 = parser.getTipo(listaTablasSimbolos.get(currentHash), e1.toString(), line1, column1);
            String tipo2 = parser.getTipo(listaTablasSimbolos.get(currentHash), e2.toString(), line2, column2);
            // Verificar que ambos operandos sean booleanos
            if (!tipo1.equals("trueno") || !tipo2.equals("trueno")) {
                System.err.println("Error semántico en línea " + (line1 + 1) + ", columna " + (column1 + 1) +
                                   ": Operadores lógicos requieren valores booleanos (trueno).");
            }
            RESULT = "trueno";
           :}
         | NEGACION expresion:e
           {:
            // Obtener el símbolo correspondiente a `e` para extraer línea y columna
            Symbol symbol = (Symbol) CUP$parser$stack.elementAt(CUP$parser$stack.size() - 1);
            int line = symbol.left;
            int column = symbol.right;
            // Obtener el tipo del operando
            String tipo = parser.getTipo(listaTablasSimbolos.get(currentHash), e.toString(), line, column);
            // Verificar que el operando sea booleano
            if (!tipo.equals("trueno")) {
                System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                                   ": La negación requiere un valor booleano (trueno).");
            }
            RESULT = "trueno";
           :}
         | PARENTESISAPERTURA expresion:e PARENTESISCIERRE {: RESULT = e; :}
         | PARENTESISAPERTURA error PARENTESISCIERRE;

literal ::= L_INTEGER:i
    {:
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, symbol.value.toString(), "rodolfo");
        RESULT = "rodolfo";
    :}
    | L_FLOAT:f
    {:
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, symbol.value.toString(), "bromista");
        RESULT = "bromista";
    :}
    | L_STRING:s
    {:
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, symbol.value.toString(), "cometa");
        RESULT = "cometa";
    :}
    | L_CHAR:c
    {:
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, symbol.value.toString(), "cupido");
        RESULT = "cupido";
    :}
    | TRUE{:RESULT = "true";:}
    | FALSE{:RESULT = "false";:};

operador_binario ::= SUMA {:RESULT="navidad";:}
                 | RESTA {:RESULT="intercambio";:}
                 | DIVISION {:RESULT="reyes";:}
                 | MULTIPLICACION {:RESULT="nochebuena";:}
                 | MODULO {:RESULT="magos";:}
                 | POTENCIA {:RESULT="adviento";:};

operador_unario ::= INCREMENTO {:RESULT="quien";:}
                  | DECREMENTO {:RESULT="grinch";:}
                  | NEGATIVO {:RESULT="-";:};

operador_logico ::=  CONJUNCION {:RESULT="melchor";:}
                  | DISYUNCION {:RESULT="gaspar";:}
                  | NEGACION {:RESULT="baltazar";:};

operador_relacional ::= MENOR {:RESULT="snowball";:}
                       | MENOR_IGUAL {:RESULT="evergreen";:}
                       | MAYOR {:RESULT="minstix";:}
                       | MAYOR_IGUAL {:RESULT="upatree";:}
                       | IGUAL {:RESULT="mary";:}
                       | DIFERENTE {:RESULT="openslae";:};

estructura_control ::= if_stmt
                    | while_stmt
                    | for_stmt
                    | switch_stmt;

if_stmt ::= IF PARENTESISAPERTURA expresion PARENTESISCIERRE bloqueEstructura
          | IF PARENTESISAPERTURA expresion PARENTESISCIERRE bloqueEstructura ELSE bloqueEstructura
          | IF PARENTESISAPERTURA error PARENTESISCIERRE bloqueEstructura
          | IF PARENTESISAPERTURA expresion PARENTESISCIERRE error ELSE bloqueEstructura
          | IF PARENTESISAPERTURA error PARENTESISCIERRE bloqueEstructura ELSE bloqueEstructura;

while_stmt ::= WHILE PARENTESISAPERTURA expresion PARENTESISCIERRE bloqueEstructura
             | WHILE PARENTESISAPERTURA error PARENTESISCIERRE bloqueEstructura;

for_stmt ::= FOR PARENTESISAPERTURA declaracion FIN_EXPRESION expresion FIN_EXPRESION expresion PARENTESISCIERRE bloqueEstructura
           | FOR PARENTESISAPERTURA asignacion FIN_EXPRESION expresion FIN_EXPRESION expresion PARENTESISCIERRE bloqueEstructura
           | FOR PARENTESISAPERTURA error PARENTESISCIERRE bloqueEstructura;

switch_stmt ::= SWITCH PARENTESISAPERTURA expresion PARENTESISCIERRE corcheteIzquierdo case_list default_stmt corcheteDerecho
              | SWITCH PARENTESISAPERTURA expresion PARENTESISCIERRE corcheteIzquierdo case_list corcheteDerecho
              | SWITCH PARENTESISAPERTURA error PARENTESISCIERRE corcheteIzquierdo case_list corcheteDerecho
              ;

case_list ::= case_list case_stmt
            | case_stmt
            | case_list error case_stmt;

case_stmt ::= CASE expresion DOS_PUNTOS lista_sentencias
            | CASE error DOS_PUNTOS lista_sentencias
            ;

default_stmt ::= DEFAULT DOS_PUNTOS lista_sentencias
               | DEFAULT error lista_sentencias;


declaracionArreglo ::= tipo:t IDENTIFICADOR:id acceso_arreglo
                      {:
                               Symbol symbol = (Symbol) CUP$parser$stack.peek();
                               parser.agregarVariable(symbol.left, symbol.right, id.toString(), t.toString());
                               if (!t.toString().equals("rodolfo") && !t.toString().equals("cupido")) {
                                   System.err.println("Error semántico en línea " + (symbol.left + 1) + ", columna " + (symbol.right + 1) +
                                                      ": Solo se permiten variables de tipo 'rodolfo' (int) o 'cupido' (char).");
                               }
                      :}
                  | IDENTIFICADOR:id acceso_arreglo
                  | tipo:t IDENTIFICADOR:id acceso_arreglo ASIGNA expresion:e
                     {:
                            Symbol symbol = (Symbol) CUP$parser$stack.peek();
                            parser.agregarVariable(symbol.left, symbol.right, id.toString(), t.toString());
                            String tipoExpresion = (e instanceof String)
                                ? e.toString()
                                : parser.getTipo(parser.listaTablasSimbolos.get(parser.currentHash), e.toString(), symbol.left, symbol.right);
                            if (!t.toString().equals(tipoExpresion)) {
                                System.err.println("Error semántico en línea " + (symbol.left + 1) + ", columna " + (symbol.right + 1) +
                                                   ": Incompatibilidad de tipos. La variable '" + id + "' es de tipo '" + t +
                                                   "', pero se le asignó una expresión de tipo '" + tipoExpresion + "'.");
                            }
                            if (!t.toString().equals("rodolfo") && !t.toString().equals("cupido")) {
                                System.err.println("Error semántico en línea " + (symbol.left + 1) + ", columna " + (symbol.right + 1) +
                                                   ": Solo se permiten asignaciones a variables de tipo 'rodolfo' (int) o 'cupido' (char).");
                            }
                    :}
                  | tipo:t IDENTIFICADOR:id acceso_arreglo ASIGNA corcheteIzquierdo parametrosArreglos corcheteDerecho
                    {:
                        Symbol symbol = (Symbol) CUP$parser$stack.peek();
                        parser.agregarVariable(symbol.left, symbol.right, id.toString(), t.toString());
                    :}
                  | IDENTIFICADOR:id acceso_arreglo ASIGNA expresion;

parametrosArreglos::= parametrosArreglosAux;

parametrosArreglosAux::= parametrosArreglosAux COMA{: RESULT = ","; :}
                   expresion
                   | expresion;

arreglo ::=declaracionArreglo
          |arreglo declaracionArreglo ;

acceso_arreglo ::=  CORCHETEAPERTURA{: RESULT = "abreempaque"; :}
                    expresion
                    CORCHETECIERRE{: RESULT = "cierraempaque"; :}
                 | CORCHETEAPERTURA error CORCHETECIERRE;

parametros ::= lista_parametros
            ;

lista_parametros ::= lista_parametros COMA tipo:t IDENTIFICADOR:id
                    {:
                        Symbol symbol = (Symbol) CUP$parser$stack.peek();
                        parser.agregarVariable(symbol.left, symbol.right, id.toString(), t.toString());
                    :}
                    | tipo:t IDENTIFICADOR:id
                    {:
                        Symbol symbol = (Symbol) CUP$parser$stack.peek();
                        parser.agregarVariable(symbol.left, symbol.right, id.toString(), t.toString());
                    :}
                    | lista_parametros error tipo IDENTIFICADOR;

llamada_funcion ::= IDENTIFICADOR:e {:RESULT = e.toString(); :} llamada_funcion_aux;

llamada_funcion_aux ::=  PARENTESISAPERTURA lista_expresiones PARENTESISCIERRE
                      |  PARENTESISAPERTURA PARENTESISCIERRE
                      |  PARENTESISAPERTURA error PARENTESISCIERRE;

lista_expresiones ::= lista_expresiones COMA{: RESULT = ","; :}
                    expresion
                   | expresion
                   | lista_expresiones error expresion;

return_stmt ::= RETURN expresion:e
            {:
                // Obtener el tipo de la función actual usando `currentHash`
                String tipoFuncion = parser.getTipo(parser.listaTablasSimbolos.get(parser.currentHash), parser.currentHash, -1, -1);

                System.out.println("Tipoetostring: " + e.toString() + " Tipo funcion: " + tipoFuncion);

                // Obtener el tipo de la expresión de retorno
                Symbol symbol = (Symbol) CUP$parser$stack.peek(); // Obtener el símbolo de la expresión
                int line = symbol.left;
                int column = symbol.right;

                String tipoExpresion = (e instanceof String) ? e.toString() :  parser.getTipo(parser.listaTablasSimbolos.get(parser.currentHash), e.toString(), line, column);

                System.out.println("Tipo: " + tipoExpresion + " Tipo funcion: " + tipoFuncion);
                // Comparar los tipos
                if (!tipoFuncion.equals(tipoExpresion)) {
                    System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                                       ": Tipo de retorno (" + tipoExpresion + ") no coincide con el tipo de la función (" + tipoFuncion + ").");
                }

                RESULT = tipoExpresion;
            :}
              | RETURN
              | RETURN error;

return_estructura_stmt ::= RETURN expresion
              | RETURN
              | RETURN error;