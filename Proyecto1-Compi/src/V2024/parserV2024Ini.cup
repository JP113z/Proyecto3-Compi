package ParserLexer;
import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Scanner;
import java.io.File;
import Tree.Arbol;
import Tree.Nodo;
import V2024.Resultado;
import java.util.Map;

action code {:  :};

parser code {:
    BasicLexerCupV lex;

    private int errorCount = 0;

    private int mainCount = 0;

    private Arbol arbol;

    private int bloqueActual = 0;

    private boolean dataSectionGenerated = false;

    private boolean textSectionGenerated = false;

    public String etiquetaTrue;
    public String etiquetaEndIf;
    public String etiquetaEndElse;
    public String etiquetaInicioWhile;
    public String etiquetaEndWhile;

    StringBuffer codMIPS = new StringBuffer();
    StringBuffer dataSection = new StringBuffer();

    private int maxTemp = 9;          // Máximo índice para registros temporales ($t0 - $t9)
    private int currentTemp = 0;      // Contador actual de registros temporales
    private int frameSize = 0;        // Tamaño actual del marco de pila
    private Map<String, Integer> variableOffset = new HashMap<>();  // Mapa para offsets fijos de variables en la pila

    // Obtener un registro temporal para operaciones intermedias
    public String newTemp() {
        String temp = "$t" + (currentTemp % (maxTemp + 1));
        currentTemp++;
        return temp;
    }

    // Asignar espacio en la pila para una nueva variable
    public void allocateVariable(String variable) {
        if (variableOffset.containsKey(variable)) {
            System.err.println("Error: Variable ya está asignada en la pila.");
            return;
        }
        frameSize += 4;  // Incrementar el tamaño del marco
        variableOffset.put(variable, -frameSize);  // Asignar un offset fijo en el marco
        gen("addi $sp, $sp, -4");  // Reservar espacio en la pila
    }

    // Obtener la dirección fija en la pila para una variable
    public String getVariableAddress(String variable) {
        Integer offset = variableOffset.get(variable);
        if (offset == null) {
            System.err.println("Error: Variable " + variable + " no encontrada en la pila");
            return "0($sp)";  // Dirección por defecto en caso de error
        }
        return offset + "($fp)";
    }

    // Cargar variable de la pila a un registro temporal
    public String loadVariable(String variable) {
        String temp = newTemp();
        gen("lw " + temp + ", " + getVariableAddress(variable));
        return temp;
    }

    // Guardar valor de un registro en la pila
    public void storeVariable(String variable, String register) {
        gen("sw " + register + ", " + getVariableAddress(variable));
    }

    public String newFloatTemp() {
            if (currentTemp <= 9) {
                return "$f" + currentTemp++;
            }
            return "ERROR"; // Si se exceden los registros da error
    }

       public void gen(String instruction) {
              System.out.println("Generando instrucción: " + instruction);
              codMIPS.append(instruction).append("\n");
          }

        public String floatToIEEE754(String floatStr) {
            try {
                float value = Float.parseFloat(floatStr); // Convertir a float
                int intBits = Float.floatToIntBits(value); // Convertir a IEEE 754 (bits enteros)
                return "0x" + Integer.toHexString(intBits).toUpperCase(); // Devolver como hexadecimal
            } catch (NumberFormatException e) {
                System.err.println("Error: No se pudo convertir " + floatStr + " a IEEE 754");
                return "0x0000";
            }
        }


        public void imprimirCodigoMIPS() {
            StringBuilder codigoCompleto = new StringBuilder();
            if (dataSectionGenerated) {
                codigoCompleto.append(dataSection.toString()).append("\n");
            }
            if (textSectionGenerated) {
                codigoCompleto.append(codMIPS.toString());
            }
            System.out.println("\n\nCÓDIGO MIPS:");
            System.out.println(codigoCompleto.toString());
        }

        public void declararString(String id, String valor) {
            if (!dataSectionGenerated) {
                dataSection.append(".data\n"); // Asegurarse de que la sección .data se genere al inicio
                dataSectionGenerated = true;
            }
            dataSection.append(id + ": .asciiz \"" + valor + "\"\n");}

       public void textSection() {
           if (!textSectionGenerated) {
                 gen(".text");
                 gen(".globl main");
                 gen("main:");
                 gen("j _verano_");
                 textSectionGenerated = true;
                 textSectionGenerated = true;
           }
           if (!dataSectionGenerated) {
                dataSection.append(".data\n"); // Asegurarse de que la sección .data se genere al inicio
                dataSectionGenerated = true;
           }
         }

    public String obtenerValorString(String id) {
        // Buscar el string declarado en .data y devolver su valor
        String data = dataSection.toString();
        for (String line : data.split("\n")) {
            if (line.startsWith(id + ":")) {
                int start = line.indexOf("\"") + 1;
                int end = line.lastIndexOf("\"");
                if (start > 0 && end > start) {
                    return line.substring(start, end);
                }
            }
        }
        return ""; // Retornar vacío si no se encuentra
    }

    public void guardarCodigoMIPS(String archivoSalida) {
        try (FileWriter writer = new FileWriter(archivoSalida)) {
            StringBuilder codigoCompleto = new StringBuilder();
            if (dataSectionGenerated) {
                codigoCompleto.append(dataSection.toString()).append("\n");
            }
            if (textSectionGenerated) {
                codigoCompleto.append(codMIPS.toString());
            }
            // Guardar el contenido del código MIPS generado
            writer.write(codigoCompleto.toString());
            System.out.println("El código MIPS ha sido guardado en el archivo: " + archivoSalida);
        } catch (IOException e) {
            System.err.println("Error escribiendo en el archivo: " + e.getMessage());
        }
    }

    public String getTipo(ArrayList<String> listaTablasSimbolos, String id, int line, int column) {
        if (listaTablasSimbolos == null) {
            System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                               ": La tabla de símbolos está vacía o no inicializada.");
            return "null";
        }

        String tipo = "null";

        for (String token : listaTablasSimbolos) {
            // Divide el token en columnas usando "|" como delimitador
            String[] partesToken = token.split("\\|");
            if (partesToken.length < 5) { // Verifica que haya al menos 5 columnas
                System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                                   ": Formato inválido en token: " + token);
                continue;
            }
            String lexema = partesToken[3].trim(); // Columna "Lexema"
            String tipoEncontrado = partesToken[4].trim(); // Columna "Tipo"

            // Compara el lexema con el id que estamos buscando
            if (id.equals(lexema)) {
                tipo = tipoEncontrado;
                break;
            }
        }

        if (tipo.equals("null")) {
            System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                               ": Identificador '" + id + "' no está declarado.");
        }

        return tipo;
    }
    /**
     * Método: getArbol
     * Objetivo: Obtener el arbol.
     * Entradas: Ninguna
     * Salida: El arbol actual.
     */
    public Arbol getArbol() {
        return arbol;
    }
    /**
     * Método: crearNodo
     * Objetivo: Crear un nuevo nodo para el árbol sintáctico con un dato específico.
     * Entradas:
     *   - dato: Cadena de texto que representa el valor asociado al nodo.
     * Salida: Una instancia de la clase Nodo con el dato proporcionado.
     */
    private Nodo crearNodo(String dato) {
        return new Nodo(dato);
    }

    /**
     * Método: syntax_error
     * Objetivo: Manejar los errores sintácticos encontrados durante el análisis sintáctico.
     * Entradas:
     *   - s: Objeto de tipo Symbol que contiene información sobre el error sintáctico, como la posición y el token involucrado.
     * Salida: Ninguna.
     * Restricciones: Se espera que el objeto Symbol contenga información válida de posición y token.
     */
    @Override
    public void syntax_error(Symbol s) {
        errorCount++;
        System.err.println("Error sintáctico en línea " + (s.left + 1) +
                           ", columna " + (s.right + 1) + ". Token inesperado: " + s.value);
    }

    /**
     * Método: hasErrors
     * Objetivo: Verificar si se han registrado errores durante el análisis sintáctico.
     * Entradas: Ninguna.
     * Salida: Booleano que indica si existen errores (true si hay errores, false sino).
     *         Se utiliza en la clase MainJFlexCup para indicar si el archivo puede generarse
     * Restricciones: La variable errorCount debe haber sido correctamente inicializada y actualizada.
     */
    public boolean hasErrors() {
        return errorCount > 0;
    }

    public void verificarMain() {
        if (mainCount == 0) {
            System.err.println("Error semántico: No se declaró ninguna función 'main' (_verano_).");
            errorCount++;
        } else if (mainCount > 1) {
            System.err.println("Error semántico: Se declaró más de una función 'main' (_verano_).");
            errorCount++;
        } else {
            System.out.println("Análisis correcto: Se declaró una única función 'main' (_verano_).");
        }
    }

    @SuppressWarnings("deprecation")
    public parser(BasicLexerCupV lex) {
        this.lex = lex;
        this.symbolFactory = new DefaultSymbolFactory();
        this.currentHash = null;
        this.arbol = new Arbol();
    }

    // Tabla de símbolos
    HashMap<String, ArrayList<String>> listaTablasSimbolos = new HashMap<>();
    String currentHash;

    /**
     * Método: imprimirTablaSimbolos
     * Objetivo: Imprimir todas las tablas de símbolos almacenadas, mostrando el contenido de cada tabla en un formato tabular.
     * Entradas: Ninguna.
     * Salida: Se llama en MainJFlexCup para imprimir en la consola el contenido de las tablas de símbolos.
     * Detalles:
     *   - Cada tabla está asociada a una clave (nombre de la función o el main).
     *   - Se imprime una tabla separada para cada clave con columnas que incluyen línea, columna, lexema y tipo.
     * Restricciones: Se espera que la estructura `listaTablasSimbolos` esté correctamente inicializada y contenga las claves y los valores correspondientes.
     */
    public void imprimirTablaSimbolos() {
        for (String key : listaTablasSimbolos.keySet()) {
            System.out.println("\nTabla de símbolos: " + key);
            System.out.println("+--------+---------+----------------------+------------+-----------+");
            System.out.println("| Línea  | Columna | Lexema              | Tipo       | Bloque    |");
            System.out.println("+--------+---------+----------------------+------------+-----------+");
            for (String simbolo : listaTablasSimbolos.get(key)) {
                System.out.println(simbolo);
            }
            System.out.println("+--------+---------+----------------------+------------+-----------+\n");
        }
    }

    /**
     * Método: agregarTablaSimbolos
     * Objetivo: Crear una nueva tabla de símbolos asociada a una función o al main y agregarla al mapa de tablas de símbolos.
     * Entradas:
     *   - tipoTabla: Tipo de la tabla ("función" o "main").
     *   - nombre: Nombre asociado a la tabla (El nombre de la función o "_verano_" que es el token asociado a main).
     * Salida: Ninguna.
     * Detalles:
     *   - Se inicializa una nueva tabla de símbolos como una lista de cadenas.
     *   - Se guarda en el mapa `listaTablasSimbolos` con el nombre como clave.
     *   - `currentHash` se actualiza para indicar que la tabla activa es la recién creada.
     * Restricciones:
     *   - El nombre de la tabla debe ser único para evitar sobrescribir tablas existentes.
     */
    public void agregarTablaSimbolos(String tipoTabla, String nombre) {
        System.out.println("/+++Nueva tabla símbolos función o main+++/ " + nombre);
        ArrayList<String> nuevaTabla = new ArrayList<>();
        currentHash = nombre;
        bloqueActual = 1;
        listaTablasSimbolos.put(currentHash, nuevaTabla);
    }

    /**
     * Método: agregarVariable
     * Objetivo: Agregar una nueva variable a la tabla de símbolos activa, registrando su línea, columna, lexema y tipo.
     * Entradas:
     *   - linea: Número de línea donde se encuentra la variable.
     *   - columna: Número de columna donde se encuentra la variable.
     *   - lexema: Nombre o representación textual de la variable.
     *   - tipo: Tipo de la variable
     * Salida: Ninguna.
     * Detalles:
     *   - Verifica que haya una tabla de símbolos activa (`currentHash`) y que esta exista en el mapa `listaTablasSimbolos`.
     *   - Si no hay tabla activa o no existe, se imprime un mensaje de error.
     *   - Si todo es válido, formatea la información de la variable en una tabla y la agrega a la tabla de símbolos activa.
     * Restricciones:
     *   - Debe existir una tabla de símbolos activa antes de llamar a este método.
     *   - La línea, columna, lexema y tipo deben ser datos válidos y coherentes con el análisis.
     */
    public void agregarVariable(int linea, int columna, String lexema, String tipo) {
        System.out.println("PARSER: identificador (agregar o verificar) " + lexema);
        if (currentHash == null) {
            System.err.println("Error: No hay una tabla de símbolos activa");
            return;
        }
        ArrayList<String> tabla = listaTablasSimbolos.get(currentHash);
        if (tabla == null) {
            System.err.println("Error: La tabla de símbolos '" + currentHash + "' no existe");
            return;
        }
        String entrada = String.format("| %-6d | %-7d | %-20s | %-10s | Bloque %-3d |",
                linea + 1, columna + 1, lexema, tipo, bloqueActual);
        tabla.add(entrada);
    }
:}

init with {: :};

scan with {: return lex.next_token(); :};

/* Terminales */
terminal MAIN, INTEGER, STRING, FLOAT, BOOL, CHAR;
terminal L_INTEGER, L_FLOAT, L_STRING, L_CHAR;
terminal COMA, IDENTIFICADOR, corcheteIzquierdo, corcheteDerecho, CORCHETEAPERTURA, CORCHETECIERRE, TRUE, FALSE, ASIGNA, PARENTESISAPERTURA, PARENTESISCIERRE,
INCREMENTO, DECREMENTO, NEGATIVO, MENOR, MENOR_IGUAL, MAYOR, MAYOR_IGUAL, IGUAL, DIFERENTE, CONJUNCION, DISYUNCION, NEGACION, FIN_EXPRESION, IF, ELSE, WHILE, FOR, SWITCH, CASE, DEFAULT, BREAK, RETURN,
DOS_PUNTOS, PRINT, READ,SUMA, RESTA, DIVISION, MULTIPLICACION, MODULO, POTENCIA;

/* No terminales */
non terminal programa, declaracion_main, bloque, lista_sentencias, sentencia, declaracion, asignacion, expresion, tipo, literal, operador_binario,
operador_unario, operador_logico, operador_relacional, estructura_control, if_stmt, while_stmt, for_stmt, switch_stmt,  case_list, case_stmt, default_stmt,
lista_expresiones,  arreglo, acceso_arreglo, llamada_funcion, declaracion_funcion, parametros, lista_parametros, return_stmt, funcion, lista_funciones, declaracionArreglo, parametrosArreglos,
parametrosArreglosAux, bloqueEstructura, cabecera_main, cabecera_funcion, contenido_estructura_control, llamada_funcion_aux, print, read, return_estructura_stmt, if_stmt_aux, if_stmt_cabecera, if_else_stmt;

/* Precedencias */
precedence right error;
precedence left FIN_EXPRESION;
precedence left DISYUNCION;
precedence left CONJUNCION;
precedence right NEGACION;
precedence nonassoc MENOR, MENOR_IGUAL, MAYOR, MAYOR_IGUAL, IGUAL, DIFERENTE;
precedence left SUMA, RESTA;
precedence left MULTIPLICACION, DIVISION, MODULO;
precedence right POTENCIA;
precedence right NEGATIVO;
precedence right INCREMENTO, DECREMENTO;

/* Reglas de producción con manejo de errores */
start with programa;

programa ::= lista_funciones
          | error lista_funciones
          | lista_funciones error;

lista_funciones ::= lista_funciones:lf funcion:f {: :}
                 | funcion:f {: :}
                 | lista_funciones error funcion;

funcion ::= cabecera_funcion:df {: :}
          | cabecera_main:dm {: :}
          | error bloque;

declaracion_main ::= PARENTESISAPERTURA PARENTESISCIERRE bloque
                  |  PARENTESISAPERTURA error PARENTESISCIERRE bloque
                  ;

cabecera_main ::= tipo:t MAIN
                {:
                    Symbol symbol = (Symbol) CUP$parser$stack.peek();
                    parser.agregarTablaSimbolos("main", "_verano_");
                    parser.agregarVariable(symbol.left, symbol.right, "_verano_", ((Resultado) t).tipo);

                    // Incrementar el contador de main
                    parser.mainCount++;
                    textSection();
                    // Generar la etiqueta del main
                    parser.gen("\n# Inicio del main (_verano_)\n_verano_:");

                    // Guardar el valor de retorno y marco de pila
                    parser.gen("addi $sp, $sp, -8");  // Reservar espacio para $ra y $fp
                    parser.gen("sw $ra, 4($sp)");    // Guardar $ra en la pila
                    parser.gen("sw $fp, 0($sp)");    // Guardar $fp en la pila
                    parser.gen("move $fp, $sp");    // Actualizar el marco de pila
                :} declaracion_main
                {:
                    // Restaurar registros y finalizar el programa
                    parser.gen("\n# Fin del main (_verano_)");
                    parser.gen("move $sp, $fp");
                    parser.gen("lw $ra, 4($sp)");  // Restaurar $ra
                    parser.gen("lw $fp, 0($sp)");  // Restaurar $fp
                    parser.gen("addi $sp, $sp, 8"); // Restaurar el espacio en la pila
                    parser.gen("li $v0, 10");       // Syscall para terminar el programa
                    parser.gen("syscall");
                :}
                | error MAIN PARENTESISAPERTURA PARENTESISCIERRE bloque;

declaracion_funcion ::= PARENTESISAPERTURA parametros:p PARENTESISCIERRE bloque:b
                     | PARENTESISAPERTURA PARENTESISCIERRE bloque:b
                     | PARENTESISAPERTURA error PARENTESISCIERRE bloque;


cabecera_funcion ::= tipo:t IDENTIFICADOR:id
                   {:
                       Symbol symbol = (Symbol) CUP$parser$stack.peek();
                       parser.agregarTablaSimbolos("funcion", id.toString());
                       parser.agregarVariable(symbol.left, symbol.right, id.toString(), ((Resultado) t).tipo);
                       textSection();
                       // Generar la etiqueta de la función
                       parser.gen("\n# Inicio de la función " + id.toString() + "\n" + id.toString() + ":");

                       // Guardar el valor de retorno y marco de pila
                       parser.gen("addi $sp, $sp, -8");  // Reservar espacio para $ra y $fp
                       parser.gen("sw $ra, 4($sp)");    // Guardar $ra en la pila
                       parser.gen("sw $fp, 0($sp)");    // Guardar $fp en la pila
                       parser.gen("move $fp, $sp");    // Actualizar el marco de pila
                   :} declaracion_funcion
                   {:
                       // Restaurar registros y salir de la función
                       parser.gen("\n# Fin de la función " + id.toString());
                       parser.gen("move $sp, $fp");
                       parser.gen("lw $ra, 4($sp)");  // Restaurar $ra
                       parser.gen("lw $fp, 0($sp)");  // Restaurar $fp
                       parser.gen("addi $sp, $sp, 8"); // Restaurar el espacio en la pila
                       parser.gen("jr $ra");          // Regresar al llamador
                   :}
                   | error IDENTIFICADOR PARENTESISAPERTURA parametros PARENTESISCIERRE bloque;

bloque ::= corcheteIzquierdo
        {:
            parser.bloqueActual++;
        :}
        lista_sentencias return_stmt FIN_EXPRESION corcheteDerecho
        | corcheteIzquierdo
        {:
            parser.bloqueActual++;
        :}
        return_stmt FIN_EXPRESION corcheteDerecho
        | corcheteIzquierdo error corcheteDerecho;

bloqueEstructura ::= corcheteIzquierdo
                    {:
                        parser.bloqueActual++;
                    :}
                    contenido_estructura_control
                  | corcheteIzquierdo error corcheteDerecho;

contenido_estructura_control ::= corcheteDerecho
                             | lista_sentencias corcheteDerecho
                             | lista_sentencias return_estructura_stmt FIN_EXPRESION corcheteDerecho
                             | return_estructura_stmt FIN_EXPRESION corcheteDerecho;

lista_sentencias ::= lista_sentencias sentencia
                  | sentencia
                  | error {: System.err.println("Error en una sentencia."); :};

sentencia ::= declaracion FIN_EXPRESION
            | asignacion FIN_EXPRESION
            | estructura_control
            | expresion FIN_EXPRESION
            | BREAK FIN_EXPRESION
            | print FIN_EXPRESION
            | read FIN_EXPRESION
            | error FIN_EXPRESION
            ;
print ::= PRINT PARENTESISAPERTURA expresion:e PARENTESISCIERRE
        {:
            Symbol symbol = (Symbol) CUP$parser$stack.elementAt(CUP$parser$stack.size() - 2);
            int line = symbol.left;
            int column = symbol.right;

            String tipo = (e instanceof Resultado)
                ? ((Resultado) e).tipo
                : parser.getTipo(parser.listaTablasSimbolos.get(parser.currentHash), e.toString(), line, column);
            String temp = (e instanceof Resultado) ? ((Resultado) e).temp : null;

            if ((!tipo.equals("rodolfo") && !tipo.equals("bromista")) && !tipo.equals("cupido") && !tipo.equals("cometa")) {
                System.err.println("Error: Solo puede usar el print con enteros, flotantes, cadenas y caracteres.");
            } else {
                if (temp != null) {
                    if (parser.variableOffset.containsKey(temp)) {
                        temp = parser.loadVariable(temp);  // Cargar variable desde la pila
                    }

                    if (tipo.equals("cometa")) {
                        parser.gen("la $a0, " + temp);
                        parser.gen("li $v0, 4");
                    } else if (tipo.equals("bromista")) {
                        parser.gen("mtc1 " + temp + ", $f12");
                        parser.gen("li $v0, 2");
                    } else {
                        parser.gen("move $a0, " + temp);

                        switch (tipo) {
                            case "rodolfo":
                                parser.gen("li $v0, 1");
                                break;
                            case "cupido":
                                parser.gen("li $v0, 11");
                                break;
                        }
                    }
                    parser.gen("syscall");
                }
            }

            RESULT = new Resultado(tipo, temp);
        :};

read ::= READ PARENTESISAPERTURA IDENTIFICADOR:id PARENTESISCIERRE
        {:
            Symbol symbol = (Symbol) CUP$parser$stack.elementAt(CUP$parser$stack.size() - 2);
            int line = symbol.left;
            int column = symbol.right;

            String tipo = parser.getTipo(parser.listaTablasSimbolos.get(parser.currentHash), id.toString(), line, column);

            if ((!tipo.equals("rodolfo") && !tipo.equals("bromista"))) {
                System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                                   ": El read solo lee enteros o flotantes.");
            } else {
                String tempReg = parser.newTemp();

                switch (tipo) {
                    case "rodolfo":
                        parser.gen("li $v0, 5");
                        parser.gen("syscall");
                        parser.gen("move " + tempReg + ", $v0");
                        break;
                    case "bromista":
                        parser.gen("li $v0, 6");
                        parser.gen("syscall");
                        parser.gen("mfc1 " + tempReg + ", $f0");
                        break;
                }

                // Guardar el valor leído en la pila
                parser.storeVariable(id.toString(), tempReg);
                RESULT = new Resultado(tipo, id.toString());
            }
        :};

declaracion ::= tipo:t IDENTIFICADOR:id
            {:
                Symbol symbol = (Symbol) CUP$parser$stack.peek();
                parser.agregarVariable(symbol.left, symbol.right, id.toString(), ((Resultado) t).tipo);

                String tipoVar = ((Resultado) t).tipo;

                if (tipoVar.equals("cometa")) {
                    parser.declararString(id.toString(), " ");
                } else {
                    // Solo asignamos espacio si la variable no ha sido declarada antes
                    if (!parser.variableOffset.containsKey(id.toString())) {
                        parser.allocateVariable(id.toString());
                    }

                    // Usar un temporal para inicializar el valor en la pila
                    String temp = parser.newTemp();
                    parser.gen("li " + temp + ", 0");  // Inicializar en 0
                    parser.storeVariable(id.toString(), temp);  // Guardar en la pila
                }
            :}
          | tipo:t IDENTIFICADOR:id ASIGNA expresion:e
            {:
                Symbol symbol = (Symbol) CUP$parser$stack.peek();
                parser.agregarVariable(symbol.left, symbol.right, id.toString(), ((Resultado) t).tipo);

                String tipoVar = ((Resultado) t).tipo;
                String tipoExpresion = ((Resultado) e).tipo;
                String tempExpresion = ((Resultado) e).temp;

                if (tipoVar.equals("cometa")) {
                    // Usar el identificador del string directamente
                    String idString = ((Resultado) e).temp;

                    // Declarar el string (si aún no existe) en .data
                    parser.declararString(id.toString(), parser.obtenerValorString(idString));

                    // Referenciarlo en .text
                    parser.gen("la $a0, " + id.toString()); // Cargar la dirección del string
                    parser.gen("li $v0, 4"); // Syscall para imprimir cadenas
                    parser.gen("syscall");
                }else if (tipoVar.equals("bromista")) {
                    String regFloat = parser.newFloatTemp();  // Obtener un registro flotante
                    parser.gen("mov.s " + regFloat + ", " + tempExpresion); // Mover el valor a registro flotante
                    parser.storeVariable(id.toString(), regFloat);  // Guardar en la pila
                }
                else {
                    // Si la variable no ha sido asignada, reservar espacio en la pila
                    if (!parser.variableOffset.containsKey(id.toString())) {
                        parser.allocateVariable(id.toString());
                    }
                    parser.storeVariable(id.toString(), tempExpresion);
                }
                // Validación semántica de tipos
                int line = symbol.left;
                int column = symbol.right;

                if (!((Resultado) t).tipo.equals(((Resultado) e).tipo)) {
                    System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                                       ": Tipo incompatible en asignación. Variable '" + id +
                                       "' es de tipo " + ((Resultado) t).tipo + ", pero se le asignó un valor de tipo " + ((Resultado) e).tipo + ".");
                } else {
                    System.out.println("Asignación válida: '" + id + "' de tipo '" + ((Resultado) t).tipo +
                                       "' con valor de tipo '" + ((Resultado) e).tipo + "'.");
                }
           :}
        | arreglo
        | tipo error;

tipo ::= INTEGER{: RESULT = new Resultado("rodolfo", null); :}
    | STRING{: RESULT = new Resultado("cometa", null); :}
    | CHAR{: RESULT = new Resultado("cupido", null); :}
    | FLOAT{: RESULT = new Resultado("bromista", null); :}
    | BOOL{: RESULT = new Resultado("trueno", null); :};

asignacion ::= IDENTIFICADOR:id ASIGNA expresion:exp
            {:
                Symbol symbol = (Symbol) CUP$parser$stack.elementAt(CUP$parser$stack.size() - 3);
                String tipoIdentificador = parser.getTipo(
                    parser.listaTablasSimbolos.get(parser.currentHash), id.toString(), symbol.left, symbol.right);

                if (tipoIdentificador != null) {
                    // Verificar si la variable está en la pila antes de almacenarla
                    if (parser.variableOffset.containsKey(id.toString())) {
                        parser.storeVariable(id.toString(), ((Resultado) exp).temp);
                    } else {
                        System.err.println("Error: Variable '" + id + "' no tiene espacio reservado en la pila.");
                    }
                }
            :}
             | IDENTIFICADOR ASIGNA error
             | error;

expresion ::= literal:e {: RESULT = e; :}
            | IDENTIFICADOR:e
            {:
                Symbol symbol = (Symbol) CUP$parser$stack.peek();
                String tipo = parser.getTipo(parser.listaTablasSimbolos.get(parser.currentHash),
                                               e.toString(), symbol.left, symbol.right);

                if (tipo != null) {
                    if (parser.variableOffset.containsKey(e.toString())) {
                        // Cargar valor de la pila a un temporal antes de usarlo
                        String temp = parser.loadVariable(e.toString());
                        RESULT = new Resultado(tipo, temp);
                    } else {
                        System.err.println("Error: Variable '" + e + "' no tiene espacio en la pila.");
                        RESULT = new Resultado("error", null);
                    }
                } else {
                    System.err.println("Error: Variable '" + e + "' no ha sido declarada.");
                    RESULT = new Resultado("error", null);
                }
            :}
         | llamada_funcion:f {: RESULT = f; :}
         | expresion:e1 operador_unario:op
             {:
                 // Obtener el símbolo correspondiente a `e1` para extraer línea y columna
                 Symbol symbol = (Symbol) CUP$parser$stack.elementAt(CUP$parser$stack.size() - 2);
                 int line = symbol.left;
                 int column = symbol.right;

                 // Obtener el tipo y el temporal de la expresión
                 Resultado resultadoE1 = (Resultado) e1;
                 String tipo = resultadoE1.tipo;
                 String tempE1 = resultadoE1.temp;

                 // Validar tipos para operadores unarios
                 if (op.toString().equals("quien") || op.toString().equals("grinch")) {
                     if (!tipo.equals("rodolfo")) {
                         System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                                            ": Incremento/Decremento solo aplica a enteros (rodolfo).");
                     }
                 } else if (op.toString().equals("-") && !tipo.equals("rodolfo") && !tipo.equals("bromista")) {
                     System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                                        ": Negación solo aplica a enteros o flotantes.");
                 }

                 // Generar el temporal para la operación unaria
                 String tempResultado = parser.newTemp();

                 // Generación de código MIPS para los operadores unarios
                 if (op.toString().equals("-")) { // Negación
                     parser.gen("neg " + tempResultado + ", " + tempE1); // Negar el valor del temporal
                 } else if (op.toString().equals("quien")) { // Incremento
                     parser.gen("addi " + tempResultado + ", " + tempE1 + ", 1"); // Incrementar en 1
                 } else if (op.toString().equals("grinch")) { // Decremento
                     parser.gen("subi " + tempResultado + ", " + tempE1 + ", 1"); // Decrementar en 1
                 }
                 RESULT = new Resultado(tipo, tempResultado);
             :}
          | expresion:e1 operador_binario:op expresion:e2
          {:
               // Obtener los símbolos correspondientes a `e1` y `e2` para extraer línea y columna
               Symbol symbol1 = (Symbol) CUP$parser$stack.elementAt(CUP$parser$stack.size() - 3);
               Symbol symbol2 = (Symbol) CUP$parser$stack.elementAt(CUP$parser$stack.size() - 1);

               int line1 = symbol1.left;
               int column1 = symbol1.right;
               int line2 = symbol2.left;
               int column2 = symbol2.right;

              // Acceder a los tipos de los operandos desde los objetos Resultado
              String tipo1 = ((Resultado) e1).tipo;
              String tipo2 = ((Resultado) e2).tipo;

              // Debug: Verificar los tipos antes de la evaluación
              // System.out.println("DEBUG - e1: " + tipo1  + ", tipo2: " + tipo2);

              // Validar los tipos de los operandos
              if ((!tipo1.equals("rodolfo") && !tipo1.equals("bromista")) ||
                         (!tipo2.equals("rodolfo") && !tipo2.equals("bromista"))) {
                          System.err.println("Error semántico en línea " + (line1 + 1) + ", columna " + (column1 + 1) +
                                                  ": Operandos deben ser enteros (rodolfo) o flotantes (bromista).");
              } else if (!tipo1.equals(tipo2)) {
                        System.err.println("Error semántico en línea " + (line1 + 1) + ", columna " + (column1 + 1) +
                                                  ": Tipos incompatibles entre los operandos. Operando 1: " + tipo1 + ", Operando 2: " + tipo2);
              }else {
                      boolean esFlotante = tipo1.equals("bromista"); // Determinar si es flotante
                      String tipoResultado = esFlotante ? "bromista" : "rodolfo";

                      String temp1 = ((Resultado) e1).temp;
                      String temp2 = ((Resultado) e2).temp;
                      String tempResultado;

                      if (esFlotante) {
                          String tempResultadoF = parser.newFloatTemp();  // Usar solo registros $fX
                          switch (((Resultado) op).tipo) {
                                 case "navidad": parser.gen("add.s " + tempResultadoF + ", " + tempResultadoF + ", $f4"); break;
                                 case "intercambio": parser.gen("sub.s " + tempResultadoF + ", " + tempResultadoF + ", $f4"); break;
                                 case "nochebuena": parser.gen("mul.s " + tempResultadoF + ", " + tempResultadoF + ", $f4"); break;
                                 case "reyes": parser.gen("div.s " + tempResultadoF + ", " + tempResultadoF + ", $f4"); break;
                                 default: System.err.println("Error: Operación flotante no soportada.");
                          }
                            tempResultado = tempResultadoF;
                       } else {
                            tempResultado = parser.newTemp();  // Usar registros $tX
                            switch (((Resultado) op).tipo) {
                                 case "navidad":  parser.gen("add " + tempResultado + ", " + temp1 + ", " + temp2); break;
                                 case "intercambio": parser.gen("sub " + tempResultado + ", " + temp1 + ", " + temp2); break;
                                 case "nochebuena": parser.gen("mul " + tempResultado + ", " + temp1 + ", " + temp2); break;
                                 case "reyes":
                                       parser.gen("div " + temp1 + ", " + temp2);
                                       parser.gen("mflo " + tempResultado);
                                 break;
                                        case "magos":
                                            parser.gen("div " + temp1 + ", " + temp2);
                                            parser.gen("mfhi " + tempResultado);
                                            break;
                                 default:
                                 System.err.println("Error: Operación entera no soportada.");
                        }
                      }
                          RESULT = new Resultado(tipoResultado, tempResultado);
                 }
                 String tipoResultado = tipo1.equals("bromista") ? "bromista" : "rodolfo";

                  // Generar un temporal para la operación
                 String temp1 = ((Resultado) e1).temp;
                 String temp2 = ((Resultado) e2).temp;
                 String tempResult = parser.newTemp();

              // Asignar el resultado con el tipo y el temporal generado
                RESULT = new Resultado(tipoResultado, tempResult);
         :}
         | expresion:e1 operador_relacional:op expresion:e2
             {:
                // Obtener los símbolos correspondientes a `e1` y `e2` para extraer línea y columna
                Symbol symbol1 = (Symbol) CUP$parser$stack.elementAt(CUP$parser$stack.size() - 3);
                Symbol symbol2 = (Symbol) CUP$parser$stack.elementAt(CUP$parser$stack.size() - 1);
                int line1 = symbol1.left;
                int column1 = symbol1.right;
                int line2 = symbol2.left;
                int column2 = symbol2.right;
                String operador = ((Resultado) op).tipo;
                // Obtener los tipos desde los objetos Resultado
                if (e1 == null) {
                    e1 = new Resultado("null", null);
                }
                if (e2 == null) {
                    e2 = new Resultado("null", null);
                }
                String tipo1 = ((Resultado) e1).tipo;
                String tipo2 = ((Resultado) e2).tipo;

                // Validar los tipos de los operandos
                if (op.toString().equals("mary") || op.toString().equals("openslae")) {
                    // Para `mary` y `openslae`, los tipos pueden ser enteros, flotantes o booleanos
                    if ((!tipo1.equals("rodolfo") && !tipo1.equals("bromista") && !tipo1.equals("trueno")) ||
                        (!tipo2.equals("rodolfo") && !tipo2.equals("bromista") && !tipo2.equals("trueno"))) {
                        System.err.println("Error semántico en línea " + (line1 + 1) + ", columna " + (column1 + 1) +
                                           ": Operadores '" + operador + "' solo admiten enteros (rodolfo), flotantes (bromista) o booleanos (trueno).");
                    } else if (!tipo1.equals(tipo2)) {
                        System.err.println("Error semántico en línea " + (line1 + 1) + ", columna " + (column1 + 1) +
                                           ": Tipos incompatibles para operador '" + operador + "'. Operando 1: " + tipo1 + ", Operando 2: " + tipo2);
                    } else {
                    // Asignar el tipo resultante para comparaciones relacionales
                    String temp1 = ((Resultado) e1).temp;
                    String temp2 = ((Resultado) e2).temp;
                    String tempResultado = parser.newTemp();

                    // Generación de código MIPS para la comparación
                    switch (operador) {
                        case "mary": // Igualdad
                            parser.gen("seq " + tempResultado + ", " + temp1 + ", " + temp2);
                            break;
                        case "openslae": // Diferente
                            parser.gen("sne " + tempResultado + ", " + temp1 + ", " + temp2);
                        default:
                            System.err.println("Error: Operador relacional no soportado.");
                    }
                    // Asignar el resultado con el tipo booleano (trueno) y el temporal generado
                    RESULT = new Resultado("trueno", tempResultado);
                    }
                } else {
                    // Validación para otros operadores relacionales
                    if ((!tipo1.equals("rodolfo") && !tipo1.equals("bromista")) ||
                        (!tipo2.equals("rodolfo") && !tipo2.equals("bromista"))) {
                        System.err.println("Error semántico en línea " + (line1 + 1) + ", columna " + (column1 + 1) +
                                           ": Operadores '" + operador + "' solo admiten enteros (rodolfo) o flotantes (bromista).");
                    } else if (!tipo1.equals(tipo2)) {
                        System.err.println("Error semántico en línea " + (line1 + 1) + ", columna " + (column1 + 1) +
                                           ": Tipos incompatibles entre los operandos. Operando 1: " + tipo1 + ", Operando 2: " + tipo2);
                    } else {
                        // Asignar el tipo resultante para comparaciones relacionales
                    String temp1 = ((Resultado) e1).temp;
                    String temp2 = ((Resultado) e2).temp;
                    String tempResultado = parser.newTemp();

                    // Generación de código MIPS para la comparación
                    switch (operador) {
                        case "snowball": // Menor que
                            parser.gen("slt " + tempResultado + ", " + temp1 + ", " + temp2);
                            break;
                        case "evergreen": // Menor o igual
                            parser.gen("sle " + tempResultado + ", " + temp1 + ", " + temp2);
                            break;
                        case "minstix": // Mayor que
                            parser.gen("sgt " + tempResultado + ", " + temp1 + ", " + temp2);
                            break;
                        case "upatree": // Mayor o igual
                            parser.gen("sge " + tempResultado + ", " + temp1 + ", " + temp2);
                            break;
                        default:
                            System.err.println("Error: Operador relacional no soportado.");
                    }

                    // Asignar el resultado con el tipo booleano (trueno) y el temporal generado
                    RESULT = new Resultado("trueno", tempResultado);
                    }
                }
             :}
         | expresion:e1 operador_logico:op expresion:e2
                      {:
                       // Obtener los símbolos correspondientes a `e1` y `e2` para extraer línea y columna
                       Symbol symbol1 = (Symbol) CUP$parser$stack.elementAt(CUP$parser$stack.size() - 3);
                       Symbol symbol2 = (Symbol) CUP$parser$stack.elementAt(CUP$parser$stack.size() - 1);
                       int line1 = symbol1.left;
                       int column1 = symbol1.right;
                       int line2 = symbol2.left;
                       int column2 = symbol2.right;

                       // Validar que `e1` y `e2` no sean nulos
                       if (e1 == null) {
                           e1 = new Resultado("null", null);
                       }
                       if (e2 == null) {
                           e2 = new Resultado("null", null);
                       }

                       // Obtener los tipos desde los objetos Resultado
                       String tipo1 = ((Resultado) e1).tipo;
                       String tipo2 = ((Resultado) e2).tipo;

                       // Verificar que ambos operandos sean booleanos
                       if (!tipo1.equals("trueno") || !tipo2.equals("trueno")) {
                           System.err.println("Error semántico en línea " + (line1 + 1) + ", columna " + (column1 + 1) +
                                              ": Operadores lógicos requieren valores booleanos (trueno).");
                       } else {
                           // Generar código MIPS para operadores lógicos
                           String temp1 = ((Resultado) e1).temp;
                           String temp2 = ((Resultado) e2).temp;
                           String tempResultado = parser.newTemp();

                           switch (((Resultado) op).tipo) {
                               case "melchor": // AND lógico
                                   parser.gen("and " + tempResultado + ", " + temp1 + ", " + temp2);
                                   break;
                               case "gaspar": // OR lógico
                                   parser.gen("or " + tempResultado + ", " + temp1 + ", " + temp2);
                                   break;
                               default:
                                   System.err.println("Error: Operador lógico no soportado.");
                           }

                           // Asignar el resultado con el tipo booleano (trueno) y el temporal generado
                           RESULT = new Resultado("trueno", tempResultado);
                       }
         :}
         | NEGACION expresion:e {:
               Symbol symbol = (Symbol) CUP$parser$stack.peek();
               int line = symbol.left;
               int column = symbol.right;

                String temp = parser.newTemp();
                         String tempExpr = ((Resultado) e).temp;
                         String tempResultado = parser.newTemp();

                         parser.gen("not " + temp + ", " + tempExpr);
                         RESULT = new Resultado("trueno", temp);
         :}
         | PARENTESISAPERTURA expresion:e PARENTESISCIERRE {: RESULT = e; :}
         | PARENTESISAPERTURA error PARENTESISCIERRE;

literal ::= L_INTEGER:i
    {:
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        String temp = parser.newTemp();
        parser.agregarVariable(symbol.left, symbol.right, symbol.value.toString(), "rodolfo");
        parser.gen("li " + temp + ", " + symbol.value);
        RESULT = new Resultado("rodolfo", temp);
    :}
    | L_FLOAT:f
    {:
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        String tempFloat = parser.newTemp();
        parser.agregarVariable(symbol.left, symbol.right, symbol.value.toString(), "rodolfo");
        String ieee754Hex = parser.floatToIEEE754(symbol.value.toString());

        parser.gen("li $t0, " + ieee754Hex);   // Cargar IEEE 754 en $t0
        //parser.gen("mtc1 $t0, " + tempFloat);  // Mover a registro flotante
        // parser.gen("cvt.s.w " + tempFloat + ", " + tempFloat);

        RESULT = new Resultado("bromista", tempFloat);
   :}
    | L_STRING:s
          {:
              Symbol symbol = (Symbol) CUP$parser$stack.peek();
              String id = "_string_" + parser.currentTemp++;  // Generar un identificador único válido

              // Declarar el string en la sección .data con el valor correcto
              parser.declararString(id, symbol.value.toString());

              // Devolver un resultado con el tipo y el identificador del string
              RESULT = new Resultado("cometa", id);
          :}
    | L_CHAR:c
    {:
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        String temp = parser.newTemp();
        parser.agregarVariable(symbol.left, symbol.right, symbol.value.toString(), "cupido");
        parser.gen("li " + temp + ", '" + symbol.value + "'");
        RESULT = new Resultado("cupido", temp);
    :}
    | TRUE:t
    {:
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        String temp = parser.newTemp();
        parser.agregarVariable(symbol.left, symbol.right, symbol.value.toString(), "trueno");
        parser.gen("li " + temp + ", 1");
        RESULT = new Resultado("trueno", temp);
    :}
    | FALSE:f
    {:
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        String temp = parser.newTemp();
        parser.agregarVariable(symbol.left, symbol.right, symbol.value.toString(), "trueno");
        parser.gen("li " + temp + ", 0");
        RESULT = new Resultado("trueno", temp);
    :};

operador_binario ::= SUMA {:RESULT = new Resultado("navidad", null);:}
                 | RESTA {:RESULT = new Resultado("intercambio", null);:}
                 | DIVISION {:RESULT = new Resultado("reyes", null);:}
                 | MULTIPLICACION {:RESULT = new Resultado("nochebuena", null);:}
                 | MODULO {:RESULT = new Resultado("magos", null);:}
                 | POTENCIA {:RESULT = new Resultado("adviento", null);:};

operador_unario ::= INCREMENTO {:RESULT = new Resultado("quien", null);:}
                  | DECREMENTO {:RESULT = new Resultado("grinch", null);:}
                  | NEGATIVO {:RESULT = new Resultado("-", null);:};

operador_logico ::=  CONJUNCION {:RESULT = new Resultado("melchor", null);:}
                  | DISYUNCION {:RESULT = new Resultado("gaspar", null);:}
                  | NEGACION {:RESULT = new Resultado("baltazar", null);:};

operador_relacional ::= MENOR {:RESULT = new Resultado("snowball", null);:}
                       | MENOR_IGUAL {:RESULT = new Resultado("evergreen", null);:}
                       | MAYOR {:RESULT = new Resultado("minstix", null);:}
                       | MAYOR_IGUAL {:RESULT = new Resultado("upatree", null);:}
                       | IGUAL {:RESULT = new Resultado("mary", null);:}
                       | DIFERENTE {:RESULT = new Resultado("openslae", null);:};

estructura_control ::= if_stmt
                    | while_stmt
                    | for_stmt
                    | switch_stmt;

if_stmt ::= if_stmt_cabecera if_stmt_aux;

if_stmt_cabecera ::= IF PARENTESISAPERTURA expresion:e PARENTESISCIERRE
            {:
            if (e == null) {
                Symbol symbol = (Symbol) CUP$parser$stack.elementAt(CUP$parser$stack.size() - 2);
                int line = symbol.left;
                int column = symbol.right;

                System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                                   ": Se ha intentado utilizar una expresión con valor nulo en el if.");
                errorCount++;
            } else {

                  parser.etiquetaTrue = "_etiqueta_true_" + parser.currentTemp++;
                  parser.etiquetaEndIf = "_etiqueta_end_if" + parser.currentTemp++;
                  parser.etiquetaEndElse = "_etiqueta_end_else" + parser.currentTemp++;

                  parser.gen("bne " + ((Resultado) e).temp + ", $zero, " + etiquetaTrue);
                  parser.gen("j " + etiquetaEndIf);

                  parser.gen(etiquetaTrue + ":");
            }
            :}
          | IF PARENTESISAPERTURA error PARENTESISCIERRE bloqueEstructura
          | IF PARENTESISAPERTURA expresion PARENTESISCIERRE error ELSE bloqueEstructura
          | IF PARENTESISAPERTURA error PARENTESISCIERRE bloqueEstructura ELSE bloqueEstructura;

if_stmt_aux ::= bloqueEstructura
                {:
                    parser.gen(parser.etiquetaEndIf + ":");
                :}
                | bloqueEstructura
                {:
                    parser.gen("j " + etiquetaEndElse);
                    parser.gen(parser.etiquetaEndIf + ":");
                :}
                 ELSE if_else_stmt;

if_else_stmt ::= bloqueEstructura
                 {:
                   parser.gen(parser.etiquetaEndElse + ":");
                 :};

while_stmt ::= WHILE PARENTESISAPERTURA
               {:
                   parser.etiquetaInicioWhile = "_while_start_" + parser.currentTemp++;
                   parser.etiquetaEndWhile = "_while_end_" + parser.currentTemp++;

                   // Generar la etiqueta de inicio del bucle
                   parser.gen(parser.etiquetaInicioWhile + ":");
               :}
               expresion:e
               {:
                    if (e == null) {
                        Symbol symbol = (Symbol) CUP$parser$stack.elementAt(CUP$parser$stack.size() - 1);
                        int line = symbol.left;
                        int column = symbol.right;

                        System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                                           ": Se ha intentado utilizar una expresión con valor nulo.");
                        errorCount++;
                    }
                    else {
                   // Generar la condición del bucle
                   parser.gen("beq " + ((Resultado) e).temp + ", $zero, " + parser.etiquetaEndWhile);
                   }
               :}
               PARENTESISCIERRE bloqueEstructura
               {:
                   // Generar el código del cuerpo del bucle
                   parser.gen("j " + parser.etiquetaInicioWhile); // Volver al inicio
                   parser.gen(parser.etiquetaEndWhile + ":");    // Etiqueta de salida
               :}
             | WHILE PARENTESISAPERTURA error PARENTESISCIERRE bloqueEstructura;


for_stmt ::= FOR PARENTESISAPERTURA declaracion FIN_EXPRESION expresion FIN_EXPRESION expresion PARENTESISCIERRE bloqueEstructura
           | FOR PARENTESISAPERTURA asignacion FIN_EXPRESION expresion FIN_EXPRESION expresion PARENTESISCIERRE bloqueEstructura
           | FOR PARENTESISAPERTURA error PARENTESISCIERRE bloqueEstructura;

switch_stmt ::= SWITCH PARENTESISAPERTURA expresion PARENTESISCIERRE corcheteIzquierdo case_list default_stmt corcheteDerecho
              | SWITCH PARENTESISAPERTURA expresion PARENTESISCIERRE corcheteIzquierdo case_list corcheteDerecho
              | SWITCH PARENTESISAPERTURA error PARENTESISCIERRE corcheteIzquierdo case_list corcheteDerecho
              ;

case_list ::= case_list case_stmt
            | case_stmt
            | case_list error case_stmt;

case_stmt ::= CASE expresion DOS_PUNTOS lista_sentencias
            | CASE error DOS_PUNTOS lista_sentencias
            ;

default_stmt ::= DEFAULT DOS_PUNTOS lista_sentencias
               | DEFAULT error lista_sentencias;


declaracionArreglo ::= tipo:t IDENTIFICADOR:id acceso_arreglo:a
                      {:
                         Symbol symbol = (Symbol) CUP$parser$stack.peek();
                         parser.agregarVariable(symbol.left, symbol.right, id.toString(), ((Resultado) t).tipo);

                         // Validación del tipo permitido
                         if (!((Resultado) t).tipo.equals("rodolfo") && !((Resultado) t).tipo.equals("cupido")) {
                             System.err.println("Error semántico en línea " + (symbol.left + 1) + ", columna " + (symbol.right + 1) +
                                                 ": Solo se permiten variables de tipo 'rodolfo' (int) o 'cupido' (char).");
                         } else {
                             System.out.println("Declaración válida: arreglo '" + id + "' de tipo '" + ((Resultado) t).tipo + "'.");
                         }
                         String tempIndice = ((Resultado) a).temp;
                         String tempSize = parser.newTemp();
                         String tempBase = parser.newTemp();
                         String tempRegistro = parser.newTemp();

                         parser.gen("mul " + tempSize + ", " + tempIndice + ", 4");
                         parser.gen("li $v0, 9");
                         parser.gen("move $a0, " + tempSize);
                         parser.gen("syscall");

                         parser.gen("move " + tempBase + ", $v0");
                         parser.gen("li " + tempRegistro + ", 3");
                         parser.gen("sw " + tempRegistro + ", 0(" + tempBase + ")");
                      :}
                  | IDENTIFICADOR:id acceso_arreglo:a
                  | tipo:t IDENTIFICADOR:id acceso_arreglo ASIGNA expresion:e
                  {:
                    Symbol symbol = (Symbol) CUP$parser$stack.peek();
                    parser.agregarVariable(symbol.left, symbol.right, id.toString(), ((Resultado) t).tipo);

                    String tipoExpresion = (e instanceof Resultado)
                        ? ((Resultado) e).tipo
                        : parser.getTipo(parser.listaTablasSimbolos.get(parser.currentHash), e.toString(), symbol.left, symbol.right);

                    // Validación de compatibilidad de tipos
                    if (!((Resultado) t).tipo.equals(tipoExpresion)) {
                        System.err.println("Error semántico en línea " + (symbol.left + 1) + ", columna " + (symbol.right + 1) +
                                           ": Incompatibilidad de tipos. La variable '" + id + "' es de tipo '" + ((Resultado) t).tipo +
                                           "', pero se le asignó una expresión de tipo '" + tipoExpresion + "'.");
                    } else if (!((Resultado) t).tipo.equals("rodolfo") && !((Resultado) t).tipo.equals("cupido")) {
                         System.err.println("Error semántico en línea " + (symbol.left + 1) + ", columna " + (symbol.right + 1) +
                                             ": Solo se permiten asignaciones a variables de tipo 'rodolfo' (int) o 'cupido' (char).");
                    } else {
                        // Generación de código MIPS para asignación
                        String temp = ((Resultado) e).temp;
                        parser.gen("la $t0, " + id);
                        parser.gen("sw " + temp + ", 0($t0)");
                        System.out.println("Asignación a arreglo válida: '" + id + "'.");
                    }
                  :}
                  | tipo:t IDENTIFICADOR:id acceso_arreglo:a ASIGNA corcheteIzquierdo parametrosArreglos corcheteDerecho
                    {:
                        Symbol symbol = (Symbol) CUP$parser$stack.peek();
                        parser.agregarVariable(symbol.left, symbol.right, id.toString(), ((Resultado) t).tipo);
                        System.out.println("Declaración y asignación de arreglo inicializado: '" + id + "'.");

                         String tempIndice = ((Resultado) a).temp;
                         String tempSize = parser.newTemp();
                         String tempBase = parser.newTemp();
                         String tempRegistro = parser.newTemp();

                         parser.gen("li " + tempSize + ", " + tempIndice + ", 4");
                         parser.gen("li $v0, 9");
                         parser.gen("move $a0, " + tempSize);
                         parser.gen("syscall");
                         parser.gen("move " + tempBase + ", $v0");
                         parser.gen("li " + tempRegistro + ", 3");
                         parser.gen("sw " + tempRegistro + ", 0(" + tempBase + ")");
                    :}
                  | IDENTIFICADOR:id acceso_arreglo ASIGNA expresion:e
                    {:
                        Symbol symbol = (Symbol) CUP$parser$stack.peek();
                        String tipoExpresion = (e instanceof Resultado)
                            ? ((Resultado) e).tipo
                            : parser.getTipo(parser.listaTablasSimbolos.get(parser.currentHash), e.toString(), symbol.left, symbol.right);
                        if (tipoExpresion != null) {
                            String temp = ((Resultado) e).temp;
                            parser.gen("la $t0, " + id);
                            parser.gen("sw " + temp + ", 0($t0)");
                            System.out.println("Asignación directa a arreglo válida: '" + id + "'.");
                        } else {
                            System.err.println("Error semántico en línea " + (symbol.left + 1) + ", columna " + (symbol.right + 1) +
                                               ": El valor asignado al arreglo no tiene un tipo válido.");
                        }
                    :};

parametrosArreglos::= parametrosArreglosAux;

parametrosArreglosAux ::= parametrosArreglosAux COMA
                          {:
                              // Generar un resultado con el separador de coma para unir parámetros
                              RESULT = new Resultado(",", null);
                          :}
                          expresion:e
                          {:
                              // Validar y asignar el resultado de la expresión
                              if (e instanceof Resultado) {
                                  Resultado resExp = (Resultado) e;
                                  if (resExp.tipo == null) {
                                      System.err.println("Error semantico: La expresión del parámetro no tiene un tipo válido.");
                                  }
                                  RESULT = resExp;
                              } else {
                                  System.err.println("Error semantico: El resultado de la expresión no es válido.");
                              }
                          :}
                      | expresion:e
                          {:
                              // Validar y asignar el resultado de la expresión directamente
                              if (e instanceof Resultado) {
                                  Resultado resExp = (Resultado) e;
                                  if (resExp.tipo == null) {
                                      System.err.println("Error semantico: La expresión del parámetro no tiene un tipo válido.");
                                  }
                                  RESULT = resExp;
                              } else {
                                  System.err.println("Error semantico: El resultado de la expresión no es válido.");
                              }
                          :};

arreglo ::= declaracionArreglo
            {:
                RESULT = null;
            :}
          | arreglo declaracionArreglo
            {:
                RESULT = null;
            :};

acceso_arreglo ::= CORCHETEAPERTURA
                    {:
                        RESULT = new Resultado("abreempaque", null);
                    :}
                    expresion:e
                    {:
                        if (e instanceof Resultado) {
                            Resultado resExp = (Resultado) e;
                            if (!"rodolfo".equals(resExp.tipo)) {
                                System.err.println("Error semántico: El índice del arreglo debe ser un entero (rodolfo), pero se encontró '" + resExp.tipo + "'.");
                            }
                            RESULT = resExp;
                        } else {
                            System.err.println("Error semántico: Expresión inválida en el índice del arreglo.");
                            RESULT = new Resultado("null", null);
                        }
                    :}
                    CORCHETECIERRE
                    {:
                        RESULT = new Resultado("cierraempaque", null);
                    :}
                 | CORCHETEAPERTURA error CORCHETECIERRE
                    {:
                        // Manejo de error en el índice del arreglo
                        System.err.println("Error sintáctico: Índice del arreglo inválido.");
                        RESULT = new Resultado("null", null); // Manejo seguro para errores
                    :};

parametros ::= lista_parametros
            ;

lista_parametros ::= lista_parametros COMA tipo:t IDENTIFICADOR:id
                    {:
                        Symbol symbol = (Symbol) CUP$parser$stack.peek();
                        parser.agregarVariable(symbol.left, symbol.right, id.toString(), ((Resultado) t).tipo);
                    :}
                    | tipo:t IDENTIFICADOR:id
                    {:
                        Symbol symbol = (Symbol) CUP$parser$stack.peek();
                        parser.agregarVariable(symbol.left, symbol.right, id.toString(), ((Resultado) t).tipo);
                    :}
                    | lista_parametros error tipo IDENTIFICADOR;

llamada_funcion ::= IDENTIFICADOR:id llamada_funcion_aux
    {:
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        int line = symbol.left;
        int column = symbol.right;

        // Construir una tabla global combinada
        ArrayList<String> tablaGlobal = new ArrayList<>();
        parser.listaTablasSimbolos.values().forEach(tabla -> {
            if (tabla != null) tablaGlobal.addAll(tabla);
        });

        // Obtener el tipo de la función
        String tipoFuncion = parser.getTipo(tablaGlobal, id.toString(), line, column);

        if (tipoFuncion.equals("null")) {
            // Si no se encuentra la función, asignar un RESULT con tipo "null"
            System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                               ": La función '" + id + "' no está declarada en ninguna tabla de símbolos.");
            RESULT = new Resultado("null", null);
        } else {
            // Generar un temporal para almacenar el resultado de la función (si no es void)
            String tempResultado = null;
            if (!tipoFuncion.equals("void")) {
                tempResultado = parser.newTemp();
                parser.gen("jal " + id);  // Llamada a la función
                parser.gen("move " + tempResultado + ", $v0");
            } else {
                parser.gen("jal " + id);
            }

            System.out.println("Invocación válida: " + id + " de tipo: " + tipoFuncion);
            RESULT = new Resultado(tipoFuncion, tempResultado);
        }
    :};


llamada_funcion_aux ::=  PARENTESISAPERTURA lista_expresiones PARENTESISCIERRE
                      |  PARENTESISAPERTURA PARENTESISCIERRE
                      |  PARENTESISAPERTURA error PARENTESISCIERRE;

lista_expresiones ::= lista_expresiones COMA
                    {:
                    :}
                    expresion:e
                    {:
                        RESULT = e;
                    :}
                   | expresion:e
                    {:
                        RESULT = e;
                    :}
                   | lista_expresiones error expresion:e
                    {:
                        RESULT = e;
                    :};

return_stmt ::= RETURN expresion:e
            {:
                Symbol symbol = (Symbol) CUP$parser$stack.peek();
                int line = symbol.left;
                int column = symbol.right;

                // Obtener el tipo de la función actual usando `currentHash`
                String tipoFuncion = parser.getTipo(parser.listaTablasSimbolos.get(parser.currentHash), parser.currentHash, line, column);

                if (e == null) {
                    // Manejo de RETURN sin expresión
                    if (!tipoFuncion.equals("void")) {
                        System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                                           ": La función requiere un valor de retorno de tipo '" + tipoFuncion + "', pero se encontró 'void'.");
                    } else {
                        System.out.println("Retorno válido: void en función de tipo void.");
                        parser.gen("jr $ra");  // Retornar a la dirección de retorno en MIPS
                        RESULT = new Resultado("void", null);
                    }
                } else {
                    // Manejo de RETURN con expresión
                    Resultado resultadoExpresion = (Resultado) e;
                    String tipoExpresion = resultadoExpresion.tipo;

                    // Comparar los tipos
                    if (!tipoFuncion.equals(tipoExpresion)) {
                        System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                                           ": Tipo de retorno (" + tipoExpresion + ") no coincide con el tipo de la función (" + tipoFuncion + ").");
                    } else {
                        System.out.println("Retorno válido: tipo '" + tipoExpresion + "'.");

                        // Generar código MIPS para mover el valor de retorno a $v0
                        if (resultadoExpresion.temp != null) {
                            parser.gen("move $v0, " + resultadoExpresion.temp);
                        } else {
                            System.err.println("Error: El temporal para el valor de retorno es null.");
                        }
                        parser.gen("jr $ra");  // Retornar a la dirección de retorno en MIPS
                    }

                    RESULT = new Resultado(tipoExpresion, resultadoExpresion.temp);
                }
            :}
              | RETURN
                {:
                    Symbol symbol = (Symbol) CUP$parser$stack.peek();
                    int line = symbol.left;
                    int column = symbol.right;

                    String tipoFuncion = parser.getTipo(parser.listaTablasSimbolos.get(parser.currentHash), parser.currentHash, line, column);

                    if (!tipoFuncion.equals("void")) {
                        System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                                           ": La función requiere un valor de retorno de tipo '" + tipoFuncion + "', pero se encontró 'void'.");
                    } else {
                        System.out.println("Retorno válido en función de tipo void.");
                        parser.gen("jr $ra");
                        RESULT = new Resultado("void", null);
                    }
                :}
              | RETURN error
                {:
                    System.err.println("Error: Retorno inválido.");
                    RESULT = new Resultado("null", null);
                :};

return_estructura_stmt ::= RETURN expresion
              | RETURN
              | RETURN error;