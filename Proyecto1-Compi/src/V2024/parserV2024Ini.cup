package ParserLexer;
import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.HashMap;
import Tree.Arbol;
import Tree.Nodo;

action code {:  :};

parser code {:
    BasicLexerCupV lex;

    private int errorCount = 0;

    private Arbol arbol;


    public String getTipo(ArrayList<String> listaTablasSimbolos, String id) {
                    String tipo = "null";
                    for (String token : listaTablasSimbolos) {
                        String[] partesToken = token.split(":");
                        if (id.equals(partesToken[0])) {
                            tipo = partesToken[1];
                            break;
                        }
                    }
                    if (tipo.equals("null")) {
                        System.err.println("Error semántico: Variable " + id + " no declarada.");
                    }
                    System.out.println("tipo: " + tipo);
                    return tipo;
                }

    /**
     * Método: getArbol
     * Objetivo: Obtener el arbol.
     * Entradas: Ninguna
     * Salida: El arbol actual.
     */
    public Arbol getArbol() {
        return arbol;
    }
    /**
     * Método: crearNodo
     * Objetivo: Crear un nuevo nodo para el árbol sintáctico con un dato específico.
     * Entradas:
     *   - dato: Cadena de texto que representa el valor asociado al nodo.
     * Salida: Una instancia de la clase Nodo con el dato proporcionado.
     */
    private Nodo crearNodo(String dato) {
        return new Nodo(dato);
    }

    /**
     * Método: syntax_error
     * Objetivo: Manejar los errores sintácticos encontrados durante el análisis sintáctico.
     * Entradas:
     *   - s: Objeto de tipo Symbol que contiene información sobre el error sintáctico, como la posición y el token involucrado.
     * Salida: Ninguna.
     * Restricciones: Se espera que el objeto Symbol contenga información válida de posición y token.
     */
    @Override
    public void syntax_error(Symbol s) {
        errorCount++;
        System.err.println("Error sintáctico en línea " + (s.left + 1) +
                           ", columna " + (s.right + 1) + ". Token inesperado: " + s.value);
    }

    /**
     * Método: hasErrors
     * Objetivo: Verificar si se han registrado errores durante el análisis sintáctico.
     * Entradas: Ninguna.
     * Salida: Booleano que indica si existen errores (true si hay errores, false sino).
     *         Se utiliza en la clase MainJFlexCup para indicar si el archivo puede generarse
     * Restricciones: La variable errorCount debe haber sido correctamente inicializada y actualizada.
     */
    public boolean hasErrors() {
        return errorCount > 0;
    }

    @SuppressWarnings("deprecation")
    public parser(BasicLexerCupV lex) {
        this.lex = lex;
        this.symbolFactory = new DefaultSymbolFactory();
        this.currentHash = null;
        this.arbol = new Arbol();
    }

    // Tabla de símbolos
    HashMap<String, ArrayList<String>> listaTablasSimbolos = new HashMap<>();
    String currentHash;

    /**
     * Método: imprimirTablaSimbolos
     * Objetivo: Imprimir todas las tablas de símbolos almacenadas, mostrando el contenido de cada tabla en un formato tabular.
     * Entradas: Ninguna.
     * Salida: Se llama en MainJFlexCup para imprimir en la consola el contenido de las tablas de símbolos.
     * Detalles:
     *   - Cada tabla está asociada a una clave (nombre de la función o el main).
     *   - Se imprime una tabla separada para cada clave con columnas que incluyen línea, columna, lexema y tipo.
     * Restricciones: Se espera que la estructura `listaTablasSimbolos` esté correctamente inicializada y contenga las claves y los valores correspondientes.
     */
    public void imprimirTablaSimbolos() {
        for (String key : listaTablasSimbolos.keySet()) {
            System.out.println("\nTabla de símbolos: " + key);
            System.out.println("+--------+---------+----------------------+------------+");
            System.out.println("| Línea  | Columna | Lexema              | Tipo       |");
            System.out.println("+--------+---------+----------------------+------------+");
            for (String simbolo : listaTablasSimbolos.get(key)) {
                System.out.println(simbolo);
            }
            System.out.println("+--------+---------+----------------------+------------+\n");
        }
    }

    /**
     * Método: agregarTablaSimbolos
     * Objetivo: Crear una nueva tabla de símbolos asociada a una función o al main y agregarla al mapa de tablas de símbolos.
     * Entradas:
     *   - tipoTabla: Tipo de la tabla ("función" o "main").
     *   - nombre: Nombre asociado a la tabla (El nombre de la función o "_verano_" que es el token asociado a main).
     * Salida: Ninguna.
     * Detalles:
     *   - Se inicializa una nueva tabla de símbolos como una lista de cadenas.
     *   - Se guarda en el mapa `listaTablasSimbolos` con el nombre como clave.
     *   - `currentHash` se actualiza para indicar que la tabla activa es la recién creada.
     * Restricciones:
     *   - El nombre de la tabla debe ser único para evitar sobrescribir tablas existentes.
     */
    public void agregarTablaSimbolos(String tipoTabla, String nombre) {
        System.out.println("/+++Nueva tabla símbolos función o main+++/ " + nombre);
        ArrayList<String> nuevaTabla = new ArrayList<>();
        currentHash = nombre;
        listaTablasSimbolos.put(currentHash, nuevaTabla);
    }

    /**
     * Método: agregarVariable
     * Objetivo: Agregar una nueva variable a la tabla de símbolos activa, registrando su línea, columna, lexema y tipo.
     * Entradas:
     *   - linea: Número de línea donde se encuentra la variable.
     *   - columna: Número de columna donde se encuentra la variable.
     *   - lexema: Nombre o representación textual de la variable.
     *   - tipo: Tipo de la variable
     * Salida: Ninguna.
     * Detalles:
     *   - Verifica que haya una tabla de símbolos activa (`currentHash`) y que esta exista en el mapa `listaTablasSimbolos`.
     *   - Si no hay tabla activa o no existe, se imprime un mensaje de error.
     *   - Si todo es válido, formatea la información de la variable en una tabla y la agrega a la tabla de símbolos activa.
     * Restricciones:
     *   - Debe existir una tabla de símbolos activa antes de llamar a este método.
     *   - La línea, columna, lexema y tipo deben ser datos válidos y coherentes con el análisis.
     */
    public void agregarVariable(int linea, int columna, String lexema, String tipo) {
        System.out.println("PARSER: identificador (agregar o verificar) " + lexema);
        if (currentHash == null) {
            System.err.println("Error: No hay una tabla de símbolos activa");
            return;
        }
        ArrayList<String> tabla = listaTablasSimbolos.get(currentHash);
        if (tabla == null) {
            System.err.println("Error: La tabla de símbolos '" + currentHash + "' no existe");
            return;
        }
        String entrada = String.format("| %-6d | %-7d | %-20s | %-10s |",
                linea + 1, columna + 1, lexema, tipo);
        tabla.add(entrada);
    }
:}

init with {: :};

scan with {: return lex.next_token(); :};

/* Terminales */
terminal corcheteIzquierdo, corcheteDerecho, CORCHETEAPERTURA, CORCHETECIERRE, ASIGNA, PARENTESISAPERTURA, PARENTESISCIERRE, FIN_EXPRESION,
        PRINT, READ, MAIN, COMA;
terminal INTEGER, STRING, CHAR, FLOAT, BOOL, IDENTIFICADOR, TRUE, FALSE;
terminal SUMA, RESTA, DIVISION, MULTIPLICACION, MODULO, POTENCIA, INCREMENTO, DECREMENTO, NEGATIVO;
terminal MENOR, MENOR_IGUAL, MAYOR, MAYOR_IGUAL, IGUAL, DIFERENTE;
terminal CONJUNCION, DISYUNCION, NEGACION;
terminal IF, ELSE, WHILE, FOR, SWITCH, CASE, DEFAULT, BREAK, RETURN, DOS_PUNTOS;
terminal Integer L_INTEGER;
terminal String L_STRING;
terminal Float L_FLOAT;
terminal Character L_CHAR;

/* No terminales */
non terminal inicio, tipos, expresionRelacional, operadorRelacional, literales, bool, operadorLogico, negacion, sentencias, sentencia, funciones, funcion, bloque, return_estructura,
parametroAux, parametros, crearArreglos, modificarArreglos, arreglos, arreglo,
parametrosArregloAux, parametrosArreglo, asignaVariable, variable, operandoBinaria, expresionBinaria,
operandoUnario, expresionUnario, expresionRelacionalMat, sentencia_lista, sentenciaEstructura, if_estructura,
for_estructura, switch_estructura, casos_switch, caso_switch, break_estructura, print, read, encabezadoFuncion,
while_estructura, return_funcion, tiposArr, expresionArr, default_case,numerosLiterales, expresionCompleja,numeroEntero,  numeroFloat,
creacion, creacionAsignacion, asignarTipo, expresiones, expresionLogica, invocacionFuncion,parametrosInvFuncion, parametrosInvFuncionAux;

/* Precedencia */
precedence left ELSE;
precedence left MENOR, MENOR_IGUAL, MAYOR, MAYOR_IGUAL;
precedence left IGUAL, DIFERENTE;
precedence left CONJUNCION, DISYUNCION;
precedence left SUMA, RESTA;
precedence left MULTIPLICACION, DIVISION, MODULO;
precedence right POTENCIA;
precedence left FIN_EXPRESION;
precedence left ASIGNA, MENOR, MAYOR, CONJUNCION, DISYUNCION;
precedence right NEGACION;
precedence left L_INTEGER, L_FLOAT;



/* Producción inicial */
start with inicio;


inicio ::= MAIN:m
    {:
        parser.agregarTablaSimbolos("main", "_verano_");
        Nodo mainNode = new Nodo("_verano_");
        parser.getArbol().setRaiz(mainNode);
        RESULT = mainNode;
    :}
    funciones
    | error {:
             System.err.println("Error en la estructura inicial.");
         :};

/* Definiciones */
tipos ::= INTEGER
    {:
        Nodo tipoNode = parser.crearNodo("INTEGER");
        parser.getArbol().getRaiz().agregarHijo(tipoNode);
        RESULT = "rodolfo";
    :}
    | STRING
    {:
        Nodo tipoNode = parser.crearNodo("STRING");
        parser.getArbol().getRaiz().agregarHijo(tipoNode);
        RESULT = "cometa";
    :}
    | CHAR
    {:
        Nodo tipoNode = parser.crearNodo("CHAR");
        parser.getArbol().getRaiz().agregarHijo(tipoNode);
        RESULT = "cupido";
    :}
    | FLOAT
    {:
        Nodo tipoNode = parser.crearNodo("FLOAT");
        parser.getArbol().getRaiz().agregarHijo(tipoNode);
        RESULT = "bromista";
    :}
    | BOOL
    {:
        Nodo tipoNode = parser.crearNodo("BOOL");
        parser.getArbol().getRaiz().agregarHijo(tipoNode);
        RESULT = "trueno";
    :};


tiposArr ::=L_INTEGER:i
                          {:
                              Symbol symbol = (Symbol) CUP$parser$stack.peek();
                              parser.agregarVariable(symbol.left, symbol.right, symbol.value.toString(), "rodolfo");
                          :}
        | L_CHAR:c
                        {:
                            Symbol symbol = (Symbol) CUP$parser$stack.peek();
                            parser.agregarVariable(symbol.left, symbol.right, symbol.value.toString(), "cupido");
                        :};

literales ::=
            L_STRING:s
              {:
                  Symbol symbol = (Symbol) CUP$parser$stack.peek();
                  parser.agregarVariable(symbol.left, symbol.right, symbol.value.toString(), "cometa");
                  RESULT = "cometa";
              :}
            | L_CHAR:c
              {:
                  Symbol symbol = (Symbol) CUP$parser$stack.peek();
                  parser.agregarVariable(symbol.left, symbol.right, symbol.value.toString(), "cupido");
                  RESULT = "cupido";
              :}
            | bool:N1
              {:
                  RESULT = N1;
              :}
            | numerosLiterales:N1
              {:
                  RESULT = N1;
              :};

numerosLiterales ::=
    numeroEntero:N1
    {:
        RESULT = N1;
    :}
    | numeroFloat:N1
    {:
        RESULT = N1;
    :};

numeroEntero ::= L_INTEGER:i
    {:
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, symbol.value.toString(), "rodolfo");
        RESULT = "rodolfo";
    :};

numeroFloat ::= L_FLOAT:f
    {:
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, symbol.value.toString(), "bromista");
        RESULT = "bromista";
    :};

bool ::= TRUE {:RESULT = "true";:}
        | FALSE {:RESULT = "false";:};


expresionRelacional ::= asignarTipo:N1 operadorRelacional:op literales:N2
    {:
        Nodo expresionRelacionalNode = parser.crearNodo("EXPRESION_RELACIONAL");

        if (N1 != null) expresionRelacionalNode.agregarHijo(N1);
        if (op != null) expresionRelacionalNode.agregarHijo(parser.crearNodo(op.toString()));
        if (N2 != null) expresionRelacionalNode.agregarHijo(N2);

        RESULT = expresionRelacionalNode;
    :}
    | asignarTipo:N1 operadorRelacional:op variable:N2
    {:
        Nodo expresionRelacionalNode = parser.crearNodo("EXPRESION_RELACIONAL");

        if (N1 != null) expresionRelacionalNode.agregarHijo(N1);
        if (op != null) expresionRelacionalNode.agregarHijo(parser.crearNodo(op.toString()));
        if (N2 != null) expresionRelacionalNode.agregarHijo(N2);

        RESULT = expresionRelacionalNode;
    :}
    | operadorRelacional:op literales:N1
    {:
        Nodo expresionRelacionalNode = parser.crearNodo("EXPRESION_RELACIONAL");

        if (op != null) expresionRelacionalNode.agregarHijo(parser.crearNodo(op.toString()));
        if (N1 != null) expresionRelacionalNode.agregarHijo(N1);

        RESULT = expresionRelacionalNode;
    :};


expresionLogica ::= asignarTipo operadorLogico:op literales:l {: System.out.println("Expresión lógica: " + op + " " + l); :}
                  | negacion literales:n {: System.out.println("Expresión lógica con negación: !" + n); :}
                  |  asignarTipo operadorLogico variable;

asignarTipo ::= tipos:t IDENTIFICADOR:idVar
    {:
        if (t == null || idVar == null) {
            System.err.println("Error: Tipo o identificador no definido.");
            parser.agregarVariable(0, 0, "undefined", "undefined");
        } else {
            Symbol symbol = (Symbol) CUP$parser$stack.peek();
            parser.agregarVariable(symbol.left, symbol.right, idVar.toString(), t.toString());
        }
    :};


operadorRelacional ::= MENOR {:RESULT="snowball";:}
                       | MENOR_IGUAL {:RESULT="evergreen";:}
                       | MAYOR {:RESULT="minstix";:}
                       | MAYOR_IGUAL {:RESULT="upatree";:}
                       | IGUAL {:RESULT="mary";:}
                       | DIFERENTE {:RESULT="openslae";:};

operadorLogico ::= CONJUNCION {:RESULT="melchor";:}
                   | DISYUNCION {:RESULT="gaspar";:};

negacion ::= NEGACION {:RESULT="baltazar";:};

creacion ::= asignarTipo:N FIN_EXPRESION
    {:
        Nodo creacionNode = parser.crearNodo("CREACION");
        creacionNode.agregarHijo(N);
        parser.getArbol().getRaiz().agregarHijo(creacionNode);
        RESULT = creacionNode;
    :}
    | error
    {:
        System.err.println("Error: Asignación inválida");
        RESULT = null;
    :};

creacionAsignacion ::=
    asignarTipo:N1 ASIGNA expresiones:N3 FIN_EXPRESION
    {:
        Nodo creacionAsignacionNode = parser.crearNodo("CREACION_ASIGNACION");
        Nodo asignarTipoNode = (Nodo) N1;
        Nodo expresionesNode = (Nodo) N3;

        creacionAsignacionNode.agregarHijo(asignarTipoNode);
        creacionAsignacionNode.agregarHijo(parser.crearNodo("="));
        creacionAsignacionNode.agregarHijo(expresionesNode);

        parser.getArbol().getRaiz().agregarHijo(creacionAsignacionNode);
        RESULT = creacionAsignacionNode;
    :}
    | asignarTipo:N1 ASIGNA expresionLogica:N3 FIN_EXPRESION
    {:
        Nodo creacionAsignacionNode = parser.crearNodo("CREACION_ASIGNACION");
        Nodo asignarTipoNode = (Nodo) N1;
        Nodo expresionLogicaNode = (Nodo) N3;

        creacionAsignacionNode.agregarHijo(asignarTipoNode);
        creacionAsignacionNode.agregarHijo(parser.crearNodo("="));
        creacionAsignacionNode.agregarHijo(expresionLogicaNode);

        parser.getArbol().getRaiz().agregarHijo(creacionAsignacionNode);
        RESULT = creacionAsignacionNode;
    :}
    | asignarTipo:N1 ASIGNA IDENTIFICADOR:I FIN_EXPRESION
    {:
        Nodo creacionAsignacionNode = parser.crearNodo("CREACION_ASIGNACION");
        Nodo asignarTipoNode = (Nodo) N1;
        // Convertir IDENTIFICADOR a Nodo
        Nodo identificadorNode = parser.crearNodo(I.toString());

        creacionAsignacionNode.agregarHijo(asignarTipoNode);
        creacionAsignacionNode.agregarHijo(parser.crearNodo("="));
        creacionAsignacionNode.agregarHijo(identificadorNode);

        parser.getArbol().getRaiz().agregarHijo(creacionAsignacionNode);
        RESULT = creacionAsignacionNode;
    :}
    | asignarTipo:N1 error
    {:
        System.err.println("Error: Expresión inválida");
        RESULT = null;
    :}
    | ASIGNA literales:N2 FIN_EXPRESION
    {:
        Nodo asignacionNode = parser.crearNodo("ASIGNA_LITERAL");
        Nodo literalNode = (Nodo) N2;

        asignacionNode.agregarHijo(parser.crearNodo("="));
        asignacionNode.agregarHijo(literalNode);

        parser.getArbol().getRaiz().agregarHijo(asignacionNode);
        RESULT = asignacionNode;
    :}
    | asignarTipo:N1 ASIGNA literales:N2 error
    {:
        System.err.println("Error: Falta el fin de expresión");
        RESULT = null;
    :};

sentencias ::= sentencia:N1
    {:
        // Crear un nodo para las sentencias
        Nodo sentenciasNode = parser.crearNodo("SENTENCIAS");

        // Agregar la sentencia al nodo
        if (N1 != null) sentenciasNode.agregarHijo(N1);

        // Agregar el nodo al árbol
        parser.getArbol().getRaiz().agregarHijo(sentenciasNode);
        RESULT = sentenciasNode;
    :}
    | sentencias:N1 sentencia:N2
    {:
        // Reutilizar el nodo de sentencias existente
        Nodo sentenciasNode = (Nodo) N1;

        // Agregar la nueva sentencia como hijo
        if (N2 != null) sentenciasNode.agregarHijo(N2);

        RESULT = sentenciasNode;
    :};

sentencia ::=
            expresionArr
            | invocacionFuncion
            | sentenciaEstructura:N1
            {:
                RESULT = N1;
            :}
            | asignaVariable
            | creacion
            | creacionAsignacion
            | print
            | read;

funciones ::= funcion:N1
    {:
        // Crear el nodo de FUNCIONES
        Nodo funcionesNode = parser.crearNodo("FUNCIONES");
        // Agregar la función como hijo si no es nula
        if (N1 != null) {funcionesNode.agregarHijo(N1);}
        parser.getArbol().getRaiz().agregarHijo(funcionesNode);
        RESULT = funcionesNode;
    :}
    | funciones:N1 funcion:N2
    {:
        Nodo funcionesNode = (Nodo) N1;
        if (N2 != null) {funcionesNode.agregarHijo(N2);}
        RESULT = funcionesNode;
    :};

funcion ::= encabezadoFuncion:e
        {:
            parser.agregarTablaSimbolos("funcion", e.toString());
        :}
        parametros:N1 bloque:N2
        {:
            // Crear el nodo de la función
            Nodo funcionNode = parser.crearNodo("FUNCION");
            // Crear y agregar el encabezado
            String nombreFuncion = e.toString();
            Nodo encabezadoNode = parser.crearNodo(nombreFuncion);
            funcionNode.agregarHijo(encabezadoNode);
            // Validar y agregar parámetros
            if (N1 != null) {funcionNode.agregarHijo(N1);}

            // Validar y agregar bloque
            if (N2 != null) {funcionNode.agregarHijo(N2);}
            // Retornar el nodo de la función
            RESULT = funcionNode;
        :};


encabezadoFuncion ::= tipos:t IDENTIFICADOR:id
    {:
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, symbol.value.toString(), t.toString());
        RESULT = id.toString();
    :}
     | IDENTIFICADOR
      error {: System.err.println("Error: Al encabezado de la función le falta el tipo"); :}
     |error;

bloque ::= corcheteIzquierdo sentencias return_funcion corcheteDerecho
         | corcheteIzquierdo  corcheteDerecho
         error {: System.err.println("Error: bloque vacio"); :}
         | corcheteIzquierdo sentencias  corcheteDerecho
          error {: System.err.println("Error: A la función le falta el retorno"); :}
         | corcheteIzquierdo sentencias return_funcion
          error {: System.err.println("Error: El bloque de la función no se cerró"); :};

return_funcion ::= RETURN literales:N1 FIN_EXPRESION
    {:
        Nodo returnNode = parser.crearNodo("RETURN");

        // Verificar y agregar el nodo del literal como cadena
        if (N1 != null) {
            returnNode.agregarHijo(parser.crearNodo("return"));
            returnNode.agregarHijo(parser.crearNodo(N1.toString()));
            Symbol symbol = (Symbol) CUP$parser$stack.peek();
            parser.agregarVariable(symbol.left, symbol.right, "return", N1.toString());
        } else {
            System.err.println("Error: El tipo de retorno es nulo.");
            parser.agregarVariable(0, 0, "return", "undefined");
        }

        // Agregar el nodo RETURN al árbol
        parser.getArbol().getRaiz().agregarHijo(returnNode);
        RESULT = returnNode;
    :}
    | RETURN variable:N1 FIN_EXPRESION
    {:
        Nodo returnNode = parser.crearNodo("RETURN");

        // Verificar y agregar el nodo de la variable
        if (N1 != null) {
            returnNode.agregarHijo(parser.crearNodo("return"));
            returnNode.agregarHijo(N1);
            Symbol symbol = (Symbol) CUP$parser$stack.peek();
            parser.agregarVariable(symbol.left, symbol.right, "return", N1.toString());
        } else {
            System.err.println("Error: El valor de retorno es nulo.");
            parser.agregarVariable(0, 0, "return", "undefined");
        }

        // Agregar el nodo RETURN al árbol
        parser.getArbol().getRaiz().agregarHijo(returnNode);
        RESULT = returnNode;
    :};

parametros ::= PARENTESISAPERTURA
    {:
        Nodo parametrosNode = parser.crearNodo("PARAMETROS");
        // Nodo para apertura de paréntesis
        parametrosNode.agregarHijo(parser.crearNodo("("));
        // Agregar a la raíz
        parser.getArbol().getRaiz().agregarHijo(parametrosNode);
        RESULT = parametrosNode;
    :}
    PARENTESISCIERRE
    {:
        Nodo parametrosNode = (Nodo) RESULT;
        // Nodo para cierre de paréntesis
        parametrosNode.agregarHijo(parser.crearNodo(")"));
    :}
    | PARENTESISAPERTURA
    {:
        Nodo parametrosNode = parser.crearNodo("PARAMETROS");
        // Nodo para apertura de paréntesis
        parametrosNode.agregarHijo(parser.crearNodo("("));
        // Agregar a la raíz
        parser.getArbol().getRaiz().agregarHijo(parametrosNode);
        RESULT = parametrosNode;
    :}
    parametroAux:N1 PARENTESISCIERRE
    {:
        Nodo parametrosNode = (Nodo) RESULT;
        // Agregar nodo de parametroAux
        parametrosNode.agregarHijo(N1);
        // Nodo para cierre de paréntesis
        parametrosNode.agregarHijo(parser.crearNodo(")"));
    :}
    | error
    {:
        System.err.println("Error: Parámetros mal definidos");
        RESULT = null;
    :};

parametroAux ::= tipos:t IDENTIFICADOR:id
    {:
        // Verificar y agregar a la tabla de símbolos
        if (t == null || id == null) {
            System.err.println("Error: Parámetro inválido (tipo o identificador nulo).");
            parser.agregarVariable(0, 0, "parametro: undefined", "undefined");
        } else {
            Symbol symbol = (Symbol) CUP$parser$stack.peek();
            parser.agregarVariable(symbol.left, symbol.right, "parametro: " + id.toString(), t.toString());
            System.out.println("Parámetro agregado: " + id.toString() + " de tipo " + t.toString());
        }
        // Crear el nodo para el parámetro
        Nodo parametrosNode = parser.crearNodo("PARAMETROS");
        Nodo parametroNode = parser.crearNodo("PARAMETRO");
        // Nodo del tipo
        parametroNode.agregarHijo(parser.crearNodo(t.toString()));
        // Nodo del identificador
        parametroNode.agregarHijo(parser.crearNodo(id.toString()));
        // Agregar el parámetro al nodo de parámetros
        parametrosNode.agregarHijo(parametroNode);
        RESULT = parametrosNode;
    :}

    | parametroAux:N1 COMA tipos:t IDENTIFICADOR:id
    {:
        // Verificar y agregar a la tabla de símbolos
        if (t == null || id == null) {
            System.err.println("Error: Parámetro adicional inválido (tipo o identificador nulo).");
            parser.agregarVariable(0, 0, "parametro: undefined", "undefined");
        } else {
            Symbol symbol = (Symbol) CUP$parser$stack.peek();
            parser.agregarVariable(symbol.left, symbol.right, "parametro: " + id.toString(), t.toString());
            System.out.println("Parámetro adicional agregado: " + id.toString() + " de tipo " + t.toString());
        }
        // Crear el nodo para el nuevo parámetro
        Nodo nuevoParametroNode = parser.crearNodo("PARAMETRO");
        // Nodo del tipo
        nuevoParametroNode.agregarHijo(parser.crearNodo(t.toString()));
        // Nodo del identificador
        nuevoParametroNode.agregarHijo(parser.crearNodo(id.toString()));
        // Nodo existente de parámetros para el nuevo parametro
        Nodo parametrosNode = (Nodo) N1;
        // Agregar el nuevo parámetro
        parametrosNode.agregarHijo(nuevoParametroNode);
        RESULT = parametrosNode;
    :};

expresionArr ::= crearArreglos:N1 operadorRelacional:op arreglos:N2 FIN_EXPRESION
    {:
        Nodo expresionArrNode = parser.crearNodo("EXPRESION_ARR");
        if (N1 != null) expresionArrNode.agregarHijo(N1); // Nodo de crearArreglos
        if (op != null) expresionArrNode.agregarHijo(parser.crearNodo(op.toString())); // Nodo del operador relacional
        if (N2 != null) expresionArrNode.agregarHijo(N2); // Nodo de arreglos
        parser.getArbol().getRaiz().agregarHijo(expresionArrNode); // Agregar al árbol
        RESULT = expresionArrNode;
    :}
    | crearArreglos:N1 ASIGNA arreglos:N2 FIN_EXPRESION
    {:
        Nodo expresionArrNode = parser.crearNodo("EXPRESION_ARR");
        if (N1 != null) expresionArrNode.agregarHijo(N1); // Nodo de crearArreglos
        expresionArrNode.agregarHijo(parser.crearNodo("=")); // Nodo del operador de asignación
        if (N2 != null) expresionArrNode.agregarHijo(N2); // Nodo de arreglos
        parser.getArbol().getRaiz().agregarHijo(expresionArrNode); // Agregar al árbol
        RESULT = expresionArrNode;
    :}
    | arreglos:N1 ASIGNA arreglos:N2 FIN_EXPRESION
    {:
        Nodo expresionArrNode = parser.crearNodo("EXPRESION_ARR");
        if (N1 != null) expresionArrNode.agregarHijo(N1); // Nodo del primer arreglo
        expresionArrNode.agregarHijo(parser.crearNodo("=")); // Nodo del operador de asignación
        if (N2 != null) expresionArrNode.agregarHijo(N2); // Nodo del segundo arreglo
        parser.getArbol().getRaiz().agregarHijo(expresionArrNode); // Agregar al árbol
        RESULT = expresionArrNode;
    :}
    | arreglos:N1 operadorRelacional:op arreglos:N2 FIN_EXPRESION
    {:
        Nodo expresionArrNode = parser.crearNodo("EXPRESION_ARR");
        if (N1 != null) expresionArrNode.agregarHijo(N1); // Nodo del primer arreglo
        if (op != null) expresionArrNode.agregarHijo(parser.crearNodo(op.toString())); // Nodo del operador relacional
        if (N2 != null) expresionArrNode.agregarHijo(N2); // Nodo del segundo arreglo
        parser.getArbol().getRaiz().agregarHijo(expresionArrNode); // Agregar al árbol
        RESULT = expresionArrNode;
    :};

crearArreglos ::= tipos:t IDENTIFICADOR:id
    {:
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, symbol.value.toString(), t.toString() + "[]");
    :}
    CORCHETEAPERTURA IDENTIFICADOR:idVarArr CORCHETECIERRE
    {:
        // Crear el nodo para la creación del arreglo
        Nodo crearArreglosNode = parser.crearNodo("CREAR_ARREGLO");
        if (t != null) crearArreglosNode.agregarHijo(parser.crearNodo(t.toString())); // Nodo del tipo
        if (id != null) crearArreglosNode.agregarHijo(parser.crearNodo(id.toString())); // Nodo del identificador
        crearArreglosNode.agregarHijo(parser.crearNodo("[")); // Nodo de apertura de corchete
        if (idVarArr != null) crearArreglosNode.agregarHijo(parser.crearNodo(idVarArr.toString())); // Nodo del identificador del tamaño
        crearArreglosNode.agregarHijo(parser.crearNodo("]")); // Nodo de cierre de corchete

        RESULT = crearArreglosNode; // Retornar el nodo
    :};

modificarArreglos ::= IDENTIFICADOR:idVar
                      CORCHETEAPERTURA{: RESULT = "abreempaque"; :}
                      IDENTIFICADOR:id
                      CORCHETECIERRE{: RESULT = "cierraempaque"; :} ;

arreglos ::= arreglo:N1
    {:
        Nodo arreglosNode = parser.crearNodo("ARREGLOS");
        if (N1 != null) arreglosNode.agregarHijo(N1);
        RESULT = arreglosNode;
    :}
    | arreglos:N1 arreglo:N2
    {:
        Nodo arreglosNode = (Nodo) N1;
        if (N2 != null) arreglosNode.agregarHijo(N2);
        RESULT = arreglosNode;
    :};

arreglo ::= parametrosArreglo;

parametrosArreglo ::= corcheteIzquierdo corcheteDerecho
    {:
        // Crear nodo para el parámetro de arreglo vacío
        Nodo parametroArregloNode = parser.crearNodo("PARAMETRO_ARREGLO");
        parametroArregloNode.agregarHijo(parser.crearNodo("corcheteIzquierdo")); // Nodo de apertura de corchete
        parametroArregloNode.agregarHijo(parser.crearNodo("corcheteDerecho")); // Nodo de cierre de corchete
        RESULT = parametroArregloNode;
    :}
    | corcheteIzquierdo parametrosArregloAux:N1 corcheteDerecho
    {:
        // Crear nodo para el parámetro de arreglo con contenido
        Nodo parametroArregloNode = parser.crearNodo("PARAMETRO_ARREGLO");
        parametroArregloNode.agregarHijo(parser.crearNodo("corcheteIzquierdo")); // Nodo de apertura de corchete
        parametroArregloNode.agregarHijo(N1); // Nodo auxiliar con parámetros
        parametroArregloNode.agregarHijo(parser.crearNodo("corcheteDerecho")); // Nodo de cierre de corchete
        RESULT = parametroArregloNode;
    :};

parametrosArregloAux ::= tiposArr | parametrosArregloAux COMA{: RESULT = ","; :}
                                        tiposArr;

asignaVariable ::= variable ASIGNA{:RESULT="entrega";:} literales
                | variable ASIGNA expresionCompleja FIN_EXPRESION
                | modificarArreglos ASIGNA{:RESULT="entrega";:} tiposArr FIN_EXPRESION
                | modificarArreglos operadorRelacional tiposArr FIN_EXPRESION;

variable ::= IDENTIFICADOR:idVar {: System.out.println("Variable: " + idVar.toString());
                RESULT = idVar.toString();
                :};

expresionCompleja ::= expresionBinaria
                    | expresionUnario
                    | expresionRelacionalMat
                    | expresionLogica
                    | PARENTESISAPERTURA expresionCompleja PARENTESISCIERRE
                    | expresionBinaria operadorRelacional expresionLogica
                    | expresionLogica operadorLogico literales
                    | expresionBinaria expresionUnario
                    | expresionCompleja operadorRelacional numerosLiterales operadorLogico bool;


operandoBinaria ::= SUMA {:RESULT="navidad";:}
                | RESTA {:RESULT="intercambio";:}
                | DIVISION {:RESULT="reyes";:}
                | MULTIPLICACION {:RESULT="nochebuena";:}
                | MODULO {:RESULT="magos";:}
                | POTENCIA {:RESULT="adviento";:};

expresionBinaria ::= numerosLiterales:e1 operandoBinaria:op numerosLiterales:e2
                    {:
                            String tipo1 = (e1 instanceof String) ? e1.toString() : parser.getTipo(listaTablasSimbolos.get(currentHash), e1.toString());
                            String tipo2 = (e2 instanceof String) ? e2.toString() : parser.getTipo(listaTablasSimbolos.get(currentHash), e2.toString());

                            if (!tipo1.equals("rodolfo") && !tipo1.equals("bromista")) {
                                System.err.println("Error semántico: Operando izquierdo no es un tipo numérico en " + op + " " + e1);
                            }
                            if (!tipo2.equals("rodolfo") && !tipo2.equals("bromista")) {
                                System.err.println("Error semántico: Operando derecho no es un tipo numérico en " + op + " " + e2);
                            }
                            if (!tipo1.equals(tipo2)) {
                                System.err.println("Error semántico: Tipos incompatibles entre " + e1 + " (" + tipo1 + ") y " + e2 + " (" + tipo2 + ")");
                            }
                            String tipoResultado = tipo1.equals("bromista") || tipo2.equals("bromista") ? "bromista" : "rodolfo";
                            RESULT = tipoResultado;
                        :}
                    | numerosLiterales:e1 operandoBinaria:op
                        {:
                            String tipo1 = (e1 instanceof String) ? e1.toString() : parser.getTipo(listaTablasSimbolos.get(currentHash), e1.toString());

                            if (!tipo1.equals("rodolfo") && !tipo1.equals("bromista")) {
                                System.err.println("Error semántico: Operando izquierdo no es un tipo numérico en " + op + " " + e1);
                            }

                            RESULT = tipo1;
                        :}
                    | variable:e1 operandoBinaria:op numerosLiterales:e2
                        {:
                            String tipo1 = parser.getTipo(listaTablasSimbolos.get(currentHash), e1.toString());
                            String tipo2 = (e2 instanceof String) ? e2.toString() : parser.getTipo(listaTablasSimbolos.get(currentHash), e2.toString());

                            if (!tipo1.equals("rodolfo") && !tipo1.equals("bromista")) {
                                System.err.println("Error semántico: Operando izquierdo no es un tipo numérico en " + op + " " + e1);
                            }
                            if (!tipo2.equals("rodolfo") && !tipo2.equals("bromista")) {
                                System.err.println("Error semántico: Operando derecho no es un tipo numérico en " + op + " " + e2);
                            }
                            if (!tipo1.equals(tipo2)) {
                                System.err.println("Error semántico: Tipos incompatibles entre " + e1 + " (" + tipo1 + ") y " + e2 + " (" + tipo2 + ")");
                            }

                            String tipoResultado = tipo1.equals("bromista") || tipo2.equals("bromista") ? "bromista" : "rodolfo";

                            RESULT = tipoResultado;
                        :}
                    | variable:e1 operandoBinaria:op
                        {:
                            String tipo1 = parser.getTipo(listaTablasSimbolos.get(currentHash), e1.toString());

                            if (!tipo1.equals("rodolfo") && !tipo1.equals("bromista")) {
                                System.err.println("Error semántico: Operando izquierdo no es un tipo numérico en " + op + " " + e1);
                            }

                            RESULT = tipo1;
                        :}
                    | variable:e1 operandoBinaria:op numerosLiterales:e2 operandoBinaria:op2 numerosLiterales:e3
                        {:
                            String tipo1 = parser.getTipo(listaTablasSimbolos.get(currentHash), e1.toString());
                            String tipo2 = (e2 instanceof String) ? e2.toString() : parser.getTipo(listaTablasSimbolos.get(currentHash), e2.toString());
                            String tipo3 = (e3 instanceof String) ? e3.toString() : parser.getTipo(listaTablasSimbolos.get(currentHash), e3.toString());

                            if (!tipo1.equals("rodolfo") && !tipo1.equals("bromista")) {
                                System.err.println("Error semántico: Primer operando no es un tipo numérico en " + op + " " + e1);
                            }
                            if (!tipo2.equals("rodolfo") && !tipo2.equals("bromista")) {
                                System.err.println("Error semántico: Segundo operando no es un tipo numérico en " + op + " " + e2);
                            }
                            if (!tipo3.equals("rodolfo") && !tipo3.equals("bromista")) {
                                System.err.println("Error semántico: Tercer operando no es un tipo numérico en " + op2 + " " + e3);
                            }
                            if (!tipo1.equals(tipo2) || !tipo2.equals(tipo3)) {
                                System.err.println("Error semántico: Tipos incompatibles en la expresión binaria compuesta.");
                            }

                            String tipoResultado = tipo1.equals("bromista") || tipo2.equals("bromista") || tipo3.equals("bromista") ? "bromista" : "rodolfo";

                            RESULT = tipoResultado;
                        :};


operandoUnario ::= INCREMENTO {:RESULT="quien";:}
                | DECREMENTO {:RESULT="grinch";:};
expresionUnario ::= numerosLiterales operandoUnario
                | NEGATIVO {:RESULT="-";:}
                numerosLiterales
                | variable operandoUnario;

expresionRelacionalMat ::= numerosLiterales operadorRelacional numerosLiterales
                       | variable operadorRelacional numerosLiterales
                       | variable operadorRelacional numerosLiterales operandoBinaria numerosLiterales;

expresiones ::= expresionRelacional
              | literales
              | operandoBinaria numerosLiterales
              | expresionBinaria
              | expresionUnario
              | expresionRelacionalMat
              | expresionBinaria operadorRelacional literales
              | expresionBinaria operadorRelacional variable
              | variable ASIGNA variable
              | PARENTESISAPERTURA {: RESULT = "abreregalo"; :}
              expresiones
              PARENTESISCIERRE{: RESULT = "cierraregalo"; :};

sentencia_lista ::= sentenciaEstructura | sentencia_lista sentenciaEstructura;

sentenciaEstructura ::= for_estructura:N1
    {:
        RESULT = N1; // Pasar directamente el nodo del for
    :}
    | while_estructura:N1
    {:
        RESULT = N1; // Pasar directamente el nodo del while
    :}
    | if_estructura:N1
    {:
        RESULT = N1; // Pasar directamente el nodo del if
    :}
    | switch_estructura:N1
    {:
        RESULT = N1; // Pasar directamente el nodo del switch
    :}
    | expresiones:N1 FIN_EXPRESION
    {:
        // Crear un nodo para la expresión seguida de fin de expresión
        Nodo sentenciaExpresionNode = parser.crearNodo("SENTENCIA_EXPRESION");
        sentenciaExpresionNode.agregarHijo(N1); // Nodo de la expresión
        sentenciaExpresionNode.agregarHijo(parser.crearNodo(";")); // Nodo para el fin de expresión
        RESULT = sentenciaExpresionNode;
    :};

if_estructura ::= IF PARENTESISAPERTURA expresiones:N1 PARENTESISCIERRE corcheteIzquierdo sentencias:N2 corcheteDerecho
    {:
        Nodo ifNode = parser.crearNodo("IF");

        // Agregar la expresión condicional
        if (N1 != null) {
            ifNode.agregarHijo(parser.crearNodo("if"));
            ifNode.agregarHijo(N1);
        }

        // Agregar el bloque de sentencias
        if (N2 != null) {
            ifNode.agregarHijo(N2);
        }

        // Agregar a la tabla de símbolos
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, "if", "elfo");

        parser.getArbol().getRaiz().agregarHijo(ifNode);
        RESULT = ifNode;
    :}
 //   |IF PARENTESISAPERTURA expresiones:N1 PARENTESISCIERRE corcheteIzquierdo sentencias corcheteDerecho
    | IF PARENTESISAPERTURA expresiones:N1 PARENTESISCIERRE corcheteIzquierdo return_estructura:N2 corcheteDerecho
    {:
        Nodo ifNode = parser.crearNodo("IF");

        if (N1 != null) {
            ifNode.agregarHijo(parser.crearNodo("if"));
            ifNode.agregarHijo(N1);
        }

        if (N2 != null) {
            ifNode.agregarHijo(N2);
        }

        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, "if", "elfo");

        parser.getArbol().getRaiz().agregarHijo(ifNode);
        RESULT = ifNode;
    :}
    | IF PARENTESISAPERTURA expresiones:N1 PARENTESISCIERRE corcheteIzquierdo sentencias:N2 return_estructura:N3 corcheteDerecho
    {:
        Nodo ifNode = parser.crearNodo("IF");

        if (N1 != null) {
            ifNode.agregarHijo(parser.crearNodo("if"));
            ifNode.agregarHijo(N1);
        }

        if (N2 != null) ifNode.agregarHijo(N2);
        if (N3 != null) ifNode.agregarHijo(N3);

        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, "if", "elfo");

        parser.getArbol().getRaiz().agregarHijo(ifNode);
        RESULT = ifNode;
    :}
    | if_estructura:N1 ELSE corcheteIzquierdo sentencias:N2 corcheteDerecho
    {:
        Nodo ifElseNode = parser.crearNodo("ELSE");

        if (N1 != null) ifElseNode.agregarHijo(N1);
        ifElseNode.agregarHijo(parser.crearNodo("else"));
        if (N2 != null) ifElseNode.agregarHijo(N2);

        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, "else", "hada");

        parser.getArbol().getRaiz().agregarHijo(ifElseNode);
        RESULT = ifElseNode;
    :}
    | if_estructura:N1 ELSE corcheteIzquierdo return_estructura:N2 corcheteDerecho
    {:
        Nodo ifElseNode = parser.crearNodo("ELSE");

        if (N1 != null) ifElseNode.agregarHijo(N1);
        ifElseNode.agregarHijo(parser.crearNodo("else"));
        if (N2 != null) ifElseNode.agregarHijo(N2);

        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, "else", "hada");

        parser.getArbol().getRaiz().agregarHijo(ifElseNode);
        RESULT = ifElseNode;
    :}
    | if_estructura:N1 ELSE corcheteIzquierdo sentencias:N2 return_estructura:N3 corcheteDerecho
    {:
        Nodo ifElseNode = parser.crearNodo("ELSE");

        if (N1 != null) ifElseNode.agregarHijo(N1);
        ifElseNode.agregarHijo(parser.crearNodo("else"));
        if (N2 != null) ifElseNode.agregarHijo(N2);
        if (N3 != null) ifElseNode.agregarHijo(N3);

        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, "else", "hada");

        parser.getArbol().getRaiz().agregarHijo(ifElseNode);
        RESULT = ifElseNode;
    :};

for_estructura ::= FOR PARENTESISAPERTURA
                    variable:N1 ASIGNA:N2 literales:N3
                    COMA
                    expresiones:N4
                    COMA
                    expresionUnario:N5
                   PARENTESISCIERRE corcheteIzquierdo sentencia_lista:N6 corcheteDerecho
    {:
        Nodo forNode = parser.crearNodo("FOR");

        // Agregar nodos de manera segura
        if (N1 != null) forNode.agregarHijo(N1);
        forNode.agregarHijo(parser.crearNodo("="));
        if (N2 != null) forNode.agregarHijo(N2);
        if (N3 != null) forNode.agregarHijo(N3);
        forNode.agregarHijo(parser.crearNodo(","));
        if (N4 != null) forNode.agregarHijo(N4);
        forNode.agregarHijo(parser.crearNodo(","));
        if (N5 != null) forNode.agregarHijo(N5);
        forNode.agregarHijo(parser.crearNodo(")"));
        forNode.agregarHijo(parser.crearNodo("{"));
        if (N6 != null) forNode.agregarHijo(N6);
        forNode.agregarHijo(parser.crearNodo("}"));
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, "for", "elfo");

        RESULT = forNode;
    :}
    | FOR PARENTESISAPERTURA
        variable:N1 ASIGNA:N2 literales:N3
        COMA
        expresionUnario:N4
        PARENTESISCIERRE corcheteIzquierdo sentencia_lista:N5 corcheteDerecho
    {:
        Nodo forNode = parser.crearNodo("FOR");

        // Agregar nodos de manera segura
        if (N1 != null) forNode.agregarHijo(N1);
        forNode.agregarHijo(parser.crearNodo("="));
        if (N2 != null) forNode.agregarHijo(N2);
        if (N3 != null) forNode.agregarHijo(N3);
        forNode.agregarHijo(parser.crearNodo(","));
        if (N4 != null) forNode.agregarHijo(N4);
        forNode.agregarHijo(parser.crearNodo(")"));
        forNode.agregarHijo(parser.crearNodo("{"));
        if (N5 != null) forNode.agregarHijo(N5);
        forNode.agregarHijo(parser.crearNodo("}"));
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, "for", "elfo");

        RESULT = forNode;
    :}
    | FOR PARENTESISAPERTURA
        creacionAsignacion:N1 COMA
        expresionLogica:N2 COMA
        expresionUnario:N3
        PARENTESISCIERRE corcheteIzquierdo sentencias:N4 corcheteDerecho
    {:
        Nodo forNode = parser.crearNodo("FOR");

        // Agregar nodos de manera segura
        if (N1 != null) forNode.agregarHijo(N1);
        forNode.agregarHijo(parser.crearNodo(","));
        if (N2 != null) forNode.agregarHijo(N2);
        forNode.agregarHijo(parser.crearNodo(","));
        if (N3 != null) forNode.agregarHijo(N3);
        forNode.agregarHijo(parser.crearNodo(")"));
        forNode.agregarHijo(parser.crearNodo("{"));
        if (N4 != null) forNode.agregarHijo(N4);
        forNode.agregarHijo(parser.crearNodo("}"));
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, "for", "elfo");

        RESULT = forNode;
    :};

while_estructura ::= WHILE PARENTESISAPERTURA expresionCompleja:N1 PARENTESISCIERRE corcheteIzquierdo expresiones:N2 corcheteDerecho
    {:
        Nodo whileNode = parser.crearNodo("WHILE");
        whileNode.agregarHijo(parser.crearNodo("while"));
        whileNode.agregarHijo(parser.crearNodo("("));
        if (N1 != null) whileNode.agregarHijo(N1); // Nodo de la expresión compleja
        whileNode.agregarHijo(parser.crearNodo(")"));
        whileNode.agregarHijo(parser.crearNodo("{"));
        if (N2 != null) whileNode.agregarHijo(N2); // Nodo de las expresiones
        whileNode.agregarHijo(parser.crearNodo("}"));
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, "while", "envuelve");

        RESULT = whileNode;
    :}
    | WHILE PARENTESISAPERTURA expresionCompleja:N1 operadorLogico:N2 expresiones:N3 expresionRelacional:N4 PARENTESISCIERRE
      corcheteIzquierdo expresiones:N5 return_estructura:N6 corcheteDerecho
    {:
        Nodo whileNode = parser.crearNodo("WHILE");
        whileNode.agregarHijo(parser.crearNodo("while"));
        whileNode.agregarHijo(parser.crearNodo("("));
        if (N1 != null) whileNode.agregarHijo(N1); // Expresión compleja
        if (N2 != null) whileNode.agregarHijo(N2); // Operador lógico
        if (N3 != null) whileNode.agregarHijo(N3); // Expresiones
        if (N4 != null) whileNode.agregarHijo(N4); // Expresión relacional
        whileNode.agregarHijo(parser.crearNodo(")"));
        whileNode.agregarHijo(parser.crearNodo("{"));
        if (N5 != null) whileNode.agregarHijo(N5); // Expresiones dentro del bloque
        if (N6 != null) whileNode.agregarHijo(N6); // Return estructura
        whileNode.agregarHijo(parser.crearNodo("}"));
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, "while", "envuelve");

        RESULT = whileNode;
    :}
    | WHILE PARENTESISAPERTURA expresionCompleja:N1 operadorLogico:N2 expresiones:N3 expresionRelacional:N4 PARENTESISCIERRE
      corcheteIzquierdo sentencia:N5 return_estructura:N6 corcheteDerecho
    {:
        Nodo whileNode = parser.crearNodo("WHILE");
        whileNode.agregarHijo(parser.crearNodo("while"));
        whileNode.agregarHijo(parser.crearNodo("("));
        if (N1 != null) whileNode.agregarHijo(N1); // Expresión compleja
        if (N2 != null) whileNode.agregarHijo(N2); // Operador lógico
        if (N3 != null) whileNode.agregarHijo(N3); // Expresiones
        if (N4 != null) whileNode.agregarHijo(N4); // Expresión relacional
        whileNode.agregarHijo(parser.crearNodo(")"));
        whileNode.agregarHijo(parser.crearNodo("{"));
        if (N5 != null) whileNode.agregarHijo(N5); // Sentencia dentro del bloque
        if (N6 != null) whileNode.agregarHijo(N6); // Return estructura
        whileNode.agregarHijo(parser.crearNodo("}"));
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, "while", "envuelve");

        RESULT = whileNode;
    :}
    | WHILE PARENTESISAPERTURA expresionCompleja:N1 operadorLogico:N2 expresiones:N3 PARENTESISCIERRE
      corcheteIzquierdo expresiones:N4 return_estructura:N5 corcheteDerecho
    {:
        Nodo whileNode = parser.crearNodo("WHILE");
        whileNode.agregarHijo(parser.crearNodo("while"));
        whileNode.agregarHijo(parser.crearNodo("("));
        if (N1 != null) whileNode.agregarHijo(N1); // Expresión compleja
        if (N2 != null) whileNode.agregarHijo(N2); // Operador lógico
        if (N3 != null) whileNode.agregarHijo(N3); // Expresiones
        whileNode.agregarHijo(parser.crearNodo(")"));
        whileNode.agregarHijo(parser.crearNodo("{"));
        if (N4 != null) whileNode.agregarHijo(N4); // Expresiones dentro del bloque
        if (N5 != null) whileNode.agregarHijo(N5); // Return estructura
        whileNode.agregarHijo(parser.crearNodo("}"));
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, "while", "envuelve");
        RESULT = whileNode;
    :};

switch_estructura ::= SWITCH PARENTESISAPERTURA variable:v PARENTESISCIERRE
                     corcheteIzquierdo casos_switch:N1 corcheteDerecho
    {:
        Nodo switchNode = parser.crearNodo("SWITCH");

        // Verificar y agregar la variable
        if (v != null) {
            switchNode.agregarHijo(parser.crearNodo("switch"));
            switchNode.agregarHijo(v);

            // Agregar a la tabla de símbolos
            Symbol symbol = (Symbol) CUP$parser$stack.peek();
            parser.agregarVariable(symbol.left, symbol.right, "switch", "varios");
        } else {
            Symbol symbol = (Symbol) CUP$parser$stack.peek();
            parser.agregarVariable(symbol.left, symbol.right, "switch", "varios");
        }

        if (N1 != null) switchNode.agregarHijo(N1);

        parser.getArbol().getRaiz().agregarHijo(switchNode);
        RESULT = switchNode;
    :}
    | SWITCH PARENTESISAPERTURA variable:v PARENTESISCIERRE
      corcheteIzquierdo casos_switch:N1 default_case:N2 corcheteDerecho
    {:
        Nodo switchNode = parser.crearNodo("SWITCH");

        if (v != null) {
            switchNode.agregarHijo(parser.crearNodo("switch"));
            switchNode.agregarHijo(v);

            // Agregar a la tabla de símbolos
            Symbol symbol = (Symbol) CUP$parser$stack.peek();
            parser.agregarVariable(symbol.left, symbol.right, "switch", "varios");
        }
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, "switch", "varios");
        if (N1 != null) switchNode.agregarHijo(N1);
        if (N2 != null) switchNode.agregarHijo(N2);

        parser.getArbol().getRaiz().agregarHijo(switchNode);
        RESULT = switchNode;
    :}
    | SWITCH PARENTESISAPERTURA variable:v PARENTESISCIERRE
      corcheteIzquierdo casos_switch:N1 return_estructura:N2 corcheteDerecho
    {:
        Nodo switchNode = parser.crearNodo("SWITCH");

        if (v != null) {
            switchNode.agregarHijo(parser.crearNodo("switch"));
            switchNode.agregarHijo(v);

            // Agregar a la tabla de símbolos
            Symbol symbol = (Symbol) CUP$parser$stack.peek();
            parser.agregarVariable(symbol.left, symbol.right, "switch", "varios");
        }
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, "switch", "varios");
        if (N1 != null) switchNode.agregarHijo(N1);
        if (N2 != null) switchNode.agregarHijo(N2);

        parser.getArbol().getRaiz().agregarHijo(switchNode);
        RESULT = switchNode;
    :}
    | SWITCH PARENTESISAPERTURA variable:v PARENTESISCIERRE
      corcheteIzquierdo casos_switch:N1 return_estructura:N2 default_case:N3 corcheteDerecho
    {:
        Nodo switchNode = parser.crearNodo("SWITCH");

        if (v != null) {
            switchNode.agregarHijo(parser.crearNodo("switch"));
            switchNode.agregarHijo(v);

            // Agregar a la tabla de símbolos
            Symbol symbol = (Symbol) CUP$parser$stack.peek();
            parser.agregarVariable(symbol.left, symbol.right, "switch", "varios");
        }
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, "switch", "varios");
        if (N1 != null) switchNode.agregarHijo(N1);
        if (N2 != null) switchNode.agregarHijo(N2);
        if (N3 != null) switchNode.agregarHijo(N3);

        parser.getArbol().getRaiz().agregarHijo(switchNode);
        RESULT = switchNode;
    :};

casos_switch ::= caso_switch:N1
    {:
        RESULT = N1;
    :}
    | casos_switch:N1 caso_switch:N2
    {:
        Nodo casosNode = (Nodo) N1;
        if (N2 != null) casosNode.agregarHijo(N2);
        RESULT = casosNode;
    :}
    |casos_switch:N1 break_estructura
        {:
                Nodo casosNode = (Nodo) N1;
                RESULT = casosNode;
            :}
        ;

caso_switch ::= CASE numerosLiterales:N1 DOS_PUNTOS sentencias:N2 FIN_EXPRESION
    {:
        Nodo casoNode = parser.crearNodo("CASE");

        // Verificar y agregar el nodo de números literales (N1)
        if (N1 != null) {
            casoNode.agregarHijo(N1);

            // Agregar a la tabla de símbolos con el valor de N1
            Symbol symbol = (Symbol) CUP$parser$stack.peek();
            parser.agregarVariable(symbol.left, symbol.right, "case", N1.toString());
        } else {
            parser.agregarVariable(0, 0, "case", "historia");
        }

        // Agregar el nodo ":" y sentencia (N2)
        casoNode.agregarHijo(parser.crearNodo(":"));
        if (N2 != null) casoNode.agregarHijo(N2);

        RESULT = casoNode;
    :}
    | CASE numerosLiterales:N1 DOS_PUNTOS expresiones:N2 FIN_EXPRESION
    {:
        Nodo casoNode = parser.crearNodo("CASE");

        // Verificar y agregar el nodo de números literales (N1)
        if (N1 != null) {
            casoNode.agregarHijo(N1);

            // Agregar a la tabla de símbolos con el valor de N1
            Symbol symbol = (Symbol) CUP$parser$stack.peek();
            parser.agregarVariable(symbol.left, symbol.right, "case", N1.toString());
        } else {
            parser.agregarVariable(0, 0, "case", "historia");
        }

        // Agregar el nodo ":" y expresiones (N2)
        casoNode.agregarHijo(parser.crearNodo(":"));
        if (N2 != null) casoNode.agregarHijo(N2);

        RESULT = casoNode;
    :};

default_case ::= DEFAULT DOS_PUNTOS expresiones:N1 FIN_EXPRESION
    {:
        Nodo defaultNode = parser.crearNodo("DEFAULT");

        defaultNode.agregarHijo(parser.crearNodo("default"));
        defaultNode.agregarHijo(parser.crearNodo(":"));
        if (N1 != null) defaultNode.agregarHijo(N1);

        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, "default", "default_case");
        RESULT = defaultNode;
    :};


break_estructura ::= BREAK FIN_EXPRESION
    {:
        Nodo breakNode = parser.crearNodo("BREAK");
        breakNode.agregarHijo(parser.crearNodo("break"));

        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, "break", "break_statement");

        parser.getArbol().getRaiz().agregarHijo(breakNode);
        RESULT = breakNode;
    :};


return_estructura ::= RETURN numerosLiterales:N1 FIN_EXPRESION
    {:
        // Crear el nodo para el retorno
        Nodo returnNode = parser.crearNodo("RETURN");
        returnNode.agregarHijo(parser.crearNodo("return")); // Nodo para el literal "return"

        if (N1 != null) {
            // Agregar el valor al nodo RETURN dependiendo de su tipo
            if (N1 instanceof Nodo) {
                returnNode.agregarHijo((Nodo) N1); // Si es Nodo, lo agrega directamente
            } else {
                returnNode.agregarHijo(parser.crearNodo(N1.toString())); // Si no, lo convierte a String
            }

            // Agregar a la tabla de símbolos
            String valor = N1.toString(); // Convertir cualquier objeto a su representación en String
            Symbol symbol = (Symbol) CUP$parser$stack.peek();
            parser.agregarVariable(symbol.left, symbol.right, "return", valor);
            System.out.println("Valor de retorno ayuda: " + valor);
        } else {
            System.err.println("Error: El valor de retorno es nulo.");
            parser.agregarVariable(0, 0, "return", "undefined");
        }

        // Agregar el nodo RETURN al árbol sintáctico
        parser.getArbol().getRaiz().agregarHijo(returnNode);
        RESULT = returnNode;
    :}
    | RETURN FIN_EXPRESION
    {:
        // Crear el nodo para el retorno sin valor
        Nodo returnNode = parser.crearNodo("RETURN");
        returnNode.agregarHijo(parser.crearNodo("return")); // Nodo para el literal "return"

        // Registrar en la tabla de símbolos como "undefined"
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, "return", "undefined");

        // Agregar el nodo RETURN al árbol sintáctico
        parser.getArbol().getRaiz().agregarHijo(returnNode);
        RESULT = returnNode;
    :};


print ::= PRINT PARENTESISAPERTURA literales:N1 PARENTESISCIERRE FIN_EXPRESION
    {:
        Nodo printNode = parser.crearNodo("PRINT");
        printNode.agregarHijo(parser.crearNodo("print"));
        printNode.agregarHijo(parser.crearNodo("("));
        if (N1 != null) printNode.agregarHijo(N1); // Nodo del literal
        printNode.agregarHijo(parser.crearNodo(")"));
        RESULT = printNode;
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, "print", "narra");
    :}
    | PRINT PARENTESISAPERTURA variable:N1 PARENTESISCIERRE FIN_EXPRESION
    {:
        Nodo printNode = parser.crearNodo("PRINT");
        printNode.agregarHijo(parser.crearNodo("print"));
        printNode.agregarHijo(parser.crearNodo("("));
        if (N1 != null) printNode.agregarHijo(N1); // Nodo de la variable
        printNode.agregarHijo(parser.crearNodo(")"));
        RESULT = printNode;
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, "print", "narra");
    :}
    | PRINT PARENTESISAPERTURA variable:N1
      error
    {:
        System.err.println("Error: No se cerró el print");
        Nodo printNode = parser.crearNodo("PRINT_ERROR");
        printNode.agregarHijo(parser.crearNodo("print"));
        printNode.agregarHijo(parser.crearNodo("("));
        if (N1 != null) printNode.agregarHijo(N1); // Nodo de la variable
        RESULT = printNode;
    :}
    | PRINT
      error
    {:
        System.err.println("Error: Print mal formado");
        Nodo printNode = parser.crearNodo("PRINT_ERROR");
        printNode.agregarHijo(parser.crearNodo("print"));
        RESULT = printNode;
    :}
    | PRINT variable:N1 PARENTESISCIERRE
      error
    {:
        System.err.println("Print mal formado");
        Nodo printNode = parser.crearNodo("PRINT_ERROR");
        printNode.agregarHijo(parser.crearNodo("print"));
        if (N1 != null) printNode.agregarHijo(N1); // Nodo de la variable
        printNode.agregarHijo(parser.crearNodo(")"));
        RESULT = printNode;
    :};

read ::= READ PARENTESISAPERTURA numerosLiterales:N1 PARENTESISCIERRE FIN_EXPRESION
    {:
        Nodo readNode = parser.crearNodo("READ");
        readNode.agregarHijo(parser.crearNodo("read"));
        readNode.agregarHijo(parser.crearNodo("("));
        if (N1 != null) readNode.agregarHijo(N1); // Nodo de los números literales
        readNode.agregarHijo(parser.crearNodo(")"));
        RESULT = readNode;
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, "read", "escucha");
    :}
    | READ PARENTESISAPERTURA variable:N1 PARENTESISCIERRE FIN_EXPRESION
    {:
        Nodo readNode = parser.crearNodo("READ");
        readNode.agregarHijo(parser.crearNodo("read"));
        readNode.agregarHijo(parser.crearNodo("("));
        if (N1 != null) readNode.agregarHijo(N1); // Nodo de la variable
        readNode.agregarHijo(parser.crearNodo(")"));
        RESULT = readNode;
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, "read", "escucha");
    :}
    | READ PARENTESISAPERTURA PARENTESISCIERRE
      error
    {:
        System.err.println("Error: Read mal formado");
        Nodo readNode = parser.crearNodo("READ_ERROR");
        readNode.agregarHijo(parser.crearNodo("read"));
        readNode.agregarHijo(parser.crearNodo("("));
        readNode.agregarHijo(parser.crearNodo(")"));
        RESULT = readNode;
    :};
invocacionFuncion::= variable parametrosInvFuncion FIN_EXPRESION;

parametrosInvFuncion::= PARENTESISAPERTURA PARENTESISCIERRE
                       | PARENTESISAPERTURA parametrosInvFuncionAux PARENTESISCIERRE;

parametrosInvFuncionAux::= literales
                        | variable PARENTESISAPERTURA PARENTESISCIERRE
                        | parametrosInvFuncionAux COMA literales;