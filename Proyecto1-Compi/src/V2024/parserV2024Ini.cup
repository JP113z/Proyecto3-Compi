package ParserLexer;
import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Scanner;
import java.io.File;
import Tree.Arbol;
import Tree.Nodo;
import V2024.Resultado;
import java.util.Map;

action code {:  :};

parser code {:
    BasicLexerCupV lex;

    private int errorCount = 0;

    private int mainCount = 0;

    private Arbol arbol;

    private int bloqueActual = 0;

    private boolean dataSectionGenerated = false;

    private boolean textSectionGenerated = false;

    public String etiquetaTrue;
    public String etiquetaEndIf;
    public String etiquetaEndElse;
    public String etiquetaInicioWhile;
    public String etiquetaEndWhile;
    public String etiquetaInicioFor;
    public String etiquetaEndFor;
    public String iteradorForActual;
    public String tempSwitch;
    public String etiquetaEndSwitch;
    public String etiquetaDefault;
    public int caseNumber = 0;

    StringBuffer codMIPS = new StringBuffer();
    StringBuffer dataSection = new StringBuffer();

    private int maxTemp = 9;          // Máximo índice para registros temporales ($t0 - $t9)
    private int currentTemp = 0;      // Contador actual de registros temporales
    private int currentFloatTemp = 0;
    private int frameSize = 0;        // Tamaño actual del marco de pila
    private Map<String, Integer> variableOffset = new HashMap<>();  // Mapa para offsets fijos de variables en la pila

    // Obtener un registro temporal para operaciones intermedias
    public String newTemp() {
        String temp = "$t" + (currentTemp % (maxTemp + 1));
        currentTemp++;
        return temp;
    }

    // Asignar espacio en la pila para una nueva variable
    public void allocateVariable(String variable) {
        if (variableOffset.containsKey(variable)) {
            System.err.println("Error interno: Variable ya está asignada en la pila.");
            errorCount++;
            return;
        }
        frameSize += 4;  // Incrementar el tamaño del marco
        variableOffset.put(variable, -frameSize);  // Asignar un offset fijo en el marco
        gen("addi $sp, $sp, -4");  // Reservar espacio en la pila
    }

    // Obtener la dirección fija en la pila para una variable
    public String getVariableAddress(String variable) {
        Integer offset = variableOffset.get(variable);
        if (offset == null) {
            System.err.println("Error interno: Variable " + variable + " no encontrada en la pila");
            errorCount++;
            return "0($sp)";  // Dirección por defecto en caso de error
        }
        return offset + "($fp)";
    }

    // Cargar variable de la pila a un registro temporal
    public String loadVariable(String variable) {
        String temp = newTemp();
        gen("lw " + temp + ", " + getVariableAddress(variable));
        return temp;
    }

    public String loadVariableFloat(String variable) {
        String temp = newFloatTemp();
        gen("lwc1 " + temp + ", " + getVariableAddress(variable));
        return temp;
    }

    // Guardar valor de un registro en la pila
    public void storeVariable(String variable, String register) {
        if (register == null || !register.startsWith("$")) {
            System.err.println("Error interno: Registro inválido para la variable '" + variable + "'.");
            errorCount++;
            return;
        }
        gen("sw " + register + ", " + getVariableAddress(variable));
    }

    // Guardar valor de un registro flotante en la pila
    public void storeFloatVariable(String variable, String register) {
        if (register == null || !register.startsWith("$")) {
            System.err.println("Error interno: Registro inválido para la variable '" + variable + "'.");
            errorCount++;
            return;
        }
        gen("swc1 " + register + ", " + getVariableAddress(variable));  // `swc1` para flotantes
    }
        // Obtener un registro temporal flotante para operaciones intermedias
        public String newFloatTemp() {
            if (currentFloatTemp < 32) { // Máximo de registros flotantes es $f0 - $f31
                return "$f" + (currentFloatTemp++ % 32);  // Ciclar dentro de los 32 registros flotantes
            } else {
                // Manejo de flotantes en la pila
                frameSize += 4;
                gen("addi $sp, $sp, -4");  // Reservar espacio en la pila
                return "-" + frameSize + "($fp)";
            }
        }

       public void gen(String instruction) {
              System.out.println("Generando instrucción: " + instruction);
              codMIPS.append(instruction).append("\n");
          }

        public String floatToIEEE754(String floatStr) {
            try {
                float value = Float.parseFloat(floatStr); // Convertir a float
                int intBits = Float.floatToIntBits(value); // Convertir a IEEE 754 (bits enteros)
                return "0x" + Integer.toHexString(intBits).toUpperCase(); // Devolver como hexadecimal
            } catch (NumberFormatException e) {
                System.err.println("Error interno: No se pudo convertir " + floatStr + " a IEEE 754");
                errorCount++;
                return "0x0000";
            }
        }


        public void imprimirCodigoMIPS() {
            StringBuilder codigoCompleto = new StringBuilder();
            if (dataSectionGenerated) {
                codigoCompleto.append(dataSection.toString()).append("\n");
            }
            if (textSectionGenerated) {
                codigoCompleto.append(codMIPS.toString());
            }
            System.out.println("\n\nCÓDIGO MIPS:");
            System.out.println(codigoCompleto.toString());
        }

        public void declararString(String id, String valor) {
            if (!dataSectionGenerated) {
                dataSection.append(".data\n"); // Asegurarse de que la sección .data se genere al inicio
                dataSectionGenerated = true;
            }
            dataSection.append(id + ": .asciiz \"" + valor + "\"\n");}

       public void textSection() {
           if (!textSectionGenerated) {
                 gen(".text");
                 gen(".globl main");
                 gen("main:");
                 gen("j _verano_");
                 textSectionGenerated = true;
                 textSectionGenerated = true;
           }
           if (!dataSectionGenerated) {
                dataSection.append(".data\n"); // Asegurarse de que la sección .data se genere al inicio
                dataSectionGenerated = true;
           }
         }

    public String obtenerValorString(String id) {
        // Buscar el string declarado en .data y devolver su valor
        String data = dataSection.toString();
        for (String line : data.split("\n")) {
            if (line.startsWith(id + ":")) {
                int start = line.indexOf("\"") + 1;
                int end = line.lastIndexOf("\"");
                if (start > 0 && end > start) {
                    return line.substring(start, end);
                }
            }
        }
        return ""; // Retornar vacío si no se encuentra
    }

    public void guardarCodigoMIPS(String archivoSalida) {
        try (FileWriter writer = new FileWriter(archivoSalida)) {
            StringBuilder codigoCompleto = new StringBuilder();
            if (dataSectionGenerated) {
                codigoCompleto.append(dataSection.toString()).append("\n");
            }
            if (textSectionGenerated) {
                codigoCompleto.append(codMIPS.toString());
            }
            // Guardar el contenido del código MIPS generado
            writer.write(codigoCompleto.toString());
            System.out.println("El código MIPS ha sido guardado en el archivo: " + archivoSalida);
        } catch (IOException e) {
            System.err.println("Error interno escribiendo en el archivo: " + e.getMessage());
            errorCount++;
        }
    }

    public String getTipo(ArrayList<String> listaTablasSimbolos, String id, int line, int column) {
        if (listaTablasSimbolos == null) {
            System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                               ": La tabla de símbolos está vacía o no inicializada.");
                               errorCount++;
            return "null";
        }

        String tipo = "null";

        for (String token : listaTablasSimbolos) {
            // Divide el token en columnas usando "|" como delimitador
            String[] partesToken = token.split("\\|");
            if (partesToken.length < 5) { // Verifica que haya al menos 5 columnas
                System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                                   ": Formato inválido en token: " + token);
                                   errorCount++;
                continue;
            }
            String lexema = partesToken[3].trim(); // Columna "Lexema"
            String tipoEncontrado = partesToken[4].trim(); // Columna "Tipo"

            // Compara el lexema con el id que estamos buscando
            if (id.equals(lexema)) {
                tipo = tipoEncontrado;
                break;
            }
        }

        if (tipo.equals("null")) {
            System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                               ": Identificador '" + id + "' no está declarado.");
                               errorCount++;
        }

        return tipo;
    }
    /**
     * Método: getArbol
     * Objetivo: Obtener el arbol.
     * Entradas: Ninguna
     * Salida: El arbol actual.
     */
    public Arbol getArbol() {
        return arbol;
    }
    /**
     * Método: crearNodo
     * Objetivo: Crear un nuevo nodo para el árbol sintáctico con un dato específico.
     * Entradas:
     *   - dato: Cadena de texto que representa el valor asociado al nodo.
     * Salida: Una instancia de la clase Nodo con el dato proporcionado.
     */
    private Nodo crearNodo(String dato) {
        return new Nodo(dato);
    }

    /**
     * Método: syntax_error
     * Objetivo: Manejar los errores sintácticos encontrados durante el análisis sintáctico.
     * Entradas:
     *   - s: Objeto de tipo Symbol que contiene información sobre el error sintáctico, como la posición y el token involucrado.
     * Salida: Ninguna.
     * Restricciones: Se espera que el objeto Symbol contenga información válida de posición y token.
     */
    @Override
    public void syntax_error(Symbol s) {
        errorCount++;
        System.err.println("Error sintáctico en línea " + (s.left + 1) +
                           ", columna " + (s.right + 1) + ". Token inesperado: " + s.value);
                           errorCount++;
    }

    /**
     * Método: hasErrors
     * Objetivo: Verificar si se han registrado errores durante el análisis sintáctico.
     * Entradas: Ninguna.
     * Salida: Booleano que indica si existen errores (true si hay errores, false sino).
     *         Se utiliza en la clase MainJFlexCup para indicar si el archivo puede generarse
     * Restricciones: La variable errorCount debe haber sido correctamente inicializada y actualizada.
     */
    public boolean hasErrors() {
        return errorCount > 0;
    }

    public void verificarMain() {
        if (mainCount == 0) {
            System.err.println("Error semántico: No se declaró ninguna función 'main' (_verano_).");
            errorCount++;
        } else if (mainCount > 1) {
            System.err.println("Error semántico: Se declaró más de una función 'main' (_verano_).");
            errorCount++;
        } else {
            System.out.println("Análisis correcto: Se declaró una única función 'main' (_verano_).");
        }
    }

    @SuppressWarnings("deprecation")
    public parser(BasicLexerCupV lex) {
        this.lex = lex;
        this.symbolFactory = new DefaultSymbolFactory();
        this.currentHash = null;
        this.arbol = new Arbol();
    }

    // Tabla de símbolos
    HashMap<String, ArrayList<String>> listaTablasSimbolos = new HashMap<>();
    String currentHash;

    /**
     * Método: imprimirTablaSimbolos
     * Objetivo: Imprimir todas las tablas de símbolos almacenadas, mostrando el contenido de cada tabla en un formato tabular.
     * Entradas: Ninguna.
     * Salida: Se llama en MainJFlexCup para imprimir en la consola el contenido de las tablas de símbolos.
     * Detalles:
     *   - Cada tabla está asociada a una clave (nombre de la función o el main).
     *   - Se imprime una tabla separada para cada clave con columnas que incluyen línea, columna, lexema y tipo.
     * Restricciones: Se espera que la estructura `listaTablasSimbolos` esté correctamente inicializada y contenga las claves y los valores correspondientes.
     */
    public void imprimirTablaSimbolos() {
        for (String key : listaTablasSimbolos.keySet()) {
            System.out.println("\nTabla de símbolos: " + key);
            System.out.println("+--------+---------+----------------------+------------+-----------+");
            System.out.println("| Línea  | Columna | Lexema              | Tipo       | Bloque    |");
            System.out.println("+--------+---------+----------------------+------------+-----------+");
            for (String simbolo : listaTablasSimbolos.get(key)) {
                System.out.println(simbolo);
            }
            System.out.println("+--------+---------+----------------------+------------+-----------+\n");
        }
    }

    /**
     * Método: agregarTablaSimbolos
     * Objetivo: Crear una nueva tabla de símbolos asociada a una función o al main y agregarla al mapa de tablas de símbolos.
     * Entradas:
     *   - tipoTabla: Tipo de la tabla ("función" o "main").
     *   - nombre: Nombre asociado a la tabla (El nombre de la función o "_verano_" que es el token asociado a main).
     * Salida: Ninguna.
     * Detalles:
     *   - Se inicializa una nueva tabla de símbolos como una lista de cadenas.
     *   - Se guarda en el mapa `listaTablasSimbolos` con el nombre como clave.
     *   - `currentHash` se actualiza para indicar que la tabla activa es la recién creada.
     * Restricciones:
     *   - El nombre de la tabla debe ser único para evitar sobrescribir tablas existentes.
     */
    public void agregarTablaSimbolos(String tipoTabla, String nombre) {
        System.out.println("/+++Nueva tabla símbolos función o main+++/ " + nombre);
        ArrayList<String> nuevaTabla = new ArrayList<>();
        currentHash = nombre;
        bloqueActual = 1;
        listaTablasSimbolos.put(currentHash, nuevaTabla);
    }

    /**
     * Método: agregarVariable
     * Objetivo: Agregar una nueva variable a la tabla de símbolos activa, registrando su línea, columna, lexema y tipo.
     * Entradas:
     *   - linea: Número de línea donde se encuentra la variable.
     *   - columna: Número de columna donde se encuentra la variable.
     *   - lexema: Nombre o representación textual de la variable.
     *   - tipo: Tipo de la variable
     * Salida: Ninguna.
     * Detalles:
     *   - Verifica que haya una tabla de símbolos activa (`currentHash`) y que esta exista en el mapa `listaTablasSimbolos`.
     *   - Si no hay tabla activa o no existe, se imprime un mensaje de error.
     *   - Si todo es válido, formatea la información de la variable en una tabla y la agrega a la tabla de símbolos activa.
     * Restricciones:
     *   - Debe existir una tabla de símbolos activa antes de llamar a este método.
     *   - La línea, columna, lexema y tipo deben ser datos válidos y coherentes con el análisis.
     */
    public void agregarVariable(int linea, int columna, String lexema, String tipo) {
        System.out.println("PARSER: identificador (agregar o verificar) " + lexema);
        if (currentHash == null) {
            System.err.println("Error interno: No hay una tabla de símbolos activa");
            errorCount++;
            return;
        }
        ArrayList<String> tabla = listaTablasSimbolos.get(currentHash);
        if (tabla == null) {
            System.err.println("Error interno: La tabla de símbolos '" + currentHash + "' no existe");
            errorCount++;
            return;
        }
        String entrada = String.format("| %-6d | %-7d | %-20s | %-10s | Bloque %-3d |",
                linea + 1, columna + 1, lexema, tipo, bloqueActual);
        tabla.add(entrada);
    }
:}

init with {: :};

scan with {: return lex.next_token(); :};

/* Terminales */
terminal MAIN, INTEGER, STRING, FLOAT, BOOL, CHAR;
terminal L_INTEGER, L_FLOAT, L_STRING, L_CHAR;
terminal COMA, IDENTIFICADOR, corcheteIzquierdo, corcheteDerecho, CORCHETEAPERTURA, CORCHETECIERRE, TRUE, FALSE, ASIGNA, PARENTESISAPERTURA, PARENTESISCIERRE,
INCREMENTO, DECREMENTO, NEGATIVO, MENOR, MENOR_IGUAL, MAYOR, MAYOR_IGUAL, IGUAL, DIFERENTE, CONJUNCION, DISYUNCION, NEGACION, FIN_EXPRESION, IF, ELSE, WHILE, FOR, SWITCH, CASE, DEFAULT, BREAK, RETURN,
DOS_PUNTOS, PRINT, READ,SUMA, RESTA, DIVISION, MULTIPLICACION, MODULO, POTENCIA;

/* No terminales */
non terminal programa, declaracion_main, bloque, lista_sentencias, sentencia, declaracion, asignacion, expresion, tipo, literal, operador_binario,
operador_unario, operador_logico, operador_relacional, estructura_control, if_stmt, while_stmt, for_stmt, switch_stmt,  case_list, case_stmt, default_stmt,
lista_expresiones,  arreglo, acceso_arreglo, llamada_funcion, declaracion_funcion, parametros, lista_parametros, return_stmt, funcion, lista_funciones, declaracionArreglo, parametrosArreglos,
parametrosArreglosAux, bloqueEstructura, cabecera_main, cabecera_funcion, contenido_estructura_control, llamada_funcion_aux, print, read, return_estructura_stmt, if_stmt_aux, if_stmt_cabecera, if_else_stmt,
for_stmt_cabecera, for_stmt_aux, for_camino, switch_cabecera, switch_cierre;

/* Precedencias */
precedence right error;
precedence left FIN_EXPRESION;
precedence left DISYUNCION;
precedence left CONJUNCION;
precedence right NEGACION;
precedence nonassoc MENOR, MENOR_IGUAL, MAYOR, MAYOR_IGUAL, IGUAL, DIFERENTE;
precedence left SUMA, RESTA;
precedence left MULTIPLICACION, DIVISION, MODULO;
precedence right POTENCIA;
precedence right NEGATIVO;
precedence right INCREMENTO, DECREMENTO;

/* Reglas de producción con manejo de errores */
start with programa;

programa ::= lista_funciones
          | error lista_funciones
          | lista_funciones error;

lista_funciones ::= lista_funciones:lf funcion:f {: :}
                 | funcion:f {: :}
                 | lista_funciones error funcion;

funcion ::= cabecera_funcion:df {: :}
          | cabecera_main:dm {: :}
          | error bloque;

declaracion_main ::= PARENTESISAPERTURA PARENTESISCIERRE bloque
                  |  PARENTESISAPERTURA error PARENTESISCIERRE bloque
                  ;

cabecera_main ::= tipo:t MAIN
                {:
                    Symbol symbol = (Symbol) CUP$parser$stack.peek();
                    parser.agregarTablaSimbolos("main", "_verano_");
                    parser.agregarVariable(symbol.left, symbol.right, "_verano_", ((Resultado) t).tipo);

                    // Incrementar el contador de main
                    parser.mainCount++;
                    textSection();
                    // Generar la etiqueta del main
                    parser.gen("\n# Inicio del main (_verano_)\n_verano_:");

                    // Guardar el valor de retorno y marco de pila
                    parser.gen("addi $sp, $sp, -8");  // Reservar espacio para $ra y $fp
                    parser.gen("sw $ra, 4($sp)");    // Guardar $ra en la pila
                    parser.gen("sw $fp, 0($sp)");    // Guardar $fp en la pila
                    parser.gen("move $fp, $sp");    // Actualizar el marco de pila
                :} declaracion_main
                {:
                    // Restaurar registros y finalizar el programa
                    parser.gen("\n# Fin del main (_verano_)");
                    parser.gen("move $sp, $fp");
                    parser.gen("lw $ra, 4($sp)");  // Restaurar $ra
                    parser.gen("lw $fp, 0($sp)");  // Restaurar $fp
                    parser.gen("addi $sp, $sp, 8"); // Restaurar el espacio en la pila
                    parser.gen("li $v0, 10");       // Syscall para terminar el programa
                    parser.gen("syscall");
                :}
                | error MAIN PARENTESISAPERTURA PARENTESISCIERRE bloque;

declaracion_funcion ::= PARENTESISAPERTURA parametros:p PARENTESISCIERRE bloque:b
                     | PARENTESISAPERTURA PARENTESISCIERRE bloque:b
                     | PARENTESISAPERTURA error PARENTESISCIERRE bloque;


cabecera_funcion ::= tipo:t IDENTIFICADOR:id
                   {:
                       Symbol symbol = (Symbol) CUP$parser$stack.peek();
                       parser.agregarTablaSimbolos("funcion", id.toString());
                       parser.agregarVariable(symbol.left, symbol.right, id.toString(), ((Resultado) t).tipo);
                       textSection();
                       // Generar la etiqueta de la función
                       parser.gen("\n# Inicio de la función " + id.toString() + "\n" + id.toString() + ":");

                       // Guardar el valor de retorno y marco de pila
                       parser.gen("addi $sp, $sp, -8");  // Reservar espacio para $ra y $fp
                       parser.gen("sw $ra, 4($sp)");    // Guardar $ra en la pila
                       parser.gen("sw $fp, 0($sp)");    // Guardar $fp en la pila
                       parser.gen("move $fp, $sp");    // Actualizar el marco de pila
                   :} declaracion_funcion
                   {:
                       // Restaurar registros y salir de la función
                       parser.gen("\n# Fin de la función " + id.toString());
                       parser.gen("move $sp, $fp");
                       parser.gen("lw $ra, 4($sp)");  // Restaurar $ra
                       parser.gen("lw $fp, 0($sp)");  // Restaurar $fp
                       parser.gen("addi $sp, $sp, 8"); // Restaurar el espacio en la pila
                       parser.gen("jr $ra");          // Regresar al llamador
                   :}
                   | error IDENTIFICADOR PARENTESISAPERTURA parametros PARENTESISCIERRE bloque;

bloque ::= corcheteIzquierdo
        {:
            parser.bloqueActual++;
        :}
        lista_sentencias return_stmt FIN_EXPRESION corcheteDerecho
        | corcheteIzquierdo
        {:
            parser.bloqueActual++;
        :}
        return_stmt FIN_EXPRESION corcheteDerecho
        | corcheteIzquierdo error corcheteDerecho;

bloqueEstructura ::= corcheteIzquierdo
                    {:
                        parser.bloqueActual++;
                    :}
                    contenido_estructura_control
                  | corcheteIzquierdo error corcheteDerecho error;

contenido_estructura_control ::= corcheteDerecho
                             | lista_sentencias corcheteDerecho
                             | lista_sentencias return_estructura_stmt FIN_EXPRESION corcheteDerecho
                             | return_estructura_stmt FIN_EXPRESION corcheteDerecho;

lista_sentencias ::= lista_sentencias sentencia
                  | sentencia
                  | error {: System.err.println("Error en una sentencia."); errorCount++; :};

sentencia ::= declaracion FIN_EXPRESION
            | asignacion FIN_EXPRESION
            | estructura_control
            | expresion FIN_EXPRESION
            | BREAK FIN_EXPRESION
            | print FIN_EXPRESION
            | read FIN_EXPRESION
            | error FIN_EXPRESION
            ;
print ::= PRINT PARENTESISAPERTURA expresion:e PARENTESISCIERRE
        {:
            Symbol symbol = (Symbol) CUP$parser$stack.elementAt(CUP$parser$stack.size() - 2);
            int line = symbol.left;
            int column = symbol.right;

            String tipo = (e instanceof Resultado)
                ? ((Resultado) e).tipo
                : parser.getTipo(parser.listaTablasSimbolos.get(parser.currentHash), e.toString(), line, column);
            String temp = (e instanceof Resultado) ? ((Resultado) e).temp : null;
            if ((!tipo.equals("rodolfo") && !tipo.equals("bromista")) && !tipo.equals("cupido") && !tipo.equals("cometa")) {
                System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                                   ": Solo puede usar el print con enteros, flotantes, cadenas y caracteres. Valor recibido: '" + tipo + "'.");
                                   errorCount++;
            } else {
                if (temp != null) {
                    if (parser.variableOffset.containsKey(temp)) {
                        if (tipo.equals("bromista")) {
                            temp = parser.loadVariableFloat(temp); // Cargar flotante
                        } else {
                            temp = parser.loadVariable(temp); // Cargar variable desde la pila
                        }
                    }

                    if (tipo.equals("cometa")) {
                        parser.gen("la $a0, " + temp);
                        parser.gen("li $v0, 4");
                    } else if (tipo.equals("bromista")) {
                        parser.gen("li $v0, 2");
                        parser.gen("mov.s $f12, " + temp);
                    } else {
                        parser.gen("move $a0, " + temp);

                        switch (tipo) {
                            case "rodolfo":
                                parser.gen("li $v0, 1");
                                break;
                            case "cupido":
                                parser.gen("li $v0, 11");
                                break;
                        }
                    }
                    parser.gen("syscall");
                    parser.gen("li $a0, 10");  // Código ASCII de '\n'
                    parser.gen("li $v0, 11");
                    parser.gen("syscall");
                }
            }

            RESULT = new Resultado(tipo, temp);
        :};

read ::= READ PARENTESISAPERTURA IDENTIFICADOR:id PARENTESISCIERRE
        {:
            Symbol symbol = (Symbol) CUP$parser$stack.elementAt(CUP$parser$stack.size() - 2);
            int line = symbol.left;
            int column = symbol.right;

            String tipo = parser.getTipo(parser.listaTablasSimbolos.get(parser.currentHash), id.toString(), line, column);

            if ((!tipo.equals("rodolfo") && !tipo.equals("bromista"))) {
                System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                                   ": El read solo lee enteros o flotantes.");
                                   errorCount++;
            } else {
                String tempReg = parser.newTemp();

                switch (tipo) {
                    case "rodolfo":
                        parser.gen("li $v0, 5");
                        parser.gen("syscall");
                        parser.gen("move " + tempReg + ", $v0");
                        break;
                    case "bromista":
                        parser.gen("li $v0, 6");
                        parser.gen("syscall");
                        parser.gen("mfc1 " + tempReg + ", $f0");
                        break;
                }

                // Guardar el valor leído en la pila
                parser.storeVariable(id.toString(), tempReg);
                RESULT = new Resultado(tipo, id.toString());
            }
        :};

declaracion ::= tipo:t IDENTIFICADOR:id
            {:
                Symbol symbol = (Symbol) CUP$parser$stack.peek();
                parser.agregarVariable(symbol.left, symbol.right, id.toString(), ((Resultado) t).tipo);

                String tipoVar = ((Resultado) t).tipo;

                if (tipoVar.equals("cometa")) {
                    parser.declararString(id.toString(), " ");
                } else {
                    // Solo asignamos espacio si la variable no ha sido declarada antes
                    if (!parser.variableOffset.containsKey(id.toString())) {
                        parser.allocateVariable(id.toString());
                    }

                    // Usar un temporal para inicializar el valor en la pila
                    String temp = parser.newTemp();
                    parser.gen("li " + temp + ", 0");  // Inicializar en 0
                    parser.storeVariable(id.toString(), temp);  // Guardar en la pila
                }
                RESULT = new Resultado(tipoVar, id.toString());
            :}
          | tipo:t IDENTIFICADOR:id ASIGNA expresion:e
        {:
            Symbol symbol = (Symbol) CUP$parser$stack.peek();
            parser.agregarVariable(symbol.left, symbol.right, id.toString(), ((Resultado) t).tipo);
            int line = symbol.left;
            int column = symbol.right;

            String tipoVar = ((Resultado) t).tipo;
            String tempExpresion = (e == null) ? null : ((Resultado) e).temp;

            if (tipoVar.equals("cometa")) {
                // Usar el identificador del string directamente
                String idString = ((Resultado) e).temp;

                // Declarar el string (si aún no existe) en .data
                parser.declararString(id.toString(), parser.obtenerValorString(idString));

                // Referenciarlo en .text
                parser.gen("la $a0, " + id.toString()); // Cargar la dirección del string
                parser.gen("li $v0, 4"); // Syscall para imprimir cadenas
                //parser.gen("syscall");
            } else if (tipoVar.equals("bromista")) {
                // Si la variable no ha sido asignada, reservar espacio en la pila
                if (!parser.variableOffset.containsKey(id.toString())) {
                    parser.allocateVariable(id.toString());
                }

                // Validar que el temporal correcto se almacene
                if (tempExpresion != null && tempExpresion.startsWith("$")) {
                    parser.storeFloatVariable(id.toString(), tempExpresion); // Usar método de flotantes
                } else {
                    System.err.println("Error interno: Registro temporal inválido para la asignación de '" + id + "'.");
                    errorCount++;
                }
            } else {
                // Si la variable no ha sido asignada, reservar espacio en la pila
                if (!parser.variableOffset.containsKey(id.toString())) {
                    parser.allocateVariable(id.toString());
                }

                // Validar que el temporal correcto se almacene
                if (tempExpresion != null && tempExpresion.startsWith("$")) {
                    parser.storeVariable(id.toString(), tempExpresion);
                } else {
                    System.err.println("Error interno: Registro temporal inválido para la asignación de '" + id + "'.");
                    errorCount++;
                }
            }
            RESULT = new Resultado(tipoVar, id.toString());
        :}
        | arreglo
        | tipo error;

tipo ::= INTEGER{: RESULT = new Resultado("rodolfo", null); :}
    | STRING{: RESULT = new Resultado("cometa", null); :}
    | CHAR{: RESULT = new Resultado("cupido", null); :}
    | FLOAT{: RESULT = new Resultado("bromista", null); :}
    | BOOL{: RESULT = new Resultado("trueno", null); :};

asignacion ::= IDENTIFICADOR:id ASIGNA expresion:exp
            {:
                Symbol symbol = (Symbol) CUP$parser$stack.elementAt(CUP$parser$stack.size() - 3);
                String tipoIdentificador = parser.getTipo(
                parser.listaTablasSimbolos.get(parser.currentHash), id.toString(), symbol.left, symbol.right);
                int line = symbol.left;
                int column = symbol.right;
                String temp;

                if (tipoIdentificador != null) {
                        if (exp == null) {
                            System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                                               ": Se ha intentado asignar un valor nulo a la variable '" + id + "'.");
                                               errorCount++;
                            temp = null;
                        } else {
                             temp = ((Resultado) exp).temp;
                        }
                    if (tipoIdentificador.equals("cometa")) {
                        // Si es un string, almacenar directamente en .data
                        parser.declararString(id.toString(), parser.obtenerValorString(temp));
                    } else if (parser.variableOffset.containsKey(id.toString())) {
                        // Si es una variable en la pila, almacenarla
                        if (temp != null && temp.startsWith("$")) {
                            parser.storeVariable(id.toString(), temp);
                        } else {
                            System.err.println("Error interno: Registro temporal inválido para la asignación de '" + id + "'.");
                            errorCount++;
                        }
                    } else {
                        System.err.println("Error interno: Variable '" + id + "' no tiene espacio reservado en la pila.");
                        errorCount++;
                    }
                }
                RESULT = new Resultado(tipoIdentificador, id.toString());
            :}
            | IDENTIFICADOR ASIGNA error
            | error;

expresion ::= literal:e {: RESULT = e; :}
            | IDENTIFICADOR:e
            {:
                Symbol symbol = (Symbol) CUP$parser$stack.peek();
                String tipo = parser.getTipo(parser.listaTablasSimbolos.get(parser.currentHash),
                                               e.toString(), symbol.left, symbol.right);
                int line = symbol.left;
                int column = symbol.right;

                 if (tipo != null) {
                     if (tipo.equals("cometa")) {
                         System.out.println("[DEBUG] Cargando string desde .data");
                         String temp = e.toString(); // La variable es una etiqueta en .data
                         RESULT = new Resultado(tipo, temp);
                     } else if (parser.variableOffset.containsKey(e.toString())) {
                          System.out.println("[DEBUG] Variable '" + e + "' encontrada en la pila.");

                          String temp;
                          if (tipo.equals("bromista")) {
                                System.out.println("[DEBUG] Cargando flotante con loadVariableFloat()");
                                temp = parser.loadVariableFloat(e.toString()); // Cargar flotante correctamente
                          } else {
                                System.out.println("[DEBUG] Cargando entero o carácter con loadVariable()");
                                temp = parser.loadVariable(e.toString()); // Cargar variable estándar
                           }
                            RESULT = new Resultado(tipo, temp);
                    } else {
                        System.err.println("Error interno: Variable '" + e + "' no tiene espacio en la pila.");
                        errorCount++;
                        RESULT = new Resultado("error", null);
                    }
                } else {
                    System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                                       ": Variable '" + e + "' no ha sido declarada.");
                                       errorCount++;
                    RESULT = new Resultado("error", null);
                }
            :}
         | llamada_funcion:f {: RESULT = f; :}
         | expresion:e1 operador_unario:op
            {:
                // Obtener el símbolo correspondiente a `e1` para extraer línea y columna
                Symbol symbol = (Symbol) CUP$parser$stack.elementAt(CUP$parser$stack.size() - 2);
                int line = symbol.left;
                int column = symbol.right;

                // Obtener el tipo y el temporal de la expresión
                Resultado resultadoE1 = (Resultado) e1;
                String tipo = resultadoE1.tipo;
                String tempE1 = resultadoE1.temp;

                // **Acceder al tipo de operador correctamente**
                String operador = ((Resultado) op).tipo.trim();

                // **Flag para indicar si hay error**
                boolean error = false;

                // Validar tipos para operadores unarios
                if (operador.equals("quien") || operador.equals("grinch")) {
                    if (!tipo.equals("rodolfo")) {
                        System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                                           ": Incremento/Decremento solo aplica a enteros (rodolfo).");
                                           errorCount++;
                        error = true;
                    }
                } else if (operador.equals("-") && !tipo.equals("rodolfo") && !tipo.equals("bromista")) {
                    System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                                       ": Negación solo aplica a enteros o flotantes.");
                                       errorCount++;
                    error = true;
                }

                // Si hubo error, asignamos un resultado de error y no ejecutamos más código
                if (error) {
                    RESULT = new Resultado("error", null);
                } else {
                    boolean esFlotante = tipo.equals("bromista");
                    String tempResultado = esFlotante ? parser.newFloatTemp() : parser.newTemp();

                    if (esFlotante) {
                        switch (operador) {
                            case "-": // Negación de flotantes
                                parser.gen("neg.s " + tempResultado + ", " + tempE1);
                                break;
                            default:
                                System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                                                   ": Operación unaria " + operador + " flotante no soportada.");
                                                   errorCount++;
                        }
                    } else {
                        switch (operador) {
                            case "-": // Negación de enteros
                                parser.gen("neg " + tempResultado + ", " + tempE1);
                                break;
                            case "quien": // Incremento para enteros
                                parser.gen("addi " + tempResultado + ", " + tempE1 + ", 1");
                                break;
                            case "grinch": // Decremento para enteros
                                parser.gen("addi " + tempResultado + ", " + tempE1 + ", -1");
                                break;
                            default:
                                System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                                                                                   ": Operación unaria " + operador + " no soportada.");
                                                                                   errorCount++;
                        }
                    }

                    // Solo asignar resultado si no hubo errores
                    RESULT = new Resultado(tipo, tempResultado);
                }
            :}
          | expresion:e1 operador_binario:op expresion:e2
          {:
                // Obtener los símbolos correspondientes a `e1` y `e2` para extraer línea y columna
                Symbol symbol1 = (Symbol) CUP$parser$stack.elementAt(CUP$parser$stack.size() - 3);
                Symbol symbol2 = (Symbol) CUP$parser$stack.elementAt(CUP$parser$stack.size() - 1);

                int line1 = symbol1.left;
                int column1 = symbol1.right;
                int line2 = symbol2.left;
                int column2 = symbol2.right;

                // Acceder a los tipos de los operandos desde los objetos Resultado
                if (e1 == null || e2 == null) {
                    System.err.println("Error semántico en línea " + (line1 + 1) + ", columna " + (column1 + 1) +
                                       ": Uno o ambos operandos de la operación binaria son nulos.");
                                       errorCount++;
                    RESULT = new Resultado("error", null);
                } else {

                    String tipo1 = ((Resultado) e1).tipo;
                    String tipo2 = ((Resultado) e2).tipo;

                    // Validar los tipos de los operandos
                    if ((!tipo1.equals("rodolfo") && !tipo1.equals("bromista")) ||
                              (!tipo2.equals("rodolfo") && !tipo2.equals("bromista"))) {
                               System.err.println("Error semántico en línea " + (line1 + 1) + ", columna " + (column1 + 1) +
                                                                  ": Operandos deben ser enteros (rodolfo) o flotantes (bromista).");
                                                                  errorCount++;
                    } else if (!tipo1.equals(tipo2)) {
                               System.err.println("Error semántico en línea " + (line1 + 1) + ", columna " + (column1 + 1) +
                                                                  ": Tipos incompatibles entre los operandos. Operando 1: " + tipo1 + ", Operando 2: " + tipo2);
                                                                  errorCount++;
                    }else {
                              boolean esFlotante = tipo1.equals("bromista"); // Determinar si es flotante
                              String tipoResultado = esFlotante ? "bromista" : "rodolfo";

                               String temp1 = ((Resultado) e1).temp;
                               String temp2 = ((Resultado) e2).temp;
                               String tempResultado;

                    if (esFlotante) {
                        String tempResultadoF = parser.newFloatTemp();  // Nuevo temporal flotante

                        switch (((Resultado) op).tipo) {
                            case "navidad": // Suma
                                parser.gen("add.s " + tempResultadoF + ", " + temp1 + ", " + temp2);
                                break;
                            case "intercambio": // Resta
                                parser.gen("sub.s " + tempResultadoF + ", " + temp1 + ", " + temp2);
                                break;
                            case "nochebuena": // Multiplicación
                                parser.gen("mul.s " + tempResultadoF + ", " + temp1 + ", " + temp2);
                                break;
                            case "reyes": // División
                                parser.gen("div.s " + tempResultadoF + ", " + temp1 + ", " + temp2);
                                break;
                            case "magos": // MODULO flotante: a % b = a - (trunc(a / b) * b)
                                 String tempDiv = parser.newFloatTemp();
                                 String tempTrunc = parser.newFloatTemp();
                                 String tempMul = parser.newFloatTemp();   // Almacena (a / b) * b
                                 parser.gen("div.s " + tempDiv + ", " + temp1 + ", " + temp2);  //a / b
                                 parser.gen("floor.w.s " + tempTrunc + ", " + tempDiv);
                                 parser.gen("cvt.s.w " + tempTrunc + ", " + tempTrunc);
                                 parser.gen("mul.s " + tempMul + ", " + tempTrunc + ", " + temp2);
                                 parser.gen("sub.s " + tempResultadoF + ", " + temp1 + ", " + tempMul);
                                 break;
                             case "adviento": // Potencia flotante: a^b (solo para exponentes enteros positivos es decir .0)
                                 String tempCounter = parser.newFloatTemp();
                                 String tempOne = parser.newFloatTemp();
                                 String tempMinusOne = parser.newFloatTemp();
                                 String labelPowLoop = "pow_loop_" + parser.currentTemp++;
                                 String labelPowEnd = "pow_end_" + parser.currentTemp++;
                                 parser.gen("li.s " + tempResultadoF + ", 1.0");
                                 parser.gen("li.s " + tempOne + ", 0.0");
                                 parser.gen("c.eq.s " + temp2 + ", " + tempOne);
                                 parser.gen("bc1t " + labelPowEnd);
                                 parser.gen("mov.s " + tempCounter + ", " + temp2);
                                 parser.gen("li.s " + tempMinusOne + ", 1.0");
                                  // Bucle de multiplicación: resultado *= base mientras b > 0
                                  parser.gen(labelPowLoop + ":");
                                  parser.gen("mul.s " + tempResultadoF + ", " + tempResultadoF + ", " + temp1);
                                  parser.gen("sub.s " + tempCounter + ", " + tempCounter + ", " + tempMinusOne); // Decrementar exponente
                                  parser.gen("c.le.s " + tempCounter + ", " + tempOne); // Verificar si exponente llegó a 0
                                  parser.gen("bc1t " + labelPowEnd); // Salir si exponente <= 0
                                  parser.gen("b " + labelPowLoop); // Volver a multiplicar
                                  parser.gen(labelPowEnd + ":");
                                  break;
                            default:
                                System.err.println("Error: Operación flotante no soportada.");
                                errorCount++;
                        }
                        // **Manejar almacenamiento en la pila**
                        if (!tempResultadoF.startsWith("$")) {
                            // Si no es un registro flotante válido, usar la pila
                            parser.storeVariable(tempResultadoF, tempResultadoF);
                        }

                        tempResultado = tempResultadoF;
                    } else {
                        tempResultado = parser.newTemp();  // Usar registros $tX para enteros
                        switch (((Resultado) op).tipo) {
                            case "navidad":
                                parser.gen("add " + tempResultado + ", " + temp1 + ", " + temp2);
                                break;
                            case "intercambio":
                                parser.gen("sub " + tempResultado + ", " + temp1 + ", " + temp2);
                                break;
                            case "nochebuena":
                                parser.gen("mul " + tempResultado + ", " + temp1 + ", " + temp2);
                                break;
                            case "reyes":
                                parser.gen("div " + temp1 + ", " + temp2);
                                parser.gen("mflo " + tempResultado);
                                break;
                            case "magos":
                                parser.gen("div " + temp1 + ", " + temp2);
                                parser.gen("mfhi " + tempResultado);
                                break;
                             case "adviento": // POTENCIA: a^b
                                 String tempCounter = parser.newTemp();  // Contador de lasiteraciones (b)
                                 String tempOne = parser.newTemp();
                                 parser.gen("li " + tempOne + ", 1");
                                 parser.gen("move " + tempResultado + ", " + tempOne); // Inicializar resultado en 1
                                 String labelPowEnd = "pow_end_" + parser.currentTemp++;
                                 parser.gen("beqz " + temp2 + ", " + labelPowEnd);
                                 // Bucle de multiplicación: resultado *= base
                                 String labelPowLoop = "pow_loop_" + parser.currentTemp++;
                                 parser.gen("move " + tempCounter + ", " + temp2);
                                 parser.gen(labelPowLoop + ":");
                                 parser.gen("mul " + tempResultado + ", " + tempResultado + ", " + temp1);
                                 parser.gen("addi " + tempCounter + ", " + tempCounter + ", -1"); // Decrementar exponente
                                 parser.gen("bgtz " + tempCounter + ", " + labelPowLoop); // Repetir si exponente es mayor a 0
                                 parser.gen(labelPowEnd + ":");  // Etiqueta de fin
                                 parser.gen("move " + tempResultado + ", " + tempResultado);
                                 break;
                            default:
                                System.err.println("Error semántico en línea " + (line1 + 1) + ", columna " + (column1 + 1) +
                                                   ": Operación flotante no soportada.");
                                                   errorCount++;

                        }
                    }
                        // Asignar el resultado con el tipo y el temporal generado
                        RESULT = new Resultado(tipoResultado, tempResultado);
                    }
                }
            :}
           | expresion:e1 operador_relacional:op expresion:e2
                 {:
                    // Obtener los símbolos correspondientes a `e1` y `e2` para extraer línea y columna
                    Symbol symbol1 = (Symbol) CUP$parser$stack.elementAt(CUP$parser$stack.size() - 3);
                    Symbol symbol2 = (Symbol) CUP$parser$stack.elementAt(CUP$parser$stack.size() - 1);
                    int line1 = symbol1.left;
                    int column1 = symbol1.right;
                    int line2 = symbol2.left;
                    int column2 = symbol2.right;
                    String operador = ((Resultado) op).tipo;
                    // Obtener los tipos desde los objetos Resultado
                    if (e1 == null) {
                           e1 = new Resultado("null", null);
                    }
                    if (e2 == null) {
                            e2 = new Resultado("null", null);
                     }
                    String tipo1 = ((Resultado) e1).tipo;
                    String tipo2 = ((Resultado) e2).tipo;

                    // Validar los tipos de los operandos
                    if (op.toString().equals("mary") || op.toString().equals("openslae")) {
                                // Para `mary` y `openslae`, los tipos pueden ser enteros, flotantes o booleanos
                                if ((!tipo1.equals("rodolfo") && !tipo1.equals("bromista") && !tipo1.equals("trueno")) ||
                                    (!tipo2.equals("rodolfo") && !tipo2.equals("bromista") && !tipo2.equals("trueno"))) {
                                    System.err.println("Error semántico en línea " + (line1 + 1) + ", columna " + (column1 + 1) +
                                                       ": Operadores '" + operador + "' solo admiten enteros (rodolfo), flotantes (bromista) o booleanos (trueno).");
                                                       errorCount++;
                                } else if (!tipo1.equals(tipo2)) {
                                    System.err.println("Error semántico en línea " + (line1 + 1) + ", columna " + (column1 + 1) +
                                                       ": Tipos incompatibles para operador '" + operador + "'. Operando 1: " + tipo1 + ", Operando 2: " + tipo2);
                                                       errorCount++;
                                } else {
                                // Asignar el tipo resultante para comparaciones relacionales
                                String temp1 = ((Resultado) e1).temp;
                                String temp2 = ((Resultado) e2).temp;
                                String tempResultado = parser.newTemp();

                                // Generación de código MIPS para la comparación
                                switch (operador) {
                                    case "mary": // Igualdad
                                        parser.gen("seq " + tempResultado + ", " + temp1 + ", " + temp2);
                                        break;
                                    case "openslae": // Diferente
                                        parser.gen("sne " + tempResultado + ", " + temp1 + ", " + temp2);
                                    default:
                                        System.err.println("Error semántico en línea " + (line1 + 1) + ", columna " + (column1 + 1) +
                                                           ": Operador relacional no soportado.");
                                                           errorCount++;

                                }
                                // Asignar el resultado con el tipo booleano (trueno) y el temporal generado
                                RESULT = new Resultado("trueno", tempResultado);
                                }
                            } else {
                                          // Identificar si la comparación es entre flotantes o enteros
                                          boolean esFlotante = tipo1.equals("bromista");

                                          // Obtener los temporales de los operandos
                                          String temp1 = ((Resultado) e1).temp;
                                          String temp2 = ((Resultado) e2).temp;
                                          String tempResultado = parser.newTemp(); // Para almacenar el resultado booleano (1 o 0)

                              if (esFlotante) {
                                  String tempResultadoF = parser.newFloatTemp(); // Crear un nuevo registro flotante
                                  String labelTrue = "label_true_";
                                  String labelEnd = "label_end_";
                                  switch (operador) {
                                      case "snowball": // Menor que
                                          parser.gen("c.lt.s " + temp1 + ", " + temp2);
                                          break;
                                      case "evergreen": // Menor o igual
                                          parser.gen("c.le.s " + temp1 + ", " + temp2);
                                          break;
                                      case "minstix": // Mayor que
                                          parser.gen("c.lt.s " + temp2 + ", " + temp1);
                                          break;
                                      case "upatree": // Mayor o igual
                                          parser.gen("c.le.s " + temp2 + ", " + temp1);
                                          break;
                                      case "mary": // Igualdad
                                          parser.gen("c.eq.s " + temp1 + ", " + temp2);
                                          break;
                                      case "openslae": // Diferente
                                          parser.gen("c.eq.s " + temp1 + ", " + temp2);
                                          parser.gen("bc1t " + labelTrue);
                                          parser.gen("li.s $f0, 1.0"); // Son diferentes, asignar 1.0
                                          parser.gen("mov.s " + tempResultadoF + ", $f0");
                                          parser.gen("b " + labelEnd);
                                          parser.gen(labelTrue + ":");
                                          parser.gen("li.s $f0, 0.0"); // Son iguales, asignar 0.0
                                          parser.gen("mov.s " + tempResultadoF + ", $f0");
                                          parser.gen(labelEnd + ":");
                                          break;
                                      default:
                                          System.err.println("Error semántico en línea " + (line1 + 1) + ", columna " + (column1 + 1) +
                                                             ": Operador relacional no soportado.");
                                                             errorCount++;
                                  }
                                  if (!operador.equals("openslae")) {
                                      parser.gen("li.s $f0, 0.0"); // Inicializar en 0.0
                                      parser.gen("mov.s " + tempResultadoF + ", $f0");
                                      parser.gen("bc1f " + labelTrue); // Si la comparación es falsa, saltar
                                      parser.gen("li.s $f0, 1.0"); // Si es verdadera, asignar 1.0
                                      parser.gen("mov.s " + tempResultadoF + ", $f0");
                                      parser.gen(labelTrue + ":");
                                  }
                                  tempResultado = tempResultadoF;
                              }
                         else {
                              // Generación de código MIPS para comparaciones de enteros
                             switch (operador) {
                             case "snowball": // Menor que
                                          parser.gen("slt " + tempResultado + ", " + temp1 + ", " + temp2);
                                         break;
                            case "evergreen": // Menor o igual
                                        parser.gen("sle " + tempResultado + ", " + temp1 + ", " + temp2);
                                        break;
                             case "minstix": // Mayor que
                                        parser.gen("sgt " + tempResultado + ", " + temp1 + ", " + temp2);
                                        break;
                             case "upatree": // Mayor o igual
                                        parser.gen("sge " + tempResultado + ", " + temp1 + ", " + temp2);
                                        break;
                             case "mary": // Igualdad
                                          parser.gen("seq " + tempResultado + ", " + temp1 + ", " + temp2);
                                         break;
                             case "openslae": // Diferente
                                    parser.gen("sne " + tempResultado + ", " + temp1 + ", " + temp2);
                                    break;
                              default:
                                    System.err.println("Error semántico en línea " + (line1 + 1) + ", columna " + (column1 + 1) +
                                                       ": Operador relacional no soportado.");
                                                       errorCount++;
                          }
                      }

                        RESULT = new Resultado("trueno", tempResultado);
                }
          :}
         | expresion:e1 operador_logico:op expresion:e2
                      {:
                       // Obtener los símbolos correspondientes a `e1` y `e2` para extraer línea y columna
                       Symbol symbol1 = (Symbol) CUP$parser$stack.elementAt(CUP$parser$stack.size() - 3);
                       Symbol symbol2 = (Symbol) CUP$parser$stack.elementAt(CUP$parser$stack.size() - 1);
                       int line1 = symbol1.left;
                       int column1 = symbol1.right;
                       int line2 = symbol2.left;
                       int column2 = symbol2.right;

                       // Validar que `e1` y `e2` no sean nulos
                       if (e1 == null) {
                           e1 = new Resultado("null", null);
                       }
                       if (e2 == null) {
                           e2 = new Resultado("null", null);
                       }

                       // Obtener los tipos desde los objetos Resultado
                       String tipo1 = ((Resultado) e1).tipo;
                       String tipo2 = ((Resultado) e2).tipo;

                       // Verificar que ambos operandos sean booleanos
                       if (!tipo1.equals("trueno") || !tipo2.equals("trueno")) {
                           System.err.println("Error semántico en línea " + (line1 + 1) + ", columna " + (column1 + 1) +
                                              ": Operadores lógicos requieren valores booleanos (trueno).");
                                              errorCount++;
                       } else {
                           // Generar código MIPS para operadores lógicos
                           String temp1 = ((Resultado) e1).temp;
                           String temp2 = ((Resultado) e2).temp;
                           String tempResultado = parser.newTemp();

                           switch (((Resultado) op).tipo) {
                               case "melchor": // AND lógico
                                   parser.gen("and " + tempResultado + ", " + temp1 + ", " + temp2);
                                   break;
                               case "gaspar": // OR lógico
                                   parser.gen("or " + tempResultado + ", " + temp1 + ", " + temp2);
                                   break;
                               default:
                                   System.err.println("Error semántico en línea " + (line1 + 1) + ", columna " + (column1 + 1) +
                                                       ": Operador logico no soportado.");
                                                       errorCount++;
                           }

                           // Asignar el resultado con el tipo booleano (trueno) y el temporal generado
                           RESULT = new Resultado("trueno", tempResultado);
                       }
         :}
         | NEGACION expresion:e
         {:
              Symbol symbol = (Symbol) CUP$parser$stack.peek();
              int line = symbol.left;
              int column = symbol.right;
              // Obtener el tipo y el temporal de la expresión
              Resultado resultadoE = (Resultado) e;
              String tipo = resultadoE.tipo;
              String tempE = resultadoE.temp;
              boolean esFlotante = tipo.equals("bromista");
              String tempResultado = esFlotante ? parser.newFloatTemp() : parser.newTemp();
              if (esFlotante) {
                    parser.gen("li.s $f1, 0.0");
                    parser.gen("li.s $f2, 1.0");
                    parser.gen("c.eq.s " + tempE + ", $f1");  // Comparar tempE con 0.0 (para !x)
                    parser.gen("movt.s " + tempResultado + ", $f2");
                    parser.gen("movf.s " + tempResultado + ", $f1");
              } else {
                    parser.gen("seq " + tempResultado + ", " + tempE + ", $zero");
              }
                 RESULT = new Resultado(tipo, tempResultado);
         :}
         | PARENTESISAPERTURA expresion:e PARENTESISCIERRE {: RESULT = e; :}
         | PARENTESISAPERTURA error PARENTESISCIERRE;

literal ::= L_INTEGER:i
    {:
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        String temp = parser.newTemp();
        parser.agregarVariable(symbol.left, symbol.right, symbol.value.toString(), "rodolfo");
        parser.gen("li " + temp + ", " + symbol.value);
        RESULT = new Resultado("rodolfo", temp);
    :}
    | L_FLOAT:f
    {:
           Symbol symbol = (Symbol) CUP$parser$stack.peek();
           String tempInt = parser.newTemp();
           String tempFloat = parser.newFloatTemp(); // Registro flotante

           parser.agregarVariable(symbol.left, symbol.right, symbol.value.toString(), "bromista");
           String ieee754Hex = parser.floatToIEEE754(symbol.value.toString());
           parser.gen("li " + tempInt + ", " + ieee754Hex); // Cargar valor IEEE 754 en un registro entero
           parser.gen("mtc1 " + tempInt + ", " + tempFloat); // Moverlo a un registro flotante
           RESULT = new Resultado("bromista", tempFloat);
    :}
    | L_STRING:s
          {:
              Symbol symbol = (Symbol) CUP$parser$stack.peek();
              String id = "_string_" + parser.currentTemp++;  // Generar un identificador único válido

              // Declarar el string en la sección .data con el valor correcto
              parser.declararString(id, symbol.value.toString());

              // Devolver un resultado con el tipo y el identificador del string
              RESULT = new Resultado("cometa", id);
          :}
    | L_CHAR:c
    {:
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        String temp = parser.newTemp();
        parser.agregarVariable(symbol.left, symbol.right, symbol.value.toString(), "cupido");
        parser.gen("li " + temp + ", '" + symbol.value + "'");
        RESULT = new Resultado("cupido", temp);
    :}
    | TRUE:t
    {:
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        String temp = parser.newTemp();
        parser.agregarVariable(symbol.left, symbol.right, symbol.value.toString(), "trueno");
        parser.gen("li " + temp + ", 1");
        RESULT = new Resultado("trueno", temp);
    :}
    | FALSE:f
    {:
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        String temp = parser.newTemp();
        parser.agregarVariable(symbol.left, symbol.right, symbol.value.toString(), "trueno");
        parser.gen("li " + temp + ", 0");
        RESULT = new Resultado("trueno", temp);
    :};

operador_binario ::= SUMA {:RESULT = new Resultado("navidad", null);:}
                 | RESTA {:RESULT = new Resultado("intercambio", null);:}
                 | DIVISION {:RESULT = new Resultado("reyes", null);:}
                 | MULTIPLICACION {:RESULT = new Resultado("nochebuena", null);:}
                 | MODULO {:RESULT = new Resultado("magos", null);:}
                 | POTENCIA {:RESULT = new Resultado("adviento", null);:};

operador_unario ::= INCREMENTO {:RESULT = new Resultado("quien", null);:}
                  | DECREMENTO {:RESULT = new Resultado("grinch", null);:}
                  | NEGATIVO {:RESULT = new Resultado("-", null);:};

operador_logico ::=  CONJUNCION {:RESULT = new Resultado("melchor", null);:}
                  | DISYUNCION {:RESULT = new Resultado("gaspar", null);:}
                  | NEGACION {:RESULT = new Resultado("baltazar", null);:};

operador_relacional ::= MENOR {:RESULT = new Resultado("snowball", null);:}
                       | MENOR_IGUAL {:RESULT = new Resultado("evergreen", null);:}
                       | MAYOR {:RESULT = new Resultado("minstix", null);:}
                       | MAYOR_IGUAL {:RESULT = new Resultado("upatree", null);:}
                       | IGUAL {:RESULT = new Resultado("mary", null);:}
                       | DIFERENTE {:RESULT = new Resultado("openslae", null);:};

estructura_control ::= if_stmt
                    | while_stmt
                    | for_stmt
                    | switch_stmt;

if_stmt ::= if_stmt_cabecera if_stmt_aux;

if_stmt_cabecera ::= IF PARENTESISAPERTURA expresion:e PARENTESISCIERRE
            {:
            if (e == null) {
                Symbol symbol = (Symbol) CUP$parser$stack.elementAt(CUP$parser$stack.size() - 2);
                int line = symbol.left;
                int column = symbol.right;

                System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                                   ": Se ha intentado utilizar una expresión con valor nulo en el if.");
                errorCount++;
            } else {

                  parser.etiquetaTrue = "_etiqueta_true_" + parser.currentTemp++;
                  parser.etiquetaEndIf = "_etiqueta_end_if" + parser.currentTemp++;
                  parser.etiquetaEndElse = "_etiqueta_end_else" + parser.currentTemp++;

                  parser.gen("bne " + ((Resultado) e).temp + ", $zero, " + etiquetaTrue);
                  parser.gen("j " + etiquetaEndIf);

                  parser.gen(etiquetaTrue + ":");
            }
            :}
          | IF PARENTESISAPERTURA error PARENTESISCIERRE bloqueEstructura
          | IF PARENTESISAPERTURA expresion PARENTESISCIERRE error ELSE bloqueEstructura
          | IF PARENTESISAPERTURA error PARENTESISCIERRE bloqueEstructura ELSE bloqueEstructura;

if_stmt_aux ::= bloqueEstructura
                {:
                    parser.gen(parser.etiquetaEndIf + ":");
                :}
                | bloqueEstructura
                {:
                    parser.gen("j " + etiquetaEndElse);
                    parser.gen(parser.etiquetaEndIf + ":");
                :}
                 ELSE if_else_stmt;

if_else_stmt ::= bloqueEstructura
                 {:
                   parser.gen(parser.etiquetaEndElse + ":");
                 :};

while_stmt ::= WHILE PARENTESISAPERTURA
               {:
                   parser.etiquetaInicioWhile = "_while_start_" + parser.currentTemp++;
                   parser.etiquetaEndWhile = "_while_end_" + parser.currentTemp++;

                   // Generar la etiqueta de inicio del bucle
                   parser.gen(parser.etiquetaInicioWhile + ":");
               :}
               expresion:e
               {:
                    if (e == null) {
                        Symbol symbol = (Symbol) CUP$parser$stack.elementAt(CUP$parser$stack.size() - 1);
                        int line = symbol.left;
                        int column = symbol.right;

                        System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                                           ": Se ha intentado utilizar una expresión con valor nulo.");
                        errorCount++;
                    }
                    else {
                   // Generar la condición del bucle
                   parser.gen("beq " + ((Resultado) e).temp + ", $zero, " + parser.etiquetaEndWhile);
                   }
               :}
               PARENTESISCIERRE bloqueEstructura
               {:
                   // Generar el código del cuerpo del bucle
                   parser.gen("j " + parser.etiquetaInicioWhile); // Volver al inicio
                   parser.gen(parser.etiquetaEndWhile + ":");    // Etiqueta de salida
               :}
             | WHILE PARENTESISAPERTURA error PARENTESISCIERRE bloqueEstructura;

for_stmt ::= for_stmt_cabecera for_camino for_stmt_aux;

for_stmt_cabecera ::= FOR PARENTESISAPERTURA
               {:
                   // Generar etiquetas para el inicio y fin del bucle
                   parser.etiquetaInicioFor = "_for_start_" + parser.currentTemp++;
                   parser.etiquetaEndFor = "_for_end_" + parser.currentTemp++;
               :};


for_camino ::= declaracion:e FIN_EXPRESION
               {:
                   // Guardar el nombre de la variable del iterador
                   parser.iteradorForActual = ((Resultado) e).temp;

                   // Generar la etiqueta de inicio del bucle
                   parser.gen(parser.etiquetaInicioFor + ":");
               :}
               |
               asignacion:e FIN_EXPRESION
               {:
                   // Guardar el nombre de la variable del iterador
                   parser.iteradorForActual = ((Resultado) e).temp;

                   // Generar la etiqueta de inicio del bucle
                   parser.gen(parser.etiquetaInicioFor + ":");
               :};

for_stmt_aux ::= expresion:e FIN_EXPRESION
               {:
                   if (e == null) {
                       Symbol symbol = (Symbol) CUP$parser$stack.elementAt(CUP$parser$stack.size() - 1);
                       int line = symbol.left;
                       int column = symbol.right;
                       System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                                          ": Se ha intentado utilizar una expresión con valor nulo en el for.");
                       errorCount++;
                   } else {
                       // Evaluar la condición del bucle
                       parser.gen("beq " + ((Resultado) e).temp + ", $zero, " + parser.etiquetaEndFor);
                   }
               :}
               expresion:e2 PARENTESISCIERRE
               {:
                   // Se ejecutará después de `bloqueEstructura`
               :}
               bloqueEstructura
               {:
                    parser.gen("# Aplicando actualización del for");

                    if (parser.iteradorForActual != null) {

                        String direccionIterador = parser.getVariableAddress(parser.iteradorForActual);
                        // Cargar el valor actual del iterador desde la pila
                            parser.gen("lw $t0, " + direccionIterador);

                            // Aplicar la actualización correctamente
                            String tempUpdate = ((Resultado) e2).temp;

                        if (tempUpdate != null) {  // Verificar que tempUpdate no sea nulo
                            if (tempUpdate.startsWith("addi") || tempUpdate.startsWith("subi")) {
                                // Si la actualización ya es una instrucción válida, la usamos directamente
                                parser.gen(tempUpdate.replaceFirst("\\$t\\d+", "$t0"));
                            } else {
                                // Si solo es un registro temporal, debemos generar la asignación explícita
                                parser.gen("move $t0, " + tempUpdate);
                            }

                            // Guardar el nuevo valor del iterador en la pila
                            parser.gen("sw $t0, " + direccionIterador);
                        } else {
                            // Obtener línea y columna para el mensaje de error
                            Symbol symbol = (Symbol) CUP$parser$stack.peek();
                            int line = symbol.left;
                            int column = symbol.right;

                            // Lanzar error semántico si tempUpdate es nulo
                            System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                                               ": Expresión de actualización inválida en el for.");
                                               errorCount++;
                        }
                    }


                   parser.gen("j " + parser.etiquetaInicioFor);
                   parser.gen(parser.etiquetaEndFor + ":");
               :};

switch_stmt ::= switch_cabecera case_list default_stmt switch_cierre
              | switch_cabecera case_list switch_cierre
              | SWITCH PARENTESISAPERTURA error PARENTESISCIERRE corcheteIzquierdo case_list corcheteDerecho;

switch_cabecera ::= SWITCH PARENTESISAPERTURA expresion:e PARENTESISCIERRE corcheteIzquierdo
               {:
                   // Crear etiqueta global para salir del switch
                   parser.etiquetaEndSwitch = "_switch_end_" + parser.currentTemp++;
                   parser.etiquetaDefault = "_default_" + parser.currentTemp++;

                   // Guardar el valor de la expresión del switch
                   parser.tempSwitch = ((Resultado) e).temp;

                   // Reiniciar contador de cases
                   parser.caseNumber = 0;
               :};

switch_cierre ::= corcheteDerecho
               {:
                   // Generar la etiqueta de salida del switch
                   parser.gen(parser.etiquetaEndSwitch + ":");
               :};

case_list ::= case_list case_stmt
            | case_stmt
            | case_list error case_stmt;

case_stmt ::= CASE expresion:e
            {:
                // Crear etiquetas
                String etiquetaCase = "_case_" + parser.caseNumber;
                String etiquetaSiguienteCase = "_case_next_" + parser.caseNumber;
                parser.caseNumber++;

                // Comparar la expresión del switch con el valor del case
                parser.gen("beq " + parser.tempSwitch + ", " + ((Resultado) e).temp + ", " + etiquetaCase);
                parser.gen("j " + etiquetaSiguienteCase);  // Saltar al siguiente case

                // Definir la etiqueta del case
                parser.gen(etiquetaCase + ":");
            :}
            DOS_PUNTOS lista_sentencias
            {:
                // Al final de la ejecución del case, saltar al final del switch
                parser.gen("j " + parser.etiquetaEndSwitch);

                // Solo generar etiqueta _case_next_ si hay más cases después
                if (parser.caseNumber > 0) {
                    parser.gen("_case_next_" + (parser.caseNumber - 1) + ":");
                }
            :}
            | CASE error DOS_PUNTOS lista_sentencias;

default_stmt ::= DEFAULT DOS_PUNTOS
               {:
                   // Generar la etiqueta para el default solo si no existe aún
                   if (!parser.etiquetaDefault.equals("_default_")) {
                       parser.gen(parser.etiquetaDefault + ":");
                   }

                   // El default no debe hacer un salto al final aquí, ya que ejecuta directamente su código
               :}
                 lista_sentencias;

declaracionArreglo ::= tipo:t IDENTIFICADOR:id acceso_arreglo:a
                      {:
                         Symbol symbol = (Symbol) CUP$parser$stack.peek();
                         parser.agregarVariable(symbol.left, symbol.right, id.toString(), ((Resultado) t).tipo);

                         // Validación del tipo permitido
                         if (!((Resultado) t).tipo.equals("rodolfo") && !((Resultado) t).tipo.equals("cupido")) {
                             System.err.println("Error semántico en línea " + (symbol.left + 1) + ", columna " + (symbol.right + 1) +
                                                 ": Solo se permiten variables de tipo 'rodolfo' (int) o 'cupido' (char).");
                                                 errorCount++;
                         } else {
                             System.out.println("Declaración válida: arreglo '" + id + "' de tipo '" + ((Resultado) t).tipo + "'.");
                         }
                         String tempIndice = ((Resultado) a).temp;
                         String tempSize = parser.newTemp();
                         String tempBase = parser.newTemp();
                         String tempRegistro = parser.newTemp();

                         parser.gen("mul " + tempSize + ", " + tempIndice + ", 4");
                         parser.gen("li $v0, 9");
                         parser.gen("move $a0, " + tempSize);
                         parser.gen("syscall");

                         parser.gen("move " + tempBase + ", $v0");
                         parser.gen("li " + tempRegistro + ", 3");
                         parser.gen("sw " + tempRegistro + ", 0(" + tempBase + ")");
                      :}
                  | IDENTIFICADOR:id acceso_arreglo:a
                  | tipo:t IDENTIFICADOR:id acceso_arreglo ASIGNA expresion:e
                  {:
                    Symbol symbol = (Symbol) CUP$parser$stack.peek();
                    parser.agregarVariable(symbol.left, symbol.right, id.toString(), ((Resultado) t).tipo);

                    String tipoExpresion = (e instanceof Resultado)
                        ? ((Resultado) e).tipo
                        : parser.getTipo(parser.listaTablasSimbolos.get(parser.currentHash), e.toString(), symbol.left, symbol.right);

                    // Validación de compatibilidad de tipos
                    if (!((Resultado) t).tipo.equals(tipoExpresion)) {
                        System.err.println("Error semántico en línea " + (symbol.left + 1) + ", columna " + (symbol.right + 1) +
                                           ": Incompatibilidad de tipos. La variable '" + id + "' es de tipo '" + ((Resultado) t).tipo +
                                           "', pero se le asignó una expresión de tipo '" + tipoExpresion + "'.");
                                           errorCount++;
                    } else if (!((Resultado) t).tipo.equals("rodolfo") && !((Resultado) t).tipo.equals("cupido")) {
                         System.err.println("Error semántico en línea " + (symbol.left + 1) + ", columna " + (symbol.right + 1) +
                                             ": Solo se permiten asignaciones a variables de tipo 'rodolfo' (int) o 'cupido' (char).");
                                             errorCount++;
                    } else {
                        // Generación de código MIPS para asignación
                        String temp = ((Resultado) e).temp;
                        parser.gen("la $t0, " + id);
                        parser.gen("sw " + temp + ", 0($t0)");
                        System.out.println("Asignación a arreglo válida: '" + id + "'.");
                    }
                  :}
                  | tipo:t IDENTIFICADOR:id acceso_arreglo:a ASIGNA corcheteIzquierdo parametrosArreglos corcheteDerecho
                    {:
                        Symbol symbol = (Symbol) CUP$parser$stack.peek();
                        parser.agregarVariable(symbol.left, symbol.right, id.toString(), ((Resultado) t).tipo);
                        System.out.println("Declaración y asignación de arreglo inicializado: '" + id + "'.");

                         String tempIndice = ((Resultado) a).temp;
                         String tempSize = parser.newTemp();
                         String tempBase = parser.newTemp();
                         String tempRegistro = parser.newTemp();

                         parser.gen("li " + tempSize + ", " + tempIndice + ", 4");
                         parser.gen("li $v0, 9");
                         parser.gen("move $a0, " + tempSize);
                         parser.gen("syscall");
                         parser.gen("move " + tempBase + ", $v0");
                         parser.gen("li " + tempRegistro + ", 3");
                         parser.gen("sw " + tempRegistro + ", 0(" + tempBase + ")");
                    :}
                  | IDENTIFICADOR:id acceso_arreglo ASIGNA expresion:e
                    {:
                        Symbol symbol = (Symbol) CUP$parser$stack.peek();
                        String tipoExpresion = (e instanceof Resultado)
                            ? ((Resultado) e).tipo
                            : parser.getTipo(parser.listaTablasSimbolos.get(parser.currentHash), e.toString(), symbol.left, symbol.right);
                        if (tipoExpresion != null) {
                            String temp = ((Resultado) e).temp;
                            parser.gen("la $t0, " + id);
                            parser.gen("sw " + temp + ", 0($t0)");
                            System.out.println("Asignación directa a arreglo válida: '" + id + "'.");
                        } else {
                            System.err.println("Error semántico en línea " + (symbol.left + 1) + ", columna " + (symbol.right + 1) +
                                               ": El valor asignado al arreglo no tiene un tipo válido.");
                                               errorCount++;
                        }
                    :};

parametrosArreglos::= parametrosArreglosAux;

parametrosArreglosAux ::= parametrosArreglosAux COMA
                          {:
                              // Generar un resultado con el separador de coma para unir parámetros
                              RESULT = new Resultado(",", null);
                          :}
                          expresion:e
                          {:
                              Symbol symbol = (Symbol) CUP$parser$stack.peek();
                              int line = symbol.left;
                              int column = symbol.right;
                              // Validar y asignar el resultado de la expresión
                                if (e instanceof Resultado) {
                                    Resultado resExp = (Resultado) e;
                                    if (resExp.tipo == null) {
                                        System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                                                           ": La expresión del parámetro no tiene un tipo válido.");
                                                           errorCount++;
                                    }
                                    RESULT = resExp;
                                } else {
                                    System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                                                       ": El resultado de la expresión no es válido.");
                                                       errorCount++;
                                }
                          :}
                      | expresion:e
                          {:
                              Symbol symbol = (Symbol) CUP$parser$stack.peek();
                              int line = symbol.left;
                              int column = symbol.right;
                              // Validar y asignar el resultado de la expresión directamente
                                if (e instanceof Resultado) {
                                    Resultado resExp = (Resultado) e;
                                    if (resExp.tipo == null) {
                                        System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                                                           ": La expresión del parámetro no tiene un tipo válido.");
                                                           errorCount++;
                                    }
                                    RESULT = resExp;
                                } else {
                                    System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                                                       ": El resultado de la expresión no es válido.");
                                                       errorCount++;
                                }
                          :};

arreglo ::= declaracionArreglo
            {:
                RESULT = null;
            :}
          | arreglo declaracionArreglo
            {:
                RESULT = null;
            :};

acceso_arreglo ::= CORCHETEAPERTURA
                    {:
                        RESULT = new Resultado("abreempaque", null);
                    :}
                    expresion:e
                    {:
                        Symbol symbol = (Symbol) CUP$parser$stack.peek();
                        int line = symbol.left;
                        int column = symbol.right;

                        if (e instanceof Resultado) {
                            Resultado resExp = (Resultado) e;
                            if (!"rodolfo".equals(resExp.tipo)) {
                                System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                                                   ": El índice del arreglo debe ser un entero (rodolfo), pero se encontró '" + resExp.tipo + "'.");
                                                   errorCount++;
                            }
                            RESULT = resExp;
                        } else {
                            System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                                               ": Expresión inválida en el índice del arreglo.");
                                               errorCount++;
                            RESULT = new Resultado("null", null);
                        }
                    :}
                    CORCHETECIERRE
                    {:
                        RESULT = new Resultado("cierraempaque", null);
                    :}
                 | CORCHETEAPERTURA error CORCHETECIERRE
                    {:
                        Symbol symbol = (Symbol) CUP$parser$stack.elementAt(CUP$parser$stack.size() - 2);
                        int line = symbol.left;
                        int column = symbol.right;

                        // Mensaje de error detallado
                        System.err.println("Error sintáctico en línea " + (line + 1) + ", columna " + (column + 1) +
                                           ": Índice del arreglo inválido.");
                                           errorCount++;

                        // Devolver un resultado seguro para evitar fallos posteriores
                        RESULT = new Resultado("null", null);
                    :};

parametros ::= lista_parametros
            ;

lista_parametros ::= lista_parametros COMA tipo:t IDENTIFICADOR:id
                    {:
                        Symbol symbol = (Symbol) CUP$parser$stack.peek();
                        parser.agregarVariable(symbol.left, symbol.right, id.toString(), ((Resultado) t).tipo);
                    :}
                    | tipo:t IDENTIFICADOR:id
                    {:
                        Symbol symbol = (Symbol) CUP$parser$stack.peek();
                        parser.agregarVariable(symbol.left, symbol.right, id.toString(), ((Resultado) t).tipo);
                    :}
                    | lista_parametros error tipo IDENTIFICADOR;

llamada_funcion ::= IDENTIFICADOR:id llamada_funcion_aux
    {:
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        int line = symbol.left;
        int column = symbol.right;

        // Construir una tabla global combinada
        ArrayList<String> tablaGlobal = new ArrayList<>();
        parser.listaTablasSimbolos.values().forEach(tabla -> {
            if (tabla != null) tablaGlobal.addAll(tabla);
        });

        // Obtener el tipo de la función
        String tipoFuncion = parser.getTipo(tablaGlobal, id.toString(), line, column);

        if (tipoFuncion.equals("null")) {
            // Si no se encuentra la función, asignar un RESULT con tipo "null"
            System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                               ": La función '" + id + "' no está declarada en ninguna tabla de símbolos.");
                               errorCount++;
            RESULT = new Resultado("null", null);
        } else {
            // Generar un temporal para almacenar el resultado de la función (si no es void)
            String tempResultado = null;
            if (!tipoFuncion.equals("void")) {
                tempResultado = parser.newTemp();
                parser.gen("jal " + id);  // Llamada a la función
                parser.gen("move " + tempResultado + ", $v0");
            } else {
                parser.gen("jal " + id);
            }

            System.out.println("Invocación válida: " + id + " de tipo: " + tipoFuncion);
            RESULT = new Resultado(tipoFuncion, tempResultado);
        }
    :};


llamada_funcion_aux ::=  PARENTESISAPERTURA lista_expresiones PARENTESISCIERRE
                      |  PARENTESISAPERTURA PARENTESISCIERRE
                      |  PARENTESISAPERTURA error PARENTESISCIERRE;

lista_expresiones ::= lista_expresiones COMA
                    {:
                    :}
                    expresion:e
                    {:
                        RESULT = e;
                    :}
                   | expresion:e
                    {:
                        RESULT = e;
                    :}
                   | lista_expresiones error expresion:e
                    {:
                        RESULT = e;
                    :};

return_stmt ::= RETURN expresion:e
            {:
                Symbol symbol = (Symbol) CUP$parser$stack.peek();
                int line = symbol.left;
                int column = symbol.right;

                // Obtener el tipo de la función actual usando `currentHash`
                String tipoFuncion = parser.getTipo(parser.listaTablasSimbolos.get(parser.currentHash), parser.currentHash, line, column);

                if (e == null) {
                    // Manejo de RETURN sin expresión
                    if (!tipoFuncion.equals("void")) {
                        System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                                           ": La función requiere un valor de retorno de tipo '" + tipoFuncion + "', pero se encontró 'void'.");
                                           errorCount++;
                    } else {
                        System.out.println("Retorno válido: void en función de tipo void.");
                        parser.gen("jr $ra");  // Retornar a la dirección de retorno en MIPS
                        RESULT = new Resultado("void", null);
                    }
                } else {
                    // Manejo de RETURN con expresión
                    Resultado resultadoExpresion = (Resultado) e;
                    String tipoExpresion = resultadoExpresion.tipo;

                    // Comparar los tipos
                    if (!tipoFuncion.equals(tipoExpresion)) {
                        System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                                           ": Tipo de retorno (" + tipoExpresion + ") no coincide con el tipo de la función (" + tipoFuncion + ").");
                                           errorCount++;
                    } else {
                        System.out.println("Retorno válido: tipo '" + tipoExpresion + "'.");

                        // Generar código MIPS para mover el valor de retorno a $v0
                        if (resultadoExpresion.temp != null) {
                            parser.gen("move $v0, " + resultadoExpresion.temp);
                        } else {
                            System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                                               ": El temporal para el valor de retorno es null. Asegúrese de que la función retorna un valor válido.");
                                               errorCount++;
                        }
                        parser.gen("jr $ra");  // Retornar a la dirección de retorno en MIPS
                    }

                    RESULT = new Resultado(tipoExpresion, resultadoExpresion.temp);
                }
            :}
              | RETURN
              | RETURN error
                {:
                    Symbol symbol = (Symbol) CUP$parser$stack.peek();
                    int line = symbol.left;
                    int column = symbol.right;

                    System.err.println("Error sintáctico en línea " + (line + 1) + ", columna " + (column + 1) +
                                       ": Retorno inválido. Asegúrese de que la expresión de retorno sea válida.");
                                       errorCount++;
                    RESULT = new Resultado("null", null);
                :};

return_estructura_stmt ::= RETURN expresion
              | RETURN
              | RETURN error;