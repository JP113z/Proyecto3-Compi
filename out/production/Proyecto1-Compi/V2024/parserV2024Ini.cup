package ParserLexer;
import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.HashMap;
import Tree.Arbol;
import Tree.Nodo;
import V2024.Resultado;

action code {:  :};

parser code {:
    BasicLexerCupV lex;

    private int errorCount = 0;

    private Arbol arbol;

    private int bloqueActual = 0;

    StringBuffer codMIPS = new StringBuffer();
    int currentTemp = 1;

   public String newTemp() {
           return "T" + currentTemp++;
       }

       public void gen(String instruction) {
              System.out.println("Generando instrucción: " + instruction);
              codMIPS.append(instruction).append("\n");
          }

        public void imprimirCodigoMIPS() {
               if (codMIPS.length() == 0) {
                   System.out.println("No se generaron instrucciones MIPS.");
               } else {
                   System.out.println("\n\nCÓDIGO MIPS");
                   System.out.println(codMIPS.toString());
               }
        }

        public void asignarCodigoMIPS(String id, String temp) {
                if (id == null || temp == null) {
                    System.err.println("Error: id o temp no pueden ser nulos");
                    return;
                }
                gen("la $t0, " + id);  // Cargar la dirección de la variable en $t0
                gen("lw $t1, " + temp); // Cargar el valor del temporal en $t1
                gen("sw $t1, 0($t0)");  // Guardar el valor en la dirección de la variable
               // imprimirCodigoMIPS();
       }

    public String getTipo(ArrayList<String> listaTablasSimbolos, String id, int line, int column) {
        if (listaTablasSimbolos == null) {
            System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                               ": La tabla de símbolos está vacía o no inicializada.");
            return "null";
        }

        String tipo = "null";

        for (String token : listaTablasSimbolos) {
            // Divide el token en columnas usando "|" como delimitador
            String[] partesToken = token.split("\\|");
            if (partesToken.length < 5) { // Verifica que haya al menos 5 columnas
                System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                                   ": Formato inválido en token: " + token);
                continue;
            }
            String lexema = partesToken[3].trim(); // Columna "Lexema"
            String tipoEncontrado = partesToken[4].trim(); // Columna "Tipo"

            // Compara el lexema con el id que estamos buscando
            if (id.equals(lexema)) {
                tipo = tipoEncontrado;
                break;
            }
        }

        if (tipo.equals("null")) {
            System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                               ": Identificador '" + id + "' no está declarado.");
        }

        return tipo;
    }
    /**
     * Método: getArbol
     * Objetivo: Obtener el arbol.
     * Entradas: Ninguna
     * Salida: El arbol actual.
     */
    public Arbol getArbol() {
        return arbol;
    }
    /**
     * Método: crearNodo
     * Objetivo: Crear un nuevo nodo para el árbol sintáctico con un dato específico.
     * Entradas:
     *   - dato: Cadena de texto que representa el valor asociado al nodo.
     * Salida: Una instancia de la clase Nodo con el dato proporcionado.
     */
    private Nodo crearNodo(String dato) {
        return new Nodo(dato);
    }

    /**
     * Método: syntax_error
     * Objetivo: Manejar los errores sintácticos encontrados durante el análisis sintáctico.
     * Entradas:
     *   - s: Objeto de tipo Symbol que contiene información sobre el error sintáctico, como la posición y el token involucrado.
     * Salida: Ninguna.
     * Restricciones: Se espera que el objeto Symbol contenga información válida de posición y token.
     */
    @Override
    public void syntax_error(Symbol s) {
        errorCount++;
        System.err.println("Error sintáctico en línea " + (s.left + 1) +
                           ", columna " + (s.right + 1) + ". Token inesperado: " + s.value);
    }

    /**
     * Método: hasErrors
     * Objetivo: Verificar si se han registrado errores durante el análisis sintáctico.
     * Entradas: Ninguna.
     * Salida: Booleano que indica si existen errores (true si hay errores, false sino).
     *         Se utiliza en la clase MainJFlexCup para indicar si el archivo puede generarse
     * Restricciones: La variable errorCount debe haber sido correctamente inicializada y actualizada.
     */
    public boolean hasErrors() {
        return errorCount > 0;
    }

    @SuppressWarnings("deprecation")
    public parser(BasicLexerCupV lex) {
        this.lex = lex;
        this.symbolFactory = new DefaultSymbolFactory();
        this.currentHash = null;
        this.arbol = new Arbol();
    }

    // Tabla de símbolos
    HashMap<String, ArrayList<String>> listaTablasSimbolos = new HashMap<>();
    String currentHash;

    /**
     * Método: imprimirTablaSimbolos
     * Objetivo: Imprimir todas las tablas de símbolos almacenadas, mostrando el contenido de cada tabla en un formato tabular.
     * Entradas: Ninguna.
     * Salida: Se llama en MainJFlexCup para imprimir en la consola el contenido de las tablas de símbolos.
     * Detalles:
     *   - Cada tabla está asociada a una clave (nombre de la función o el main).
     *   - Se imprime una tabla separada para cada clave con columnas que incluyen línea, columna, lexema y tipo.
     * Restricciones: Se espera que la estructura `listaTablasSimbolos` esté correctamente inicializada y contenga las claves y los valores correspondientes.
     */
    public void imprimirTablaSimbolos() {
        for (String key : listaTablasSimbolos.keySet()) {
            System.out.println("\nTabla de símbolos: " + key);
            System.out.println("+--------+---------+----------------------+------------+-----------+");
            System.out.println("| Línea  | Columna | Lexema              | Tipo       | Bloque    |");
            System.out.println("+--------+---------+----------------------+------------+-----------+");
            for (String simbolo : listaTablasSimbolos.get(key)) {
                System.out.println(simbolo);
            }
            System.out.println("+--------+---------+----------------------+------------+-----------+\n");
        }
    }

    /**
     * Método: agregarTablaSimbolos
     * Objetivo: Crear una nueva tabla de símbolos asociada a una función o al main y agregarla al mapa de tablas de símbolos.
     * Entradas:
     *   - tipoTabla: Tipo de la tabla ("función" o "main").
     *   - nombre: Nombre asociado a la tabla (El nombre de la función o "_verano_" que es el token asociado a main).
     * Salida: Ninguna.
     * Detalles:
     *   - Se inicializa una nueva tabla de símbolos como una lista de cadenas.
     *   - Se guarda en el mapa `listaTablasSimbolos` con el nombre como clave.
     *   - `currentHash` se actualiza para indicar que la tabla activa es la recién creada.
     * Restricciones:
     *   - El nombre de la tabla debe ser único para evitar sobrescribir tablas existentes.
     */
    public void agregarTablaSimbolos(String tipoTabla, String nombre) {
        System.out.println("/+++Nueva tabla símbolos función o main+++/ " + nombre);
        ArrayList<String> nuevaTabla = new ArrayList<>();
        currentHash = nombre;
        bloqueActual = 1;
        listaTablasSimbolos.put(currentHash, nuevaTabla);
    }

    /**
     * Método: agregarVariable
     * Objetivo: Agregar una nueva variable a la tabla de símbolos activa, registrando su línea, columna, lexema y tipo.
     * Entradas:
     *   - linea: Número de línea donde se encuentra la variable.
     *   - columna: Número de columna donde se encuentra la variable.
     *   - lexema: Nombre o representación textual de la variable.
     *   - tipo: Tipo de la variable
     * Salida: Ninguna.
     * Detalles:
     *   - Verifica que haya una tabla de símbolos activa (`currentHash`) y que esta exista en el mapa `listaTablasSimbolos`.
     *   - Si no hay tabla activa o no existe, se imprime un mensaje de error.
     *   - Si todo es válido, formatea la información de la variable en una tabla y la agrega a la tabla de símbolos activa.
     * Restricciones:
     *   - Debe existir una tabla de símbolos activa antes de llamar a este método.
     *   - La línea, columna, lexema y tipo deben ser datos válidos y coherentes con el análisis.
     */
    public void agregarVariable(int linea, int columna, String lexema, String tipo) {
        System.out.println("PARSER: identificador (agregar o verificar) " + lexema);
        if (currentHash == null) {
            System.err.println("Error: No hay una tabla de símbolos activa");
            return;
        }
        ArrayList<String> tabla = listaTablasSimbolos.get(currentHash);
        if (tabla == null) {
            System.err.println("Error: La tabla de símbolos '" + currentHash + "' no existe");
            return;
        }
        String entrada = String.format("| %-6d | %-7d | %-20s | %-10s | Bloque %-3d |",
                linea + 1, columna + 1, lexema, tipo, bloqueActual);
        tabla.add(entrada);
    }
:}

init with {: :};

scan with {: return lex.next_token(); :};

/* Terminales */
terminal MAIN, INTEGER, STRING, FLOAT, BOOL, CHAR;
terminal L_INTEGER, L_FLOAT, L_STRING, L_CHAR;
terminal COMA, IDENTIFICADOR, corcheteIzquierdo, corcheteDerecho, CORCHETEAPERTURA, CORCHETECIERRE, TRUE, FALSE, ASIGNA, PARENTESISAPERTURA, PARENTESISCIERRE,
INCREMENTO, DECREMENTO, NEGATIVO, MENOR, MENOR_IGUAL, MAYOR, MAYOR_IGUAL, IGUAL, DIFERENTE, CONJUNCION, DISYUNCION, NEGACION, FIN_EXPRESION, IF, ELSE, WHILE, FOR, SWITCH, CASE, DEFAULT, BREAK, RETURN,
DOS_PUNTOS, PRINT, READ,SUMA, RESTA, DIVISION, MULTIPLICACION, MODULO, POTENCIA;

/* No terminales */
non terminal programa, declaracion_main, bloque, lista_sentencias, sentencia, declaracion, asignacion, expresion, tipo, literal, operador_binario,
operador_unario, operador_logico, operador_relacional, estructura_control, if_stmt, while_stmt, for_stmt, switch_stmt,  case_list, case_stmt, default_stmt,
lista_expresiones,  arreglo, acceso_arreglo, llamada_funcion, declaracion_funcion, parametros, lista_parametros, return_stmt, funcion, lista_funciones, declaracionArreglo, parametrosArreglos,
parametrosArreglosAux, bloqueEstructura, cabecera_main, cabecera_funcion, contenido_estructura_control, llamada_funcion_aux, print, read, return_estructura_stmt;

/* Precedencias */
precedence right error;
precedence left FIN_EXPRESION;
precedence left DISYUNCION;
precedence left CONJUNCION;
precedence right NEGACION;
precedence nonassoc MENOR, MENOR_IGUAL, MAYOR, MAYOR_IGUAL, IGUAL, DIFERENTE;
precedence left SUMA, RESTA;
precedence left MULTIPLICACION, DIVISION, MODULO;
precedence right POTENCIA;
precedence right NEGATIVO;
precedence right INCREMENTO, DECREMENTO;

/* Reglas de producción con manejo de errores */
start with programa;

programa ::= lista_funciones
          | error lista_funciones
          | lista_funciones error;

lista_funciones ::= lista_funciones:lf funcion:f {: :}
                 | funcion:f {: :}
                 | lista_funciones error funcion;

funcion ::= cabecera_funcion:df {: :}
          | cabecera_main:dm {: :}
          | error bloque;

declaracion_main ::= PARENTESISAPERTURA PARENTESISCIERRE bloque
                  |  PARENTESISAPERTURA error PARENTESISCIERRE bloque
                  ;

cabecera_main ::= tipo:t MAIN
                {:
                    Symbol symbol = (Symbol) CUP$parser$stack.peek();
                    parser.agregarTablaSimbolos("main", "_verano_");
                    parser.agregarVariable(symbol.left, symbol.right, "_verano_", ((Resultado) t).tipo);
                :} declaracion_main
                | error MAIN PARENTESISAPERTURA PARENTESISCIERRE bloque;

declaracion_funcion ::= PARENTESISAPERTURA parametros:p PARENTESISCIERRE bloque:b
                     | PARENTESISAPERTURA PARENTESISCIERRE bloque:b
                     | PARENTESISAPERTURA error PARENTESISCIERRE bloque;


cabecera_funcion ::= tipo:t IDENTIFICADOR:id
                   {:
                       Symbol symbol = (Symbol) CUP$parser$stack.peek();
                       parser.agregarTablaSimbolos("funcion", id.toString());
                       parser.agregarVariable(symbol.left, symbol.right, id.toString(), ((Resultado) t).tipo);
                   :} declaracion_funcion
                   | error IDENTIFICADOR PARENTESISAPERTURA parametros PARENTESISCIERRE bloque;

bloque ::= corcheteIzquierdo
        {:
            parser.bloqueActual++;
        :}
        lista_sentencias return_stmt FIN_EXPRESION corcheteDerecho
        | corcheteIzquierdo
        {:
            parser.bloqueActual++;
        :}
        return_stmt FIN_EXPRESION corcheteDerecho
        | corcheteIzquierdo error corcheteDerecho;

bloqueEstructura ::= corcheteIzquierdo
                    {:
                        parser.bloqueActual++;
                    :}
                    contenido_estructura_control
                  | corcheteIzquierdo error corcheteDerecho;

contenido_estructura_control ::= corcheteDerecho
                             | lista_sentencias corcheteDerecho
                             | lista_sentencias return_estructura_stmt FIN_EXPRESION corcheteDerecho
                             | return_estructura_stmt FIN_EXPRESION corcheteDerecho;

lista_sentencias ::= lista_sentencias sentencia
                  | sentencia
                  | error {: System.err.println("Error en una sentencia."); :};

sentencia ::= declaracion FIN_EXPRESION
            | asignacion FIN_EXPRESION
            | estructura_control
            | expresion FIN_EXPRESION
            | BREAK FIN_EXPRESION
            | print FIN_EXPRESION
            | read FIN_EXPRESION
            | error FIN_EXPRESION
            ;
print::= PRINT PARENTESISAPERTURA expresion:e PARENTESISCIERRE
        {:
        Symbol symbol = (Symbol) CUP$parser$stack.elementAt(CUP$parser$stack.size() - 2);
        int line = symbol.left;
        int column = symbol.right;


        String tipo = (e instanceof Resultado)
            ? ((Resultado) e).tipo
            : parser.getTipo(parser.listaTablasSimbolos.get(parser.currentHash), e.toString(), line, column);

        // Validar que el tipo sea compatible con `print`
        if ((!tipo.equals("rodolfo") && !tipo.equals("bromista")) && !tipo.equals("cupido") && !tipo.equals("cometa")) {
            System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                               ": Solo puede usar el print con enteros, flotantes, cadenas y caracteres.");
        }

        RESULT = new Resultado(tipo, null);
         :};

read::= READ PARENTESISAPERTURA expresion:e PARENTESISCIERRE
        {:
        // Obtener el símbolo correspondiente a `e` para extraer línea y columna
        Symbol symbol = (Symbol) CUP$parser$stack.elementAt(CUP$parser$stack.size() - 2);
        int line = symbol.left;
        int column = symbol.right;

        // Obtener el tipo de la expresión
        String tipo = (e instanceof Resultado)
            ? ((Resultado) e).tipo
            : parser.getTipo(listaTablasSimbolos.get(currentHash), e.toString(), line, column);

        // Validar que el tipo sea compatible con `read`
        if ((!tipo.equals("rodolfo") && !tipo.equals("bromista"))) {
            System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                               ": El read solo lee enteros o flotantes.");
        }

        RESULT = new Resultado(tipo, null);
        :};

declaracion ::= tipo:t IDENTIFICADOR:id
    {:
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, id.toString(), ((Resultado) t).tipo);
    :}
    | tipo:t IDENTIFICADOR:id ASIGNA expresion:e
    {:
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, id.toString(), ((Resultado) t).tipo);

        // Verificar que el tipo de la expresión sea compatible con el tipo de la variable
        int line = symbol.left;
        int column = symbol.right;

        if (!((Resultado) t).tipo.equals(((Resultado) e).tipo)) {
            System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                               ": Tipo incompatible en asignación. Variable '" + id +
                               "' es de tipo " + ((Resultado) t).tipo + ", pero se le asignó un valor de tipo " + ((Resultado) e).tipo + ".");
        }
    :}
    | arreglo
    | tipo error;

tipo ::= INTEGER{: RESULT = new Resultado("rodolfo", null); :}
    | STRING{: RESULT = new Resultado("cometa", null); :}
    | CHAR{: RESULT = new Resultado("cupido", null); :}
    | FLOAT{: RESULT = new Resultado("bromista", null); :}
    | BOOL{: RESULT = new Resultado("trueno", null); :};

asignacion ::= IDENTIFICADOR:id ASIGNA expresion:exp
                {:
                Symbol symbol = (Symbol) CUP$parser$stack.elementAt(CUP$parser$stack.size() - 3);
                int line = symbol.left;
                int column = symbol.right;

                // Obtener el tipo del identificador
                String tipoIdentificador = parser.getTipo(
                        parser.listaTablasSimbolos.get(parser.currentHash), id.toString(), line, column);

                // Obtener el tipo y temporal de la expresión
                Resultado resultadoExp = (Resultado) exp;
                String tipoExpresion = resultadoExp.tipo;
                // Validar tipos
                if (!tipoIdentificador.equals(tipoExpresion)) {
                    System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                                       ": Asignación inválida. Variable '" + id +
                                       "' es de tipo " + tipoIdentificador + ", pero se le asignó un valor de tipo " + tipoExpresion + ".");
                } else {
                    System.out.println("Asignación válida: '" + id + "' de tipo '" + tipoIdentificador +
                                       "' con valor de tipo '" + tipoExpresion + "'.");

                    // Generación de código MIPS
                    String temp = parser.newTemp();
                    parser.gen("la " + temp + ", " + resultadoExp.temp);  // Cargar el valor de la expresión al temporal
                    parser.gen("sw " + temp + ", " + id);  // Guardar el valor en la variable
                }
              :}
             | IDENTIFICADOR ASIGNA error
             | error;

expresion ::= literal:e {: RESULT = e; :}
         | IDENTIFICADOR:e
             {:
                 // Obtener el símbolo directamente desde el stack
                 Symbol symbol = (Symbol) CUP$parser$stack.peek();

                 // Extraer línea y columna
                 int line = symbol.left;
                 int column = symbol.right;

                 // Llamar a `getTipo` para obtener el tipo del identificador
                 String tipo = parser.getTipo(parser.listaTablasSimbolos.get(parser.currentHash), e.toString(), line, column);

                 // Generar un temporal para el identificador (si aplica)
                 String temp = parser.newTemp();

                 // Asignar el tipo y el temporal al resultado
                 RESULT = new Resultado(tipo, temp);
             :}
         | llamada_funcion:f {: RESULT = f; :}
         | expresion:e1 operador_unario:op
           {:
               // Obtener el símbolo correspondiente a `e1` para extraer línea y columna
               Symbol symbol = (Symbol) CUP$parser$stack.elementAt(CUP$parser$stack.size() - 2);
               int line = symbol.left;
               int column = symbol.right;

               // Obtener el tipo de la expresión
               String tipo = ((Resultado) e1).tipo;

               // Validar tipos para operadores unarios
               if (op.toString().equals("quien") || op.toString().equals("grinch")) {
                   if (!tipo.equals("rodolfo")) {
                       System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                                          ": Incremento/Decremento solo aplica a enteros (rodolfo).");
                   }
               } else if (op.toString().equals("-") && !tipo.equals("rodolfo") && !tipo.equals("bromista")) {
                   System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                                      ": Negación solo aplica a enteros o flotantes.");
               }

               // Generar el temporal para la operación unaria
               String temp = parser.newTemp();
               // Aquí no se genera código MIPS todavía, pero podrías hacerlo después

               // Asignar el resultado con el tipo y el temporal generado
               RESULT = new Resultado(tipo, temp);
           :}
          | expresion:e1 operador_binario:op expresion:e2
           {:
               // Obtener los símbolos correspondientes a `e1` y `e2` para extraer línea y columna
               Symbol symbol1 = (Symbol) CUP$parser$stack.elementAt(CUP$parser$stack.size() - 3);
               Symbol symbol2 = (Symbol) CUP$parser$stack.elementAt(CUP$parser$stack.size() - 1);

               int line1 = symbol1.left;
               int column1 = symbol1.right;
               int line2 = symbol2.left;
               int column2 = symbol2.right;

               // Acceder a los tipos de los operandos desde los objetos Resultado
               String tipo1 = ((Resultado) e1).tipo;
               String tipo2 = ((Resultado) e2).tipo;

               // Debug: Verificar los tipos antes de la evaluación
               System.out.println("DEBUG - tipo1: " + tipo1 + ", tipo2: " + tipo2);

               // Validar los tipos de los operandos
               if ((!tipo1.equals("rodolfo") && !tipo1.equals("bromista")) ||
                   (!tipo2.equals("rodolfo") && !tipo2.equals("bromista"))) {
                   System.err.println("Error semántico en línea " + (line1 + 1) + ", columna " + (column1 + 1) +
                                      ": Operandos deben ser enteros (rodolfo) o flotantes (bromista).");
               } else if (!tipo1.equals(tipo2)) {
                   System.err.println("Error semántico en línea " + (line1 + 1) + ", columna " + (column1 + 1) +
                                      ": Tipos incompatibles entre los operandos. Operando 1: " + tipo1 + ", Operando 2: " + tipo2);
               }else {
                   String tipoResultado = tipo1.equals("bromista") ? "bromista" : "rodolfo";

                   String temp1 = ((Resultado) e1).temp;
                   String temp2 = ((Resultado) e2).temp;
                   String tempResultado = parser.newTemp();

                   System.out.println("Expresion: " + ((Resultado) e1).tipo);
                   switch (((Resultado) op).tipo) {
                            case "navidad": // Suma
                                  parser.gen("add " + tempResultado + ", " + temp1 + ", " + temp2);  // Suma
                                  break;
                            case "intercambio": // Resta
                                  parser.gen("sub " + tempResultado + ", " + temp1 + ", " + temp2);  // Resta
                                  break;
                           case "nochebuena": // Multiplicación
                                 parser.gen("mul " + tempResultado + ", " + temp1 + ", " + temp2);  // Multiplicación
                                 break;
                           case "reyes": // División
                                 parser.gen("div " + temp1 + ", " + temp2);  // División
                                 parser.gen("mflo " + tempResultado);  // Guardar el resultado en el temporal
                                 break;
                           case "magos": // Módulo
                                 parser.gen("div " + temp1 + ", " + temp2);  // División para obtener el resto
                                 parser.gen("mfhi " + tempResultado);  // El resto se guarda en mfhi
                                 break;
                           case "adviento": // Potencia
                                 //Hay que bucar a que traduce en MIPS
                                 break;
                           default:
                                 System.err.println("Error: Operación binaria no soportada.");
                                  }

                         RESULT = new Resultado(tipoResultado, tempResultado);

                         // Llamar a asignarCodigoMIPS después de todas las operaciones para almacenar el resultado en la variable
                         parser.asignarCodigoMIPS("resultado", tempResultado);

               }
               // Definir el tipo resultante basado en los operandos
               String tipoResultado = tipo1.equals("bromista") ? "bromista" : "rodolfo";

               // Generar un temporal para la operación
               String temp1 = ((Resultado) e1).temp;
               String temp2 = ((Resultado) e2).temp;
               String tempResult = parser.newTemp();

               // Asignar el resultado con el tipo y el temporal generado
               RESULT = new Resultado(tipoResultado, tempResult);
           :}
         | expresion:e1 operador_relacional:op expresion:e2
             {:
                // Obtener los símbolos correspondientes a `e1` y `e2` para extraer línea y columna
                Symbol symbol1 = (Symbol) CUP$parser$stack.elementAt(CUP$parser$stack.size() - 3);
                Symbol symbol2 = (Symbol) CUP$parser$stack.elementAt(CUP$parser$stack.size() - 1);
                int line1 = symbol1.left;
                int column1 = symbol1.right;
                int line2 = symbol2.left;
                int column2 = symbol2.right;
                String operador = ((Resultado) op).tipo;
                // Obtener los tipos desde los objetos Resultado
                String tipo1 = ((Resultado) e1).tipo;
                String tipo2 = ((Resultado) e2).tipo;

                // Validar los tipos de los operandos
                if (op.toString().equals("mary") || op.toString().equals("openslae")) {
                    // Para `mary` y `openslae`, los tipos pueden ser enteros, flotantes o booleanos
                    if ((!tipo1.equals("rodolfo") && !tipo1.equals("bromista") && !tipo1.equals("trueno")) ||
                        (!tipo2.equals("rodolfo") && !tipo2.equals("bromista") && !tipo2.equals("trueno"))) {
                        System.err.println("Error semántico en línea " + (line1 + 1) + ", columna " + (column1 + 1) +
                                           ": Operadores '" + operador + "' solo admiten enteros (rodolfo), flotantes (bromista) o booleanos (trueno).");
                    } else if (!tipo1.equals(tipo2)) {
                        System.err.println("Error semántico en línea " + (line1 + 1) + ", columna " + (column1 + 1) +
                                           ": Tipos incompatibles para operador '" + operador + "'. Operando 1: " + tipo1 + ", Operando 2: " + tipo2);
                    } else {
                        // Asignar el tipo resultante para comparaciones lógicas
                        RESULT = new Resultado("trueno", null);
                    }
                } else {
                    // Validación para otros operadores relacionales
                    if ((!tipo1.equals("rodolfo") && !tipo1.equals("bromista")) ||
                        (!tipo2.equals("rodolfo") && !tipo2.equals("bromista"))) {
                        System.err.println("Error semántico en línea " + (line1 + 1) + ", columna " + (column1 + 1) +
                                           ": Operadores '" + operador + "' solo admiten enteros (rodolfo) o flotantes (bromista).");
                    } else if (!tipo1.equals(tipo2)) {
                        System.err.println("Error semántico en línea " + (line1 + 1) + ", columna " + (column1 + 1) +
                                           ": Tipos incompatibles entre los operandos. Operando 1: " + tipo1 + ", Operando 2: " + tipo2);
                    } else {
                        // Asignar el tipo resultante para comparaciones relacionales
                        RESULT = new Resultado("trueno", null);
                    }
                }
             :}
         | expresion:e1 operador_logico:op expresion:e2
           {:
            // Obtener los símbolos correspondientes a `e1` y `e2` para extraer línea y columna
            Symbol symbol1 = (Symbol) CUP$parser$stack.elementAt(CUP$parser$stack.size() - 3);
            Symbol symbol2 = (Symbol) CUP$parser$stack.elementAt(CUP$parser$stack.size() - 1);
            int line1 = symbol1.left;
            int column1 = symbol1.right;
            int line2 = symbol2.left;
            int column2 = symbol2.right;

            if (e1 == null) {
                e1 = new Resultado("null", null);
            }
            if (e2 == null) {
                e2 = new Resultado("null", null);
            }
            // Obtener los tipos desde los objetos Resultado
            String tipo1 = ((Resultado) e1).tipo;
            String tipo2 = ((Resultado) e2).tipo;

            if (tipo1.equals(null)) {

                  RESULT = new Resultado("trueno", null);
            } else {
                // Verificar que ambos operandos sean booleanos
                if (!tipo1.equals("trueno") || !tipo2.equals("trueno")) {
                    System.err.println("Error semántico en línea " + (line1 + 1) + ", columna " + (column1 + 1) +
                                       ": Operadores lógicos requieren valores booleanos (trueno).");
                }

                // Definir el tipo resultante
                RESULT = new Resultado("trueno", null);
            }
           :}
         | NEGACION expresion:e
         | PARENTESISAPERTURA expresion:e PARENTESISCIERRE {: RESULT = e; :}
         | PARENTESISAPERTURA error PARENTESISCIERRE;

literal ::= L_INTEGER:i
    {:
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, symbol.value.toString(), "rodolfo");
        RESULT = new Resultado("rodolfo", null); // Tipo "rodolfo" y temporal null (aún no se genera código MIPS)
    :}
    | L_FLOAT:f
    {:
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, symbol.value.toString(), "bromista");
        RESULT = new Resultado("bromista", null); // Tipo "bromista" y temporal null
    :}
    | L_STRING:s
    {:
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, symbol.value.toString(), "cometa");
        RESULT = new Resultado("cometa", null); // Tipo "cometa" y temporal null
    :}
    | L_CHAR:c
    {:
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, symbol.value.toString(), "cupido");
        RESULT = new Resultado("cupido", null); // Tipo "cupido" y temporal null
    :}
    | TRUE:t
    {:
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, symbol.value.toString(), "trueno");
        RESULT = new Resultado("trueno", null); // Tipo "trueno" y temporal null
    :}
    | FALSE:f
    {:
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, symbol.value.toString(), "trueno");
        RESULT = new Resultado("trueno", null); // Tipo "trueno" y temporal null
    :};

operador_binario ::= SUMA {:RESULT = new Resultado("navidad", null);:}
                 | RESTA {:RESULT = new Resultado("intercambio", null);:}
                 | DIVISION {:RESULT = new Resultado("reyes", null);:}
                 | MULTIPLICACION {:RESULT = new Resultado("nochebuena", null);:}
                 | MODULO {:RESULT = new Resultado("magos", null);:}
                 | POTENCIA {:RESULT = new Resultado("adviento", null);:};

operador_unario ::= INCREMENTO {:RESULT = new Resultado("quien", null);:}
                  | DECREMENTO {:RESULT = new Resultado("grinch", null);:}
                  | NEGATIVO {:RESULT = new Resultado("-", null);:};

operador_logico ::=  CONJUNCION {:RESULT = new Resultado("melchor", null);:}
                  | DISYUNCION {:RESULT = new Resultado("gaspar", null);:}
                  | NEGACION {:RESULT = new Resultado("baltazar", null);:};

operador_relacional ::= MENOR {:RESULT = new Resultado("snowball", null);:}
                       | MENOR_IGUAL {:RESULT = new Resultado("evergreen", null);:}
                       | MAYOR {:RESULT = new Resultado("minstix", null);:}
                       | MAYOR_IGUAL {:RESULT = new Resultado("upatree", null);:}
                       | IGUAL {:RESULT = new Resultado("mary", null);:}
                       | DIFERENTE {:RESULT = new Resultado("openslae", null);:};

estructura_control ::= if_stmt
                    | while_stmt
                    | for_stmt
                    | switch_stmt;

if_stmt ::= IF PARENTESISAPERTURA expresion PARENTESISCIERRE bloqueEstructura
          | IF PARENTESISAPERTURA expresion PARENTESISCIERRE bloqueEstructura ELSE bloqueEstructura
          | IF PARENTESISAPERTURA error PARENTESISCIERRE bloqueEstructura
          | IF PARENTESISAPERTURA expresion PARENTESISCIERRE error ELSE bloqueEstructura
          | IF PARENTESISAPERTURA error PARENTESISCIERRE bloqueEstructura ELSE bloqueEstructura;

while_stmt ::= WHILE PARENTESISAPERTURA expresion PARENTESISCIERRE bloqueEstructura
             | WHILE PARENTESISAPERTURA error PARENTESISCIERRE bloqueEstructura;

for_stmt ::= FOR PARENTESISAPERTURA declaracion FIN_EXPRESION expresion FIN_EXPRESION expresion PARENTESISCIERRE bloqueEstructura
           | FOR PARENTESISAPERTURA asignacion FIN_EXPRESION expresion FIN_EXPRESION expresion PARENTESISCIERRE bloqueEstructura
           | FOR PARENTESISAPERTURA error PARENTESISCIERRE bloqueEstructura;

switch_stmt ::= SWITCH PARENTESISAPERTURA expresion PARENTESISCIERRE corcheteIzquierdo case_list default_stmt corcheteDerecho
              | SWITCH PARENTESISAPERTURA expresion PARENTESISCIERRE corcheteIzquierdo case_list corcheteDerecho
              | SWITCH PARENTESISAPERTURA error PARENTESISCIERRE corcheteIzquierdo case_list corcheteDerecho
              ;

case_list ::= case_list case_stmt
            | case_stmt
            | case_list error case_stmt;

case_stmt ::= CASE expresion DOS_PUNTOS lista_sentencias
            | CASE error DOS_PUNTOS lista_sentencias
            ;

default_stmt ::= DEFAULT DOS_PUNTOS lista_sentencias
               | DEFAULT error lista_sentencias;


declaracionArreglo ::= tipo:t IDENTIFICADOR:id acceso_arreglo
                      {:
                         Symbol symbol = (Symbol) CUP$parser$stack.peek();
                         parser.agregarVariable(symbol.left, symbol.right, id.toString(), ((Resultado) t).tipo);
                         if (!((Resultado) t).tipo.equals("rodolfo") && !((Resultado) t).tipo.equals("cupido")) {
                             System.err.println("Error semántico en línea " + (symbol.left + 1) + ", columna " + (symbol.right + 1) +
                                                 ": Solo se permiten variables de tipo 'rodolfo' (int) o 'cupido' (char).");
                         }
                      :}
                  | IDENTIFICADOR:id acceso_arreglo
                  | tipo:t IDENTIFICADOR:id acceso_arreglo ASIGNA expresion:e
                  {:
                    Symbol symbol = (Symbol) CUP$parser$stack.peek();
                    parser.agregarVariable(symbol.left, symbol.right, id.toString(), ((Resultado) t).tipo);
                    String tipoExpresion = (e instanceof Resultado)
                        ? ((Resultado) e).tipo
                        : parser.getTipo(parser.listaTablasSimbolos.get(parser.currentHash), e.toString(), symbol.left, symbol.right);
                    if (!((Resultado) t).tipo.equals(tipoExpresion)) {
                        System.err.println("Error semántico en línea " + (symbol.left + 1) + ", columna " + (symbol.right + 1) +
                                           ": Incompatibilidad de tipos. La variable '" + id + "' es de tipo '" + ((Resultado) t).tipo +
                                           "', pero se le asignó una expresión de tipo '" + tipoExpresion + "'.");
                     }
                     if (!((Resultado) t).tipo.equals("rodolfo") && !((Resultado) t).tipo.equals("cupido")) {
                         System.err.println("Error semántico en línea " + (symbol.left + 1) + ", columna " + (symbol.right + 1) +
                                             ": Solo se permiten asignaciones a variables de tipo 'rodolfo' (int) o 'cupido' (char).");
                     }
                  :}
                  | tipo:t IDENTIFICADOR:id acceso_arreglo ASIGNA corcheteIzquierdo parametrosArreglos corcheteDerecho
                    {:
                        Symbol symbol = (Symbol) CUP$parser$stack.peek();
                        parser.agregarVariable(symbol.left, symbol.right, id.toString(), ((Resultado) t).tipo);
                    :}
                  | IDENTIFICADOR:id acceso_arreglo ASIGNA expresion:e
                    {:
                        Symbol symbol = (Symbol) CUP$parser$stack.peek();
                        String tipoExpresion = (e instanceof Resultado)
                            ? ((Resultado) e).tipo
                            : parser.getTipo(parser.listaTablasSimbolos.get(parser.currentHash), e.toString(), symbol.left, symbol.right);
                    :};

parametrosArreglos::= parametrosArreglosAux;

parametrosArreglosAux::= parametrosArreglosAux COMA
                        {:
                            RESULT = new Resultado(",", null);
                        :}
                        expresion:e
                        {:
                            RESULT = e;
                        :}
                   | expresion:e
                        {:
                            RESULT = e;
                        :};

arreglo ::= declaracionArreglo
            {:
                RESULT = null;
            :}
          | arreglo declaracionArreglo
            {:
                RESULT = null;
            :};

acceso_arreglo ::= CORCHETEAPERTURA
                    {:
                        RESULT = new Resultado("abreempaque", null);
                    :}
                    expresion:e
                    {:
                        RESULT = e;
                    :}
                    CORCHETECIERRE
                    {:
                        RESULT = new Resultado("cierraempaque", null);
                    :}
                 | CORCHETEAPERTURA error CORCHETECIERRE
                    {:
                        RESULT = null;
                    :};

parametros ::= lista_parametros
            ;

lista_parametros ::= lista_parametros COMA tipo:t IDENTIFICADOR:id
                    {:
                        Symbol symbol = (Symbol) CUP$parser$stack.peek();
                        parser.agregarVariable(symbol.left, symbol.right, id.toString(), ((Resultado) t).tipo);
                    :}
                    | tipo:t IDENTIFICADOR:id
                    {:
                        Symbol symbol = (Symbol) CUP$parser$stack.peek();
                        parser.agregarVariable(symbol.left, symbol.right, id.toString(), ((Resultado) t).tipo);
                    :}
                    | lista_parametros error tipo IDENTIFICADOR;

llamada_funcion ::= IDENTIFICADOR:id llamada_funcion_aux
    {:
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        int line = symbol.left;
        int column = symbol.right;

        // Construir una tabla global combinada
        ArrayList<String> tablaGlobal = new ArrayList<>();
        parser.listaTablasSimbolos.values().forEach(tabla -> {
            if (tabla != null) tablaGlobal.addAll(tabla);
        });

        // Obtener el tipo de la función
        String tipoFuncion = parser.getTipo(tablaGlobal, id.toString(), line, column);

        if (tipoFuncion.equals("null")) {
            // Si no se encuentra la función, asignar un RESULT con tipo "null"
            System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                               ": La función '" + id + "' no está declarada en ninguna tabla de símbolos.");
            RESULT = new Resultado("null", null);
        } else {
            // Si es válida, asignar el tipo y dejar el temp como null (porque no estamos generando MIPS aún)
            System.out.println("Invocación válida: " + id + " de tipo: " + tipoFuncion);
            RESULT = new Resultado(tipoFuncion, null);
        }
    :};

llamada_funcion_aux ::=  PARENTESISAPERTURA lista_expresiones PARENTESISCIERRE
                      |  PARENTESISAPERTURA PARENTESISCIERRE
                      |  PARENTESISAPERTURA error PARENTESISCIERRE;

lista_expresiones ::= lista_expresiones COMA
                    {:
                    :}
                    expresion:e
                    {:
                        RESULT = e;
                    :}
                   | expresion:e
                    {:
                        RESULT = e;
                    :}
                   | lista_expresiones error expresion:e
                    {:
                        RESULT = e;
                    :};

return_stmt ::= RETURN expresion:e
            {:
                Symbol symbol = (Symbol) CUP$parser$stack.peek();
                int line = symbol.left;
                int column = symbol.right;
                // Obtener el tipo de la función actual usando `currentHash`
                // Verificar si `e` es nulo
                if (e == null) {
                    System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                                       ": El retorno no contiene una expresión válida.");
                } else {
                    // Obtener el tipo y temporal de la expresión de retorno
                    String tipoFuncion = parser.getTipo(parser.listaTablasSimbolos.get(parser.currentHash), parser.currentHash, line, column);
                    Resultado resultadoExpresion = (Resultado) e;
                    String tipoExpresion = resultadoExpresion.tipo;

                    // Comparar los tipos
                    if (!tipoFuncion.equals(tipoExpresion)) {
                        System.err.println("Error semántico en línea " + (line + 1) + ", columna " + (column + 1) +
                                           ": Tipo de retorno (" + tipoExpresion + ") no coincide con el tipo de la función (" + tipoFuncion + ").");
                    }

                    RESULT = new Resultado(tipoExpresion, resultadoExpresion.temp);
                }
            :}
              | RETURN
              | RETURN error;

return_estructura_stmt ::= RETURN expresion
              | RETURN
              | RETURN error;