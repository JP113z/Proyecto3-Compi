package ParserLexer;
import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.HashMap;
import Tree.Arbol;
import Tree.Nodo;

action code {:  :};

parser code {:
    BasicLexerCupV lex;

    private int errorCount = 0;

    private Arbol arbol;


    /**public String getTipo(ArrayList<String> listaTablasSimbolos, String id) {
                    String tipo = "null";
                    for (String token : listaTablasSimbolos) {
                        String[] partesToken = token.split(":");
                        if (id.equals(partesToken[0])) {
                            tipo = partesToken[1];
                            break;
                        }
                    }
                    if (tipo.equals("null")) {
                        System.err.println("Error semántico: Variable " + id + " no declarada.");
                    }
                    System.out.println("tipo: " + tipo);
                    return tipo;
                }*/

    /**
     * Método: getArbol
     * Objetivo: Obtener el arbol.
     * Entradas: Ninguna
     * Salida: El arbol actual.
     */
    public Arbol getArbol() {
        return arbol;
    }
    /**
     * Método: crearNodo
     * Objetivo: Crear un nuevo nodo para el árbol sintáctico con un dato específico.
     * Entradas:
     *   - dato: Cadena de texto que representa el valor asociado al nodo.
     * Salida: Una instancia de la clase Nodo con el dato proporcionado.
     */
    private Nodo crearNodo(String dato) {
        return new Nodo(dato);
    }

    /**
     * Método: syntax_error
     * Objetivo: Manejar los errores sintácticos encontrados durante el análisis sintáctico.
     * Entradas:
     *   - s: Objeto de tipo Symbol que contiene información sobre el error sintáctico, como la posición y el token involucrado.
     * Salida: Ninguna.
     * Restricciones: Se espera que el objeto Symbol contenga información válida de posición y token.
     */
    @Override
    public void syntax_error(Symbol s) {
        errorCount++;
        System.err.println("Error sintáctico en línea " + (s.left + 1) +
                           ", columna " + (s.right + 1) + ". Token inesperado: " + s.value);
    }

    /**
     * Método: hasErrors
     * Objetivo: Verificar si se han registrado errores durante el análisis sintáctico.
     * Entradas: Ninguna.
     * Salida: Booleano que indica si existen errores (true si hay errores, false sino).
     *         Se utiliza en la clase MainJFlexCup para indicar si el archivo puede generarse
     * Restricciones: La variable errorCount debe haber sido correctamente inicializada y actualizada.
     */
    public boolean hasErrors() {
        return errorCount > 0;
    }

    @SuppressWarnings("deprecation")
    public parser(BasicLexerCupV lex) {
        this.lex = lex;
        this.symbolFactory = new DefaultSymbolFactory();
        this.currentHash = null;
        this.arbol = new Arbol();
    }

    // Tabla de símbolos
    HashMap<String, ArrayList<String>> listaTablasSimbolos = new HashMap<>();
    String currentHash;

    /**
     * Método: imprimirTablaSimbolos
     * Objetivo: Imprimir todas las tablas de símbolos almacenadas, mostrando el contenido de cada tabla en un formato tabular.
     * Entradas: Ninguna.
     * Salida: Se llama en MainJFlexCup para imprimir en la consola el contenido de las tablas de símbolos.
     * Detalles:
     *   - Cada tabla está asociada a una clave (nombre de la función o el main).
     *   - Se imprime una tabla separada para cada clave con columnas que incluyen línea, columna, lexema y tipo.
     * Restricciones: Se espera que la estructura `listaTablasSimbolos` esté correctamente inicializada y contenga las claves y los valores correspondientes.
     */
    public void imprimirTablaSimbolos() {
        for (String key : listaTablasSimbolos.keySet()) {
            System.out.println("\nTabla de símbolos: " + key);
            System.out.println("+--------+---------+----------------------+------------+");
            System.out.println("| Línea  | Columna | Lexema              | Tipo       |");
            System.out.println("+--------+---------+----------------------+------------+");
            for (String simbolo : listaTablasSimbolos.get(key)) {
                System.out.println(simbolo);
            }
            System.out.println("+--------+---------+----------------------+------------+\n");
        }
    }

    /**
     * Método: agregarTablaSimbolos
     * Objetivo: Crear una nueva tabla de símbolos asociada a una función o al main y agregarla al mapa de tablas de símbolos.
     * Entradas:
     *   - tipoTabla: Tipo de la tabla ("función" o "main").
     *   - nombre: Nombre asociado a la tabla (El nombre de la función o "_verano_" que es el token asociado a main).
     * Salida: Ninguna.
     * Detalles:
     *   - Se inicializa una nueva tabla de símbolos como una lista de cadenas.
     *   - Se guarda en el mapa `listaTablasSimbolos` con el nombre como clave.
     *   - `currentHash` se actualiza para indicar que la tabla activa es la recién creada.
     * Restricciones:
     *   - El nombre de la tabla debe ser único para evitar sobrescribir tablas existentes.
     */
    public void agregarTablaSimbolos(String tipoTabla, String nombre) {
        System.out.println("/+++Nueva tabla símbolos función o main+++/ " + nombre);
        ArrayList<String> nuevaTabla = new ArrayList<>();
        currentHash = nombre;
        listaTablasSimbolos.put(currentHash, nuevaTabla);
    }

    /**
     * Método: agregarVariable
     * Objetivo: Agregar una nueva variable a la tabla de símbolos activa, registrando su línea, columna, lexema y tipo.
     * Entradas:
     *   - linea: Número de línea donde se encuentra la variable.
     *   - columna: Número de columna donde se encuentra la variable.
     *   - lexema: Nombre o representación textual de la variable.
     *   - tipo: Tipo de la variable
     * Salida: Ninguna.
     * Detalles:
     *   - Verifica que haya una tabla de símbolos activa (`currentHash`) y que esta exista en el mapa `listaTablasSimbolos`.
     *   - Si no hay tabla activa o no existe, se imprime un mensaje de error.
     *   - Si todo es válido, formatea la información de la variable en una tabla y la agrega a la tabla de símbolos activa.
     * Restricciones:
     *   - Debe existir una tabla de símbolos activa antes de llamar a este método.
     *   - La línea, columna, lexema y tipo deben ser datos válidos y coherentes con el análisis.
     */
    public void agregarVariable(int linea, int columna, String lexema, String tipo) {
        System.out.println("PARSER: identificador (agregar o verificar) " + lexema);
        if (currentHash == null) {
            System.err.println("Error: No hay una tabla de símbolos activa, linea: " + linea + " clumna:" + columna + " lexema perdido: " + lexema + " tipo: " + tipo);
            return;
        }
        ArrayList<String> tabla = listaTablasSimbolos.get(currentHash);
        if (tabla == null) {
            System.err.println("Error: La tabla de símbolos '" + currentHash + "' no existe");
            return;
        }
        String entrada = String.format("| %-6d | %-7d | %-20s | %-10s |",
                linea + 1, columna + 1, lexema, tipo);
        tabla.add(entrada);
    }
:}

init with {: :};

scan with {: return lex.next_token(); :};

/* Terminales */
terminal MAIN, INTEGER, STRING, FLOAT, BOOL, CHAR;
terminal L_INTEGER, L_FLOAT, L_STRING, L_CHAR;
terminal COMA, IDENTIFICADOR, corcheteIzquierdo, corcheteDerecho, CORCHETEAPERTURA, CORCHETECIERRE, TRUE, FALSE, ASIGNA, PARENTESISAPERTURA, PARENTESISCIERRE,
INCREMENTO, DECREMENTO, NEGATIVO, MENOR, MENOR_IGUAL, MAYOR, MAYOR_IGUAL, IGUAL, DIFERENTE, CONJUNCION, DISYUNCION, NEGACION, FIN_EXPRESION, IF, ELSE, WHILE, FOR, SWITCH, CASE, DEFAULT, BREAK, RETURN,
DOS_PUNTOS, PRINT, READ,SUMA, RESTA, DIVISION, MULTIPLICACION, MODULO, POTENCIA;

/* No terminales */
non terminal programa, declaracion_main, bloque, lista_sentencias, sentencia, declaracion, asignacion, expresion, tipo, literal, operador_binario,
operador_unario, operador_logico, operador_relacional, estructura_control, if_stmt, while_stmt, for_stmt, switch_stmt,  case_list, case_stmt, default_stmt,
lista_expresiones,  arreglo, acceso_arreglo, llamada_funcion, declaracion_funcion, parametros, lista_parametros, return_stmt, funcion, lista_funciones, declaracionArreglo, parametrosArreglos,
parametrosArreglosAux, bloqueEstructura, cabecera_main, cabecera_funcion;

/* Precedencias */
precedence right error;
precedence left FIN_EXPRESION;
precedence left DISYUNCION;
precedence left CONJUNCION;
precedence right NEGACION;
precedence nonassoc MENOR, MENOR_IGUAL, MAYOR, MAYOR_IGUAL, IGUAL, DIFERENTE;
precedence left SUMA, RESTA;
precedence left MULTIPLICACION, DIVISION, MODULO;
precedence right POTENCIA;
precedence right NEGATIVO;
precedence right INCREMENTO, DECREMENTO;

/* Reglas de producción con manejo de errores */
start with programa;

programa ::= lista_funciones
          | error lista_funciones
          | lista_funciones error;

lista_funciones ::= lista_funciones:lf funcion:f {: :}
                 | funcion:f {: :}
                 | lista_funciones error funcion;

funcion ::= cabecera_funcion:df {: :}
          | cabecera_main:dm {: :}
          | error bloque;

declaracion_main ::= PARENTESISAPERTURA PARENTESISCIERRE bloque
                  |  PARENTESISAPERTURA error PARENTESISCIERRE bloque
                  ;

cabecera_main ::= tipo:t MAIN
                {:
                    parser.agregarTablaSimbolos("main", "_verano_");
                    parser.agregarVariable(0, 0, "main", t.toString());
                :} declaracion_main
                | error MAIN PARENTESISAPERTURA PARENTESISCIERRE bloque
                ;

declaracion_funcion ::= PARENTESISAPERTURA parametros:p PARENTESISCIERRE bloque:b
                     | PARENTESISAPERTURA PARENTESISCIERRE bloque:b
                     | PARENTESISAPERTURA error PARENTESISCIERRE bloque;


cabecera_funcion ::= tipo:t IDENTIFICADOR:id
                   {:
                       Symbol symbol = (Symbol) CUP$parser$stack.peek();
                       parser.agregarTablaSimbolos("funcion", id.toString());
                       parser.agregarVariable(symbol.left, symbol.right, id.toString(), t.toString());
                   :} declaracion_funcion
                   | error IDENTIFICADOR PARENTESISAPERTURA parametros PARENTESISCIERRE bloque;

bloque ::= corcheteIzquierdo lista_sentencias return_stmt FIN_EXPRESION corcheteDerecho
         | corcheteIzquierdo return_stmt FIN_EXPRESION corcheteDerecho
         | corcheteIzquierdo error corcheteDerecho;

bloqueEstructura::=corcheteIzquierdo corcheteDerecho
                  | corcheteIzquierdo lista_sentencias return_stmt FIN_EXPRESION corcheteDerecho
                  | corcheteIzquierdo lista_sentencias corcheteDerecho
                  | corcheteIzquierdo return_stmt FIN_EXPRESION corcheteDerecho
                  | error;

lista_sentencias ::= lista_sentencias sentencia
                  | sentencia
                  | error {: System.err.println("Error en una setencia."); :};

sentencia ::= declaracion FIN_EXPRESION
            | asignacion FIN_EXPRESION
            | estructura_control
            | expresion FIN_EXPRESION
            | BREAK FIN_EXPRESION
 //           | return_stmt FIN_EXPRESION
            | PRINT PARENTESISAPERTURA expresion PARENTESISCIERRE FIN_EXPRESION
            | READ PARENTESISAPERTURA IDENTIFICADOR PARENTESISCIERRE FIN_EXPRESION
            | error FIN_EXPRESION
            ;

declaracion ::= tipo:t IDENTIFICADOR:id
    {:
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, id.toString(), t.toString());
    :}
    | tipo:t IDENTIFICADOR:id ASIGNA expresion
    {:
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, id.toString(), t.toString());
    :}
    | arreglo
    | tipo error;

tipo ::= INTEGER
    {:
        RESULT = "rodolfo";
    :}
    | STRING
    {:
        RESULT = "cometa";
    :}
    | CHAR
    {:
        RESULT = "cupido";
    :}
    | FLOAT
    {:
        RESULT = "bromista";
    :}
    | BOOL
    {:
        RESULT = "trueno";
    :};

asignacion ::= IDENTIFICADOR ASIGNA expresion
             | IDENTIFICADOR ASIGNA error
             | error;


expresion ::= literal
         | IDENTIFICADOR
         | llamada_funcion
         | expresion operador_unario
         | expresion operador_binario expresion
         | expresion operador_relacional expresion
         | expresion operador_logico expresion
         | NEGACION expresion
         | PARENTESISAPERTURA{: RESULT = "abreregalo"; :}
          expresion
          PARENTESISCIERRE{: RESULT = "cierraregalo"; :}
         | PARENTESISAPERTURA error PARENTESISCIERRE;

literal ::= L_INTEGER:i
    {:
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, symbol.value.toString(), "rodolfo");
        RESULT = "rodolfo";
    :}
    | L_FLOAT:f
    {:
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, symbol.value.toString(), "bromista");
        RESULT = "bromista";
    :}
    | L_STRING:s
    {:
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, symbol.value.toString(), "cometa");
        RESULT = "cometa";
    :}
    | L_CHAR:c
    {:
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, symbol.value.toString(), "cupido");
        RESULT = "cupido";
    :}
    | TRUE{:RESULT = "true";:}
    | FALSE{:RESULT = "false";:};

operador_binario ::= SUMA {:RESULT="navidad";:}
                 | RESTA {:RESULT="intercambio";:}
                 | DIVISION {:RESULT="reyes";:}
                 | MULTIPLICACION {:RESULT="nochebuena";:}
                 | MODULO {:RESULT="magos";:}
                 | POTENCIA {:RESULT="adviento";:};

operador_unario ::= INCREMENTO {:RESULT="quien";:}
                  | DECREMENTO {:RESULT="grinch";:}
                  | NEGATIVO {:RESULT="-";:};

operador_logico ::=  CONJUNCION {:RESULT="melchor";:}
                  | DISYUNCION {:RESULT="gaspar";:}
                  | NEGACION {:RESULT="baltazar";:};

operador_relacional ::= MENOR {:RESULT="snowball";:}
                       | MENOR_IGUAL {:RESULT="evergreen";:}
                       | MAYOR {:RESULT="minstix";:}
                       | MAYOR_IGUAL {:RESULT="upatree";:}
                       | IGUAL {:RESULT="mary";:}
                       | DIFERENTE {:RESULT="openslae";:};

estructura_control ::= if_stmt
                    | while_stmt
                    | for_stmt
                    | switch_stmt;

if_stmt ::= IF PARENTESISAPERTURA expresion PARENTESISCIERRE bloqueEstructura
          | IF PARENTESISAPERTURA expresion PARENTESISCIERRE bloqueEstructura ELSE bloqueEstructura
          | IF PARENTESISAPERTURA error PARENTESISCIERRE bloqueEstructura
          | IF PARENTESISAPERTURA expresion PARENTESISCIERRE error ELSE bloqueEstructura
          | IF PARENTESISAPERTURA error PARENTESISCIERRE bloqueEstructura ELSE bloqueEstructura;

while_stmt ::= WHILE PARENTESISAPERTURA expresion PARENTESISCIERRE bloqueEstructura
             | WHILE PARENTESISAPERTURA error PARENTESISCIERRE bloqueEstructura;

for_stmt ::= FOR PARENTESISAPERTURA declaracion FIN_EXPRESION expresion FIN_EXPRESION expresion PARENTESISCIERRE bloqueEstructura
           | FOR PARENTESISAPERTURA asignacion FIN_EXPRESION expresion FIN_EXPRESION expresion PARENTESISCIERRE bloqueEstructura
           | FOR PARENTESISAPERTURA error PARENTESISCIERRE bloqueEstructura;

switch_stmt ::= SWITCH PARENTESISAPERTURA expresion PARENTESISCIERRE corcheteIzquierdo case_list default_stmt corcheteDerecho
              | SWITCH PARENTESISAPERTURA expresion PARENTESISCIERRE corcheteIzquierdo case_list corcheteDerecho
              | SWITCH PARENTESISAPERTURA error PARENTESISCIERRE corcheteIzquierdo case_list corcheteDerecho
              ;

case_list ::= case_list case_stmt
            | case_stmt
            | case_list error case_stmt;

case_stmt ::= CASE expresion DOS_PUNTOS lista_sentencias
            | CASE error DOS_PUNTOS lista_sentencias
            ;

default_stmt ::= DEFAULT DOS_PUNTOS lista_sentencias
               | DEFAULT error lista_sentencias;


declaracionArreglo ::= tipo:t IDENTIFICADOR:id acceso_arreglo
{:
    Symbol symbol = (Symbol) CUP$parser$stack.peek();
    parser.agregarVariable(symbol.left, symbol.right, id.toString(), t.toString());
:}
                  | IDENTIFICADOR:id acceso_arreglo
                  | tipo:t IDENTIFICADOR:id acceso_arreglo ASIGNA expresion
{:
    Symbol symbol = (Symbol) CUP$parser$stack.peek();
    parser.agregarVariable(symbol.left, symbol.right, id.toString(), t.toString());
:}
                  | tipo:t IDENTIFICADOR:id acceso_arreglo ASIGNA corcheteIzquierdo parametrosArreglos corcheteDerecho
{:
    Symbol symbol = (Symbol) CUP$parser$stack.peek();
    parser.agregarVariable(symbol.left, symbol.right, id.toString(), t.toString());
:}
                  | IDENTIFICADOR:id acceso_arreglo ASIGNA expresion;

 parametrosArreglos::= parametrosArreglosAux;

parametrosArreglosAux::= parametrosArreglosAux COMA{: RESULT = ","; :}
                   expresion
                   | expresion;

arreglo ::=declaracionArreglo
          |arreglo declaracionArreglo ;

acceso_arreglo ::=  CORCHETEAPERTURA{: RESULT = "abreempaque"; :}
                    expresion
                    CORCHETECIERRE{: RESULT = "cierraempaque"; :}
                 | CORCHETEAPERTURA error CORCHETECIERRE;

parametros ::= lista_parametros
            ;

lista_parametros ::= lista_parametros COMA tipo:t IDENTIFICADOR:id
                    {:
                        Symbol symbol = (Symbol) CUP$parser$stack.peek();
                        parser.agregarVariable(symbol.left, symbol.right, id.toString(), t.toString());
                    :}
                    | tipo:t IDENTIFICADOR:id
                    {:
                        Symbol symbol = (Symbol) CUP$parser$stack.peek();
                        parser.agregarVariable(symbol.left, symbol.right, id.toString(), t.toString());
                    :}
                    | lista_parametros error tipo IDENTIFICADOR;

llamada_funcion ::= IDENTIFICADOR PARENTESISAPERTURA lista_expresiones PARENTESISCIERRE
                  | IDENTIFICADOR PARENTESISAPERTURA PARENTESISCIERRE
                  | IDENTIFICADOR PARENTESISAPERTURA error PARENTESISCIERRE;

lista_expresiones ::= lista_expresiones COMA{: RESULT = ","; :}
                    expresion
                   | expresion
                   | lista_expresiones error expresion;

return_stmt ::= RETURN expresion
              | RETURN
              | RETURN error;