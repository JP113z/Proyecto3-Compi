package ParserLexer;
import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.HashMap;
import Tree.Arbol;
import Tree.Nodo;

action code {:  :};

parser code {:
    BasicLexerCupV lex;

    private int errorCount = 0;

    private Arbol arbol;

    private int bloqueActual = 0;

    public String getTipo(ArrayList<String> listaTablasSimbolos, String id) {
        if (listaTablasSimbolos == null) {
            System.err.println("Error semántico: La tabla de símbolos está vacía o no inicializada.");
            return "null";
        }
        String tipo = "null";

        for (String token : listaTablasSimbolos) {
            // Divide el token en columnas usando "|" como delimitador
            String[] partesToken = token.split("\\|");
            if (partesToken.length < 5) { // Verifica que haya al menos 5 columnas
                System.err.println("Formato inválido en token: " + token);
                continue;
            }
            String lexema = partesToken[3].trim(); // Columna "Lexema"
            String tipoEncontrado = partesToken[4].trim(); // Columna "Tipo"

            // Compara el lexema con el id que estamos buscando
            if (id.equals(lexema)) {
                tipo = tipoEncontrado;
               // System.out.println("Identificador encontrado. Tipo: " + tipo);
                break;
            }
        }

        if (tipo.equals("null")) {
            System.err.println("Error semántico: Identificador '" + id + "' no está declarado.");
        }

        return tipo;
    }

    /**
     * Método: getArbol
     * Objetivo: Obtener el arbol.
     * Entradas: Ninguna
     * Salida: El arbol actual.
     */
    public Arbol getArbol() {
        return arbol;
    }
    /**
     * Método: crearNodo
     * Objetivo: Crear un nuevo nodo para el árbol sintáctico con un dato específico.
     * Entradas:
     *   - dato: Cadena de texto que representa el valor asociado al nodo.
     * Salida: Una instancia de la clase Nodo con el dato proporcionado.
     */
    private Nodo crearNodo(String dato) {
        return new Nodo(dato);
    }

    /**
     * Método: syntax_error
     * Objetivo: Manejar los errores sintácticos encontrados durante el análisis sintáctico.
     * Entradas:
     *   - s: Objeto de tipo Symbol que contiene información sobre el error sintáctico, como la posición y el token involucrado.
     * Salida: Ninguna.
     * Restricciones: Se espera que el objeto Symbol contenga información válida de posición y token.
     */
    @Override
    public void syntax_error(Symbol s) {
        errorCount++;
        System.err.println("Error sintáctico en línea " + (s.left + 1) +
                           ", columna " + (s.right + 1) + ". Token inesperado: " + s.value);
    }

    /**
     * Método: hasErrors
     * Objetivo: Verificar si se han registrado errores durante el análisis sintáctico.
     * Entradas: Ninguna.
     * Salida: Booleano que indica si existen errores (true si hay errores, false sino).
     *         Se utiliza en la clase MainJFlexCup para indicar si el archivo puede generarse
     * Restricciones: La variable errorCount debe haber sido correctamente inicializada y actualizada.
     */
    public boolean hasErrors() {
        return errorCount > 0;
    }

    @SuppressWarnings("deprecation")
    public parser(BasicLexerCupV lex) {
        this.lex = lex;
        this.symbolFactory = new DefaultSymbolFactory();
        this.currentHash = null;
        this.arbol = new Arbol();
    }

    // Tabla de símbolos
    HashMap<String, ArrayList<String>> listaTablasSimbolos = new HashMap<>();
    String currentHash;

    /**
     * Método: imprimirTablaSimbolos
     * Objetivo: Imprimir todas las tablas de símbolos almacenadas, mostrando el contenido de cada tabla en un formato tabular.
     * Entradas: Ninguna.
     * Salida: Se llama en MainJFlexCup para imprimir en la consola el contenido de las tablas de símbolos.
     * Detalles:
     *   - Cada tabla está asociada a una clave (nombre de la función o el main).
     *   - Se imprime una tabla separada para cada clave con columnas que incluyen línea, columna, lexema y tipo.
     * Restricciones: Se espera que la estructura `listaTablasSimbolos` esté correctamente inicializada y contenga las claves y los valores correspondientes.
     */
    public void imprimirTablaSimbolos() {
        for (String key : listaTablasSimbolos.keySet()) {
            System.out.println("\nTabla de símbolos: " + key);
            System.out.println("+--------+---------+----------------------+------------+-----------+");
            System.out.println("| Línea  | Columna | Lexema              | Tipo       | Bloque    |");
            System.out.println("+--------+---------+----------------------+------------+-----------+");
            for (String simbolo : listaTablasSimbolos.get(key)) {
                System.out.println(simbolo);
            }
            System.out.println("+--------+---------+----------------------+------------+-----------+\n");
        }
    }

    /**
     * Método: agregarTablaSimbolos
     * Objetivo: Crear una nueva tabla de símbolos asociada a una función o al main y agregarla al mapa de tablas de símbolos.
     * Entradas:
     *   - tipoTabla: Tipo de la tabla ("función" o "main").
     *   - nombre: Nombre asociado a la tabla (El nombre de la función o "_verano_" que es el token asociado a main).
     * Salida: Ninguna.
     * Detalles:
     *   - Se inicializa una nueva tabla de símbolos como una lista de cadenas.
     *   - Se guarda en el mapa `listaTablasSimbolos` con el nombre como clave.
     *   - `currentHash` se actualiza para indicar que la tabla activa es la recién creada.
     * Restricciones:
     *   - El nombre de la tabla debe ser único para evitar sobrescribir tablas existentes.
     */
    public void agregarTablaSimbolos(String tipoTabla, String nombre) {
        System.out.println("/+++Nueva tabla símbolos función o main+++/ " + nombre);
        ArrayList<String> nuevaTabla = new ArrayList<>();
        currentHash = nombre;
        bloqueActual = 1;
        listaTablasSimbolos.put(currentHash, nuevaTabla);
    }

    /**
     * Método: agregarVariable
     * Objetivo: Agregar una nueva variable a la tabla de símbolos activa, registrando su línea, columna, lexema y tipo.
     * Entradas:
     *   - linea: Número de línea donde se encuentra la variable.
     *   - columna: Número de columna donde se encuentra la variable.
     *   - lexema: Nombre o representación textual de la variable.
     *   - tipo: Tipo de la variable
     * Salida: Ninguna.
     * Detalles:
     *   - Verifica que haya una tabla de símbolos activa (`currentHash`) y que esta exista en el mapa `listaTablasSimbolos`.
     *   - Si no hay tabla activa o no existe, se imprime un mensaje de error.
     *   - Si todo es válido, formatea la información de la variable en una tabla y la agrega a la tabla de símbolos activa.
     * Restricciones:
     *   - Debe existir una tabla de símbolos activa antes de llamar a este método.
     *   - La línea, columna, lexema y tipo deben ser datos válidos y coherentes con el análisis.
     */
    public void agregarVariable(int linea, int columna, String lexema, String tipo) {
        System.out.println("PARSER: identificador (agregar o verificar) " + lexema);
        if (currentHash == null) {
            System.err.println("Error: No hay una tabla de símbolos activa");
            return;
        }
        ArrayList<String> tabla = listaTablasSimbolos.get(currentHash);
        if (tabla == null) {
            System.err.println("Error: La tabla de símbolos '" + currentHash + "' no existe");
            return;
        }
        String entrada = String.format("| %-6d | %-7d | %-20s | %-10s | Bloque %-3d |",
                linea + 1, columna + 1, lexema, tipo, bloqueActual);
        tabla.add(entrada);
    }
:}

init with {: :};

scan with {: return lex.next_token(); :};

/* Terminales */
terminal MAIN, INTEGER, STRING, FLOAT, BOOL, CHAR;
terminal L_INTEGER, L_FLOAT, L_STRING, L_CHAR;
terminal COMA, IDENTIFICADOR, corcheteIzquierdo, corcheteDerecho, CORCHETEAPERTURA, CORCHETECIERRE, TRUE, FALSE, ASIGNA, PARENTESISAPERTURA, PARENTESISCIERRE,
INCREMENTO, DECREMENTO, NEGATIVO, MENOR, MENOR_IGUAL, MAYOR, MAYOR_IGUAL, IGUAL, DIFERENTE, CONJUNCION, DISYUNCION, NEGACION, FIN_EXPRESION, IF, ELSE, WHILE, FOR, SWITCH, CASE, DEFAULT, BREAK, RETURN,
DOS_PUNTOS, PRINT, READ,SUMA, RESTA, DIVISION, MULTIPLICACION, MODULO, POTENCIA;

/* No terminales */
non terminal programa, declaracion_main, bloque, lista_sentencias, sentencia, declaracion, asignacion, expresion, tipo, literal, operador_binario,
operador_unario, operador_logico, operador_relacional, estructura_control, if_stmt, while_stmt, for_stmt, switch_stmt,  case_list, case_stmt, default_stmt,
lista_expresiones,  arreglo, acceso_arreglo, llamada_funcion, declaracion_funcion, parametros, lista_parametros, return_stmt, funcion, lista_funciones, declaracionArreglo, parametrosArreglos,
parametrosArreglosAux, bloqueEstructura, cabecera_main, cabecera_funcion, contenido_estructura_control, llamada_funcion_aux;

/* Precedencias */
precedence right error;
precedence left FIN_EXPRESION;
precedence left DISYUNCION;
precedence left CONJUNCION;
precedence right NEGACION;
precedence nonassoc MENOR, MENOR_IGUAL, MAYOR, MAYOR_IGUAL, IGUAL, DIFERENTE;
precedence left SUMA, RESTA;
precedence left MULTIPLICACION, DIVISION, MODULO;
precedence right POTENCIA;
precedence right NEGATIVO;
precedence right INCREMENTO, DECREMENTO;

/* Reglas de producción con manejo de errores */
start with programa;

programa ::= lista_funciones
          | error lista_funciones
          | lista_funciones error;

lista_funciones ::= lista_funciones:lf funcion:f {: :}
                 | funcion:f {: :}
                 | lista_funciones error funcion;

funcion ::= cabecera_funcion:df {: :}
          | cabecera_main:dm {: :}
          | error bloque;

declaracion_main ::= PARENTESISAPERTURA PARENTESISCIERRE bloque
                  |  PARENTESISAPERTURA error PARENTESISCIERRE bloque
                  ;

cabecera_main ::= tipo:t MAIN
                {:
                    parser.agregarTablaSimbolos("main", "_verano_");
                    parser.agregarVariable(0, 0, "main", t.toString());
                :} declaracion_main
                | error MAIN PARENTESISAPERTURA PARENTESISCIERRE bloque
                ;

declaracion_funcion ::= PARENTESISAPERTURA parametros:p PARENTESISCIERRE bloque:b
                     | PARENTESISAPERTURA PARENTESISCIERRE bloque:b
                     | PARENTESISAPERTURA error PARENTESISCIERRE bloque;


cabecera_funcion ::= tipo:t IDENTIFICADOR:id
                   {:
                       Symbol symbol = (Symbol) CUP$parser$stack.peek();
                       parser.agregarTablaSimbolos("funcion", id.toString());
                       parser.agregarVariable(symbol.left, symbol.right, id.toString(), t.toString());
                   :} declaracion_funcion
                   | error IDENTIFICADOR PARENTESISAPERTURA parametros PARENTESISCIERRE bloque;

bloque ::= corcheteIzquierdo
        {:
            parser.bloqueActual++;
        :}
        lista_sentencias return_stmt FIN_EXPRESION corcheteDerecho
        | corcheteIzquierdo
        {:
            parser.bloqueActual++;
        :}
        return_stmt FIN_EXPRESION corcheteDerecho
        | corcheteIzquierdo error corcheteDerecho;

bloqueEstructura ::= corcheteIzquierdo
                    {:
                        parser.bloqueActual++;
                    :}
                    contenido_estructura_control
                  | corcheteIzquierdo error corcheteDerecho;

contenido_estructura_control ::= corcheteDerecho
                             | lista_sentencias corcheteDerecho
                             | lista_sentencias return_stmt FIN_EXPRESION corcheteDerecho
                             | return_stmt FIN_EXPRESION corcheteDerecho;

lista_sentencias ::= lista_sentencias sentencia
                  | sentencia
                  | error {: System.err.println("Error en una sentencia."); :};

sentencia ::= declaracion FIN_EXPRESION
            | asignacion FIN_EXPRESION
            | estructura_control
            | expresion FIN_EXPRESION
            | BREAK FIN_EXPRESION
            | PRINT PARENTESISAPERTURA expresion PARENTESISCIERRE FIN_EXPRESION
            | READ PARENTESISAPERTURA IDENTIFICADOR PARENTESISCIERRE FIN_EXPRESION
            | error FIN_EXPRESION
            ;

declaracion ::= tipo:t IDENTIFICADOR:id
    {:
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, id.toString(), t.toString());
    :}
    | tipo:t IDENTIFICADOR:id ASIGNA expresion:e
    {:
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, id.toString(), t.toString());
        // Verificar que el tipo de la expresión sea compatible con el tipo de la variable
        String tipoExpresion = e.toString();
        if (!t.toString().equals(tipoExpresion)) {
            System.err.println("Error semántico: Tipo incompatible en asignación. Variable '" + id +
                                       "' es de tipo " + t + ", pero se le asignó un valor de tipo " + tipoExpresion + ".");
        }
    :}
    | arreglo
    | tipo error;

tipo ::= INTEGER{:RESULT = "rodolfo";:}
    | STRING{:RESULT = "cometa";:}
    | CHAR{:RESULT = "cupido";:}
    | FLOAT{:RESULT = "bromista";:}
    | BOOL{:RESULT = "trueno";:};

asignacion ::= IDENTIFICADOR ASIGNA expresion
             | IDENTIFICADOR ASIGNA error
             | error;


expresion ::= literal:e {: RESULT = e; :}
         | IDENTIFICADOR:e {:
                          String tipo = parser.getTipo(parser.listaTablasSimbolos.get(parser.currentHash), e.toString());
                          RESULT = tipo;
                      :}
         | llamada_funcion:f {: RESULT = f; :}
         | expresion:e1 operador_unario:op {:
             // Validar tipos para operadores unarios
             String tipo = (e1 instanceof String) ? e1.toString() : parser.getTipo(listaTablasSimbolos.get(currentHash), e1.toString());
             if (op.toString().equals("quien") || op.toString().equals("grinch")) {
                 if (!tipo.equals("rodolfo")) {
                     System.err.println("Error semántico: Incremento/Decremento solo aplica a enteros (rodolfo).");
                 }
             } else if (op.toString().equals("-") && !tipo.equals("rodolfo") && !tipo.equals("bromista")) {
                 System.err.println("Error semántico: Negación solo aplica a enteros o flotantes.");
             }
             RESULT = tipo;
         :}
         | expresion:e1 operador_binario:op expresion:e2
           {:
           // Obtener el tipo de ambos operandos
           String tipo1 = (e1 instanceof String) ? e1.toString() : parser.getTipo(listaTablasSimbolos.get(currentHash), e1.toString());
           String tipo2 = (e2 instanceof String) ? e2.toString() : parser.getTipo(listaTablasSimbolos.get(currentHash), e2.toString());
           // Validar los tipos de los operandos
           if ((!tipo1.equals("rodolfo") && !tipo1.equals("bromista")) ||
               (!tipo2.equals("rodolfo") && !tipo2.equals("bromista"))) {
               System.err.println("Error semántico: Operandos deben ser enteros (rodolfo) o flotantes (bromista).");
           } else if (!tipo1.equals(tipo2)) {
               System.err.println("Error semántico: Tipos incompatibles entre los operandos. Operando 1: " + tipo1 + ", Operando 2: " + tipo2);
           }
           // Definir el tipo resultante
           String tipoResultado = tipo1.equals("bromista") ? "bromista" : "rodolfo";
           RESULT = tipoResultado;
           :}
         | expresion:e1 operador_relacional:op expresion:e2
             {:
             // Obtener el tipo de ambos operandos
             String tipo1 = (e1 instanceof String) ? e1.toString() : parser.getTipo(listaTablasSimbolos.get(currentHash), e1.toString());
             String tipo2 = (e2 instanceof String) ? e2.toString() : parser.getTipo(listaTablasSimbolos.get(currentHash), e2.toString());
             // Validar los tipos de los operandos
             if (op.toString().equals("mary") || op.toString().equals("openslae")) {
                 // Para `mary` y `openslae`, los tipos pueden ser enteros, flotantes o booleanos
                 if ((!tipo1.equals("rodolfo") && !tipo1.equals("bromista") && !tipo1.equals("trueno")) ||
                     (!tipo2.equals("rodolfo") && !tipo2.equals("bromista") && !tipo2.equals("trueno"))) {
                     System.err.println("Error semántico: Operadores '" + op + "' solo admiten enteros (rodolfo), flotantes (bromista) o booleanos (trueno).");
                 } else if (!tipo1.equals(tipo2)) {
                     System.err.println("Error semántico: Tipos incompatibles para operador '" + op + "'. Operando 1: " + tipo1 + ", Operando 2: " + tipo2);
                 } else {
                     RESULT = "trueno";
                 }
             } else {
                 // Validación para otros operadores relacionales
                 if ((!tipo1.equals("rodolfo") && !tipo1.equals("bromista")) ||
                     (!tipo2.equals("rodolfo") && !tipo2.equals("bromista"))) {
                     System.err.println("Error semántico: Operadores '" + op + "' solo admiten enteros (rodolfo) o flotantes (bromista).");
                 } else if (!tipo1.equals(tipo2)) {
                     System.err.println("Error semántico: Tipos incompatibles entre los operandos. Operando 1: " + tipo1 + ", Operando 2: " + tipo2);
                 } else {
                     RESULT = "trueno";
                 }
             }
             :}
         | expresion:e1 operador_logico:op expresion:e2
           {:
           // Verificar que ambos operandos sean booleanos
           String tipo1 = parser.getTipo(listaTablasSimbolos.get(currentHash), e1.toString());
           String tipo2 = parser.getTipo(listaTablasSimbolos.get(currentHash), e2.toString());

           if (!tipo1.equals("trueno") || !tipo2.equals("trueno")) {
               System.err.println("Error semántico: Operadores lógicos requieren valores booleanos (trueno).");
           }
           RESULT = "trueno";
           :}
         | NEGACION expresion:e
           {:
           // Verificar que el operando sea booleano
           String tipo = parser.getTipo(listaTablasSimbolos.get(currentHash), e.toString());

           if (!tipo.equals("trueno")) {
               System.err.println("Error semántico: La negación requiere un valor booleano (trueno).");
           }
           RESULT = "trueno";
           :}
         | PARENTESISAPERTURA expresion:e PARENTESISCIERRE {: RESULT = e; :}
         | PARENTESISAPERTURA error PARENTESISCIERRE;

literal ::= L_INTEGER:i
    {:
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, symbol.value.toString(), "rodolfo");
        RESULT = "rodolfo";
    :}
    | L_FLOAT:f
    {:
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, symbol.value.toString(), "bromista");
        RESULT = "bromista";
    :}
    | L_STRING:s
    {:
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, symbol.value.toString(), "cometa");
        RESULT = "cometa";
    :}
    | L_CHAR:c
    {:
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, symbol.value.toString(), "cupido");
        RESULT = "cupido";
    :}
    | TRUE{:RESULT = "true";:}
    | FALSE{:RESULT = "false";:};

operador_binario ::= SUMA {:RESULT="navidad";:}
                 | RESTA {:RESULT="intercambio";:}
                 | DIVISION {:RESULT="reyes";:}
                 | MULTIPLICACION {:RESULT="nochebuena";:}
                 | MODULO {:RESULT="magos";:}
                 | POTENCIA {:RESULT="adviento";:};

operador_unario ::= INCREMENTO {:RESULT="quien";:}
                  | DECREMENTO {:RESULT="grinch";:}
                  | NEGATIVO {:RESULT="-";:};

operador_logico ::=  CONJUNCION {:RESULT="melchor";:}
                  | DISYUNCION {:RESULT="gaspar";:}
                  | NEGACION {:RESULT="baltazar";:};

operador_relacional ::= MENOR {:RESULT="snowball";:}
                       | MENOR_IGUAL {:RESULT="evergreen";:}
                       | MAYOR {:RESULT="minstix";:}
                       | MAYOR_IGUAL {:RESULT="upatree";:}
                       | IGUAL {:RESULT="mary";:}
                       | DIFERENTE {:RESULT="openslae";:};

estructura_control ::= if_stmt
                    | while_stmt
                    | for_stmt
                    | switch_stmt;

if_stmt ::= IF PARENTESISAPERTURA expresion PARENTESISCIERRE bloqueEstructura
          | IF PARENTESISAPERTURA expresion PARENTESISCIERRE bloqueEstructura ELSE bloqueEstructura
          | IF PARENTESISAPERTURA error PARENTESISCIERRE bloqueEstructura
          | IF PARENTESISAPERTURA expresion PARENTESISCIERRE error ELSE bloqueEstructura
          | IF PARENTESISAPERTURA error PARENTESISCIERRE bloqueEstructura ELSE bloqueEstructura;

while_stmt ::= WHILE PARENTESISAPERTURA expresion PARENTESISCIERRE bloqueEstructura
             | WHILE PARENTESISAPERTURA error PARENTESISCIERRE bloqueEstructura;

for_stmt ::= FOR PARENTESISAPERTURA declaracion FIN_EXPRESION expresion FIN_EXPRESION expresion PARENTESISCIERRE bloqueEstructura
           | FOR PARENTESISAPERTURA asignacion FIN_EXPRESION expresion FIN_EXPRESION expresion PARENTESISCIERRE bloqueEstructura
           | FOR PARENTESISAPERTURA error PARENTESISCIERRE bloqueEstructura;

switch_stmt ::= SWITCH PARENTESISAPERTURA expresion PARENTESISCIERRE corcheteIzquierdo case_list default_stmt corcheteDerecho
              | SWITCH PARENTESISAPERTURA expresion PARENTESISCIERRE corcheteIzquierdo case_list corcheteDerecho
              | SWITCH PARENTESISAPERTURA error PARENTESISCIERRE corcheteIzquierdo case_list corcheteDerecho
              ;

case_list ::= case_list case_stmt
            | case_stmt
            | case_list error case_stmt;

case_stmt ::= CASE expresion DOS_PUNTOS lista_sentencias
            | CASE error DOS_PUNTOS lista_sentencias
            ;

default_stmt ::= DEFAULT DOS_PUNTOS lista_sentencias
               | DEFAULT error lista_sentencias;


declaracionArreglo ::= tipo:t IDENTIFICADOR:id acceso_arreglo
                    {:
                        Symbol symbol = (Symbol) CUP$parser$stack.peek();
                        parser.agregarVariable(symbol.left, symbol.right, id.toString(), t.toString());
                    :}
                  | IDENTIFICADOR:id acceso_arreglo
                  | tipo:t IDENTIFICADOR:id acceso_arreglo ASIGNA expresion
                    {:
                        Symbol symbol = (Symbol) CUP$parser$stack.peek();
                        parser.agregarVariable(symbol.left, symbol.right, id.toString(), t.toString());
                    :}
                  | tipo:t IDENTIFICADOR:id acceso_arreglo ASIGNA corcheteIzquierdo parametrosArreglos corcheteDerecho
                    {:
                        Symbol symbol = (Symbol) CUP$parser$stack.peek();
                        parser.agregarVariable(symbol.left, symbol.right, id.toString(), t.toString());
                    :}
                  | IDENTIFICADOR:id acceso_arreglo ASIGNA expresion;

 parametrosArreglos::= parametrosArreglosAux;

parametrosArreglosAux::= parametrosArreglosAux COMA{: RESULT = ","; :}
                   expresion
                   | expresion;

arreglo ::=declaracionArreglo
          |arreglo declaracionArreglo ;

acceso_arreglo ::=  CORCHETEAPERTURA{: RESULT = "abreempaque"; :}
                    expresion
                    CORCHETECIERRE{: RESULT = "cierraempaque"; :}
                 | CORCHETEAPERTURA error CORCHETECIERRE;

parametros ::= lista_parametros
            ;

lista_parametros ::= lista_parametros COMA tipo:t IDENTIFICADOR:id
                    {:
                        Symbol symbol = (Symbol) CUP$parser$stack.peek();
                        parser.agregarVariable(symbol.left, symbol.right, id.toString(), t.toString());
                    :}
                    | tipo:t IDENTIFICADOR:id
                    {:
                        Symbol symbol = (Symbol) CUP$parser$stack.peek();
                        parser.agregarVariable(symbol.left, symbol.right, id.toString(), t.toString());
                    :}
                    | lista_parametros error tipo IDENTIFICADOR;

llamada_funcion ::= IDENTIFICADOR:e {:RESULT = e.toString(); :} llamada_funcion_aux;

llamada_funcion_aux ::=  PARENTESISAPERTURA lista_expresiones PARENTESISCIERRE
                      |  PARENTESISAPERTURA PARENTESISCIERRE
                      |  PARENTESISAPERTURA error PARENTESISCIERRE;

lista_expresiones ::= lista_expresiones COMA{: RESULT = ","; :}
                    expresion
                   | expresion
                   | lista_expresiones error expresion;

return_stmt ::= RETURN expresion
              | RETURN
              | RETURN error;